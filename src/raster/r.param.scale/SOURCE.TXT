r.param.scale

GRASS module that extracts terrain parameters from a DEM.
Uses a multi-scalar approach by taking fitting quadratic
parameters to any size window (via least squares).

Jo Wood, 27th November, 1994.

Modified to include constrained fitting, April, 1995 

Modified to include weighting matrix and double precision arithmetic,
9th May, 1995.

Modified 23rd May to inclue two separate tolerance values for feature detection.

Still to do:
	Fix bug when `constrain through central cell' option selected.
	Create colour tables for all output files (presently on features).

/************************************************************************/
/*** 								      ***/
/***				param.h				      ***/
/***  Header file for use with r.param.scale			      ***/
/***  Jo Wood, ASSIST, Dept of Geography, University of Leicester     ***/
/***  V1.0  - 7th February, 1993				      ***/
/***								      ***/
/************************************************************************/

#include "gis.h" 		/* This MUST be included in all GRASS	*/
				/* programs. It sets up the necessary 	*/
				/* prototypes for GRASS library calls.	*/
#include <math.h>

#define EDGE ((wsize-1)/2)	/* Number of rows/cols that make up the	*/
				/* 'blank' edge around raster.		*/
#define MAX_WSIZE 69		/* Maximum dimensions of window.	*/

				/* Some useful labels.			*/
#define TRUE 1
#define FALSE 0

#define RAD2DEG 57.29578
#define DEG2RAD 0.017453293

#define TINY 1.0e-20;

#define FLAT ((CELL)0)
#define PIT ((CELL)1)
#define CHANNEL ((CELL)2)
#define PASS ((CELL)3)
#define RIDGE ((CELL)4)
#define PEAK ((CELL)5)

#define NUM_CATS ((CELL)6)

#define ELEV   1
#define SLOPE  2
#define ASPECT 3
#define PROFC  4
#define PLANC  5
#define LONGC  6
#define CROSC  7
#define MINIC  8
#define MAXIC  9
#define FEATURE 10

/* The six quadratic coefficients are stored in the array coeff */

#define C_A coeff[1]
#define C_B coeff[2]
#define C_C coeff[3]
#define C_D coeff[4]
#define C_E coeff[5]
#define C_F coeff[6]

/* ------ Declare functions ----- */

float	*vector(),		/* Reserves memory for 1D matrix.	*/
	**matrix();		/* Reserves memory for 2D matrix.	*/

int	*ivector();		/* Reserves memory for 1D int matrix.	*/

CELL	param();		/* Calculates terrain parameters.	*/

/* ------ Global variables ------ */

#ifndef MAIN
    extern			/* Externally defined if not main()	*/
#endif

char		*rast_in_name,	/* Name of the raster file to process.	*/
    		*rast_out_name,	/* Name of the raster output file.	*/

    		*mapset_in,	/* If no problems, these will be names 	*/
		*mapset_out,	/* of mapsets containing the files to 	*/
				/* be processed. Otherwise, error code.	*/

		constrained;	/* Flag that forces quadtratic through	*/
				/* the central cell of the window.	*/

#ifndef MAIN
    extern			/* Externally defined if not main()	*/
#endif

int		fd_in,		/* File descriptor for input and	*/
		fd_out,		/* output raster files.			*/

		wsize,		/* Size of local processing window.	*/

		mparam;		/* Morphometric parameter to calculate.	*/


#ifndef MAIN
    extern			/* Externally defined if not main()	*/
#endif

double      	resoln,		/* Planimetric resolution.		*/
		exponent,	/* Distance weighting exponent.		*/
		zscale,		/* Vertical scaling factor.		*/

	      	slope_tol,	/* Vertical tolerences for surface	*/
		curve_tol;	/* feature identification.		*/

/*********************************************************************************/
/**	                                                            		**/
/**                              r.param.scale                 			**/
/**       GRASS module for extracting multi-scale surface parameters.		**/
/**  										**/
/**                                                         			**/
/**			  Jo Wood, V 1.1, 11th December, 1994			**/
/**                                      					**/
/*********************************************************************************/

#define MAIN

#include "param.h"	

main(argc,argv) 
    int argc;
    char *argv[];
{

    /*--------------------------------------------------------------------------*/
    /*                                 INITIALISE				*/
    /*--------------------------------------------------------------------------*/ 



    /*--------------------------------------------------------------------------*/
    /*                               GET INPUT FROM USER			*/
    /*--------------------------------------------------------------------------*/

    interface(argc,argv);


    /*--------------------------------------------------------------------------*/
    /*                        OPEN INPUT AND OUTPUT RASTER FILES		*/
    /*--------------------------------------------------------------------------*/

    open_files();


    /*--------------------------------------------------------------------------*/
    /*                       PROCESS SURFACE FOR FEATURE DETECTION 		*/
    /*--------------------------------------------------------------------------*/

    process();   

    /*--------------------------------------------------------------------------*/
    /*                     CLOSE ALL OPENED FILES AND FREE MEMORY		*/
    /*--------------------------------------------------------------------------*/

    close_down();

    if (mparam == FEATURE)
    {
	write_cols();
	write_cats();
    }

}
/*********************************************************************************/
/***                               interface()                                 ***/
/***       Function to get input from user and check files can be opened       ***/
/***  									       ***/
/***         Jo Wood, Department of Geography, V1.2, 7th February 1992         ***/
/*********************************************************************************/

#include "param.h"

interface(argc,argv) 

    int	     argc;			/* Number of command line arguments.	*/
    char    *argv[];			/* Contents of command line arguments.	*/

{
    /*--------------------------------------------------------------------------*/
    /*                                 INITIALISE				*/
    /*--------------------------------------------------------------------------*/ 

    struct Option 	*rast_in,	/* Name of input file from command line.*/
    			*rast_out,	/* Holds name of output file.		*/
    			*tol1_val,	/* Tolerance values for feature		*/
			*tol2_val,	/* detection (slope and curvature).	*/
			*win_size,	/* Size of side of local window.	*/ 
			*parameter,	/* Morphometric parameter to calculate.	*/
			*expon,		/* Inverse distance exponent for weight.*/
			*vert_sc;	/* Vertical scaling factor.		*/

    struct Flag		*constr;	/* Forces quadratic through the central	*/
					/* cell of local window if selected.	*/

    G_gisinit (argv[0]);                /* GRASS function which MUST be called	*/
                                      	/* first to check for valid database 	*/
					/* and mapset and prompt user for input.*/

    /*--------------------------------------------------------------------------*/
    /*                            SET PARSER OPTIONS 				*/
    /*--------------------------------------------------------------------------*/

    rast_in   = G_define_option();	/* Request memory for each option.	*/
    rast_out  = G_define_option();
    tol1_val  = G_define_option();	
    tol2_val  = G_define_option();	
    win_size  = G_define_option();	
    parameter = G_define_option();	
    expon     = G_define_option();	
    vert_sc   = G_define_option();	

    constr    = G_define_flag();

    /* Each option has a 'key' (short descriptn), a 'description` (longer one)	*/
    /* a 'type' (eg int, or string), and an indication whether manditory or not	*/

    rast_in->key	  = "in";
    rast_in->description  = "Raster surface layer to process";
    rast_in->type	  = TYPE_STRING;
    rast_in->required	  = YES;


    rast_out->key	  = "out";
    rast_out->description = "Output raster layer containing morphometric parameter";
    rast_out->type	  = TYPE_STRING;
    rast_out->required	  = YES;

    tol1_val->key	  = "s_tol";
    tol1_val->description = "Slope tolerance that defines a `flat' surface (degrees)";
    tol1_val->type	  = TYPE_DOUBLE;
    tol1_val->required	  = NO;
    tol1_val->answer	  = "1.0";

    tol2_val->key	  = "c_tol";
    tol2_val->description = "Curvature tolerance that defines `planar' surface";
    tol2_val->type	  = TYPE_DOUBLE;
    tol2_val->required	  = NO;
    tol2_val->answer	  = "1.0";

    win_size->key	  = "size";
    win_size->description = "Size of processing window (odd number only)";
    win_size->type	  = TYPE_INTEGER;
    win_size->required	  = NO;
    win_size->answer	  = "3";

    parameter->key	  = "param";
    parameter->description= "Morphometric parameter to calculate";
    parameter->type	  = TYPE_STRING;
    parameter->required	  = NO;
    parameter->options	  = "elev,slope,aspect,profc,planc,longc,crosc,minic,maxic,feature";
    parameter->answer  	  = "elev";

    expon->key	  	  = "exp";
    expon->description 	  = "Exponent for distance weighting (0.0-4.0)";
    expon->type	  	  = TYPE_DOUBLE;
    expon->required	  = NO;
    expon->answer	  = "0.0";

    vert_sc->key	  = "zscale";
    vert_sc->description  = "Vertical scaling factor";
    vert_sc->type	  = TYPE_DOUBLE;
    vert_sc->required	  = NO;
    vert_sc->answer	  = "1.0";

    constr->key		  = 'c';
    constr->description   = "Constrain model through central window cell";


    if (G_parser(argc,argv))		/* Actually performs the prompting for	*/
	exit(-1);			/* keyboard input. 			*/

    rast_in_name  = rast_in->answer;	/* Now  keyboard input has been parsed, */
    rast_out_name = rast_out->answer;	/* can place the contents into strings	*/
    wsize	  = atoi(win_size->answer);
    constrained   = constr->answer;
    sscanf(expon->answer,"%lf",&exponent);
    sscanf(vert_sc->answer,"%lf",&zscale);
    sscanf(tol1_val->answer,"%lf",&slope_tol);
    sscanf(tol2_val->answer,"%lf",&curve_tol);

    if ((exponent<0.0) || (exponent >4.0))
	exponent = 0.0;

    if (zscale == 0.0)
	zscale = 1;

    if (!strcmp(parameter->answer,"elev"))
	    mparam = ELEV;
    else
    	if (!strcmp(parameter->answer,"slope"))
	    mparam = SLOPE;
	else
	    if (!strcmp(parameter->answer,"aspect"))
	    	mparam = ASPECT;
	    else
		if (!strcmp(parameter->answer,"profc"))
	    	    mparam = PROFC;
		else
		    if (!strcmp(parameter->answer,"planc"))
	    		mparam = PLANC;
		    else
			if (!strcmp(parameter->answer,"crosc"))
	    		    mparam = CROSC;
			else
			    if (!strcmp(parameter->answer,"longc"))
	    			mparam = LONGC;
			    else
			    	if (!strcmp(parameter->answer,"maxic"))
	    			    mparam = MAXIC;
			    	else
			    	    if (!strcmp(parameter->answer,"minic"))
	    			    	mparam = MINIC;
				    else
			    	    	if (!strcmp(parameter->answer,"feature"))
	    			    	    mparam = FEATURE;
			    	    else
			    	    {
	    				G_warning("Morphometric parameter not recognised. Assuming `Elevation'");
	    				mparam  = ELEV;
    			    	    }

    /*--------------------------------------------------------------------------*/
    /*                      CHECK INPUT RASTER FILE EXISTS			*/
    /*--------------------------------------------------------------------------*/


    if ((mapset_in=G_find_cell2(rast_in_name,""))==NULL)
    {
	char err[256];
	sprintf(err,"Raster map [%s] not available.",rast_in_name);
	G_fatal_error(err);
    }


    /*--------------------------------------------------------------------------*/
    /*                  CHECK OUTPUT RASTER FILE DOES NOT EXIST			*/
    /*--------------------------------------------------------------------------*/

    mapset_out = G_mapset();		/* Set output to current mapset.	*/

    if (G_legal_filename(rast_out_name)==NULL)
    {
        char err[256];
        sprintf(err,"Illegal file name. Please try another.");
        G_fatal_error(err);
    }
    else
    {
        if (G_find_cell2(rast_out_name,mapset_out) !=NULL)
        {
            char err[256];
            sprintf(err,"Raster map [%s] exists.\nPlease try another\n",rast_out_name);
            G_fatal_error(err);
        }
    }

    /*--------------------------------------------------------------------------*/
    /*                 CHECK WINDOW SIZE IS NOT EVEN OR TOO LARGE		*/
    /*--------------------------------------------------------------------------*/

    if ( (wsize/2 != (wsize-1)/2) || (wsize > MAX_WSIZE) )
    {
    	char err[256];
    	sprintf(err,"Inappropriate window size (too big or even)");
    	G_fatal_error(err);
    }

}
/*****************************************************************************/
/***                                                                       ***/
/***                             open_files()                              ***/
/***   	              Opens input and output raster files.  		   ***/
/***               Jo Wood, Project ASSIST, 24th January 1993              ***/
/***                                                                       ***/
/*****************************************************************************/

#include "param.h"


open_files()
{
    /* Open existing file and set the input file descriptor. */

    if ( (fd_in=G_open_cell_old(rast_in_name,mapset_in)) <0)
    {
        char err[256];
        sprintf(err,"ERROR: Problem opening input file.");
        G_fatal_error(err);
    }

    /* Open new file and set the output file descriptor. */

    if ( (fd_out=G_open_cell_new(rast_out_name)) <0)
    {
        char err[256];
        sprintf(err,"ERROR: Problem opening output file.");
        G_fatal_error(err);
    }
}
/****************************************************************/
/* find_normal() - Function to find the set of normal equations	*/
/*		   that allow a quadratic trend surface to be	*/
/*		   fitted through N  points using least squares	*/
/* 		   V.1.0, Jo Wood, 27th November, 1994.  	*/
/****************************************************************/

#include "param.h"

find_normal(normal,w)
    float **normal;		/* Matrix of cross-products.	*/
    double *w;			/* Weights matrix.		*/
{

    int edge=EDGE;		/* Store (wsize-1)/2 to save	*/
				/* on computation 		*/	 

    float  x,y,			/* Local coordinates of window.	*/
	   x1=0,y1=0,		/* coefficients of X-products.	*/
	   x2=0,y2=0,
	   x3=0,y3=0,
	   x4=0,y4=0,
	   xy2=0, x2y=0,
	   xy3=0, x3y=0,
 	   x2y2=0,xy=0,
  	   N=0;
	   
    int   row,col;		/* Pass through local window.	*/


    /* Initialise sums-of-squares and cross products matrix */

    for (row=1; row<=6; row++)
        for (col=1; col<=6;col++)
            normal[row][col] = 0.0;


    /* Calculate matrix of sums of squares and cross products */

    for (row=0; row<wsize; row++)
	for (col=0; col<wsize; col++)
	{
	   x = resoln*(col-EDGE); 
	   y = resoln*(row-EDGE);

	   x4   += x*x*x*x* *(w + row*wsize + col);
 	   x2y2 += x*x*y*y* *(w + row*wsize + col);
	   x3y  += x*x*x*y* *(w + row*wsize + col);
     	   x3   += x*x*x*   *(w + row*wsize + col);
	   x2y  += x*x*y*   *(w + row*wsize + col);
	   x2   += x*x*     *(w + row*wsize + col);

	   y4   += y*y*y*y* *(w + row*wsize + col);
   	   xy3  += x*y*y*y* *(w + row*wsize + col);
	   xy2  += x*y*y*   *(w + row*wsize + col);
	   y3   += y*y*y*   *(w + row*wsize + col);
	   y2   += y*y*     *(w + row*wsize + col);

	   xy   += x*y*     *(w + row*wsize + col);

	   x1   += x*       *(w + row*wsize + col);

	   y1   += y*       *(w + row*wsize + col);

	   N    +=          *(w + row*wsize + col);

	}

   /* --- Store cross-product matrix elements. ---*/

    normal[1][1] = x4;
    normal[1][2] = normal[2][1] = x2y2;
    normal[1][3] = normal[3][1] = x3y;
    normal[1][4] = normal[4][1] = x3;
    normal[1][5] = normal[5][1] = x2y;
    normal[1][6] = normal[6][1] = x2;

    normal[2][2] = y4;
    normal[2][3] = normal[3][2] = xy3;
    normal[2][4] = normal[4][2] = xy2;
    normal[2][5] = normal[5][2] = y3;
    normal[2][6] = normal[6][2] = y2;

    normal[3][3] = x2y2;
    normal[3][4] = normal[4][3] = x2y;
    normal[3][5] = normal[5][3] = xy2;
    normal[3][6] = normal[6][3] = xy;

    normal[4][4] = x2;
    normal[4][5] = normal[5][4] = xy;
    normal[4][6] = normal[6][4] = x1;
    
    normal[5][5] = y2;
    normal[5][6] = normal[6][5] = y1;

    normal[6][6] = N;
}


/****************************************************************/
/* find_obs() - Function to find the observed vector as part of	*/
/*		the set of normal equations for least squares.	*/
/* 		V.1.0, Jo Wood, 11th December, 1994.	 	*/
/****************************************************************/

find_obs(z,obs,w)
    CELL  *z;			/* Local window of elevs.	*/
    float *obs;			/* Observed column vector.	*/
    double  *w;			/* Weighting matrix.		*/
    
{

    int	row,col,		/* Counts through local window.	*/
	edge=EDGE,		/* EDGE = (wsize-1)/2.		*/
	offset;			/* Array offset for weights & z	*/

    float x,y;			/* Local window coordinates.	*/

    for (row=1;row<=6; row++)	/* Initialise column vector.	*/
	obs[row] = 0.0;


    for (row=0;row<wsize; row++)
	for (col=0; col<wsize; col++)
	{
	    x = resoln*(col-EDGE); 
	    y = resoln*(row-EDGE);
 	    offset = row*wsize + col;

	    obs[1] += *(w + offset) * *(z + offset) * x*x ;
	    obs[2] += *(w + offset) * *(z + offset) * y*y ;
	    obs[3] += *(w + offset) * *(z + offset) * x*y ;
	    obs[4] += *(w + offset) * *(z + offset) * x ;
	    obs[5] += *(w + offset) * *(z + offset) * y ;

	    if (!constrained)	/* If constrained, should remain 0.0 */
	 	obs[6] += *(w + offset) * *(z + offset) ;
	}
}


/****************************************************************/
/* find_weight() Function to find the weightings matrix for the */
/*               observed cell values.				*/
/*		 Uses an inverse distance function that can be  */
/*		 calibrated with an exponent (0= no decay,	*/
/*		 1=linear decay, 2=squared distance decay etc.)	*/
/*               V.1.1, Jo Wood, 11th May, 1995.		*/
/****************************************************************/

find_weight(weight_ptr)
    double *weight_ptr;
{
    int row,col;		/* Counts through the rows and	*/
				/* columns of weights matrix.	*/

    double dist,		/* Distance to centre of kernel.*/
	   sum_weight=0;	/* Sum of weights.		*/	


    /* --- Find inverse distance of all cells to centre. ---*/

    for (row=0; row<wsize; row++)
	for (col=0; col<wsize; col++)
	{
	    dist = 1.0 /
		pow(sqrt((EDGE-col)*(EDGE-col) + (EDGE-row)*(EDGE-row))+1.0,exponent);
	    *(weight_ptr + row*wsize + col) = dist;
	}
}

/****************************************************************/
/* lubksub() - Function to perform forward and back substitution*/
/*		on an LU decomposed matrix. Used for solving a  */
/*		set of linear equations.			*/
/*		Adapted from Press et al (1988), p.44.		*/
/* 		V.1.0, Jo Wood, 10th December, 1994.  	  	*/
/****************************************************************/


lubksub(a,n,index,b)
    int     n,		/* Size of side of matrix 		*/
	    *index;	/* Row permutation effected by pivoting */
    float   **a,	/* Matrix to be decomposed. 		*/
	    *b;		/* Input as RHS vector, output as soln.	*/

{
    int    i, ii=0, ip, j;
    float  sum;

    for (i=1; i<=n; i++)
    {
	ip    = index[i];
	sum   = b[ip];
	b[ip] = b[i];

	if (ii)
	    for (j=ii; j<=i-1; j++)
		sum -= a[i][j] * b[j];
	else
	    if (sum)
		ii=i;

	b[i] = sum;
    }

    for (i=n; i>=1; i--)
    {
	sum = b[i];
	for (j=i+1; j<=n; j++)
	    sum -= a[i][j] * b[j];
	
	b[i] = sum/a[i][i];
    }
}

/****************************************************************/
/* ludcomp() - Function to perform LU decomposition of a matrix.*/
/*		Used to find inverse of the matrix when solving */
/*		sets of linear equations.			*/
/*		Adapted from Press et al (1988), pp.43-45.	*/
/* 		V.1.0, Jo Wood, 9th December, 1994.  	  	*/
/****************************************************************/

#include "param.h"
#include <math.h>


ludcomp(a,n,index)
    int     n,		/* Size of side of matrix 		*/
	    *index;	/* Row permutation effected by pivoting */
    float   **a;	/* Matrix to be decomposed. 		*/

{
    int	    i, imax,j,k;
    float   big,dum,sum,temp,
    	    *vv;


    vv = vector(1,n);

    for (i=1; i<=n; i++)    /* Loop over rows, get scaling info.*/
    {
	big = 0.0;
	for (j=1; j<=n; j++)
	    if ((temp=fabs(a[i][j])) > big)
		big = temp;
	
	if (big == 0.0)
	{
	    fprintf(stderr,"Singular matrix - can't perform LU decomposition\n");
	    exit(-1);
	}

	vv[i] = 1.0/big;    /* Save the scaling. */
    }


    for (j=1; j<=n; j++)
    {
	for (i=1; i<j; i++)
	{
	    sum=a[i][j];
	    for (k=1; k<i; k++)
		sum -= a[i][k] * a[k][j];
	    a[i][j] = sum;
	}

	big=0.0;

	for (i=j; i<=n; i++)
	{
	    sum=a[i][j];
	    for (k=1; k<j; k++)
	    	sum -= a[i][k] * a[k][j];
	    a[i][j] = sum;

	    if ( (dum=vv[i]*fabs(sum)) >= big)
	    {
		big = dum;
		imax = i;
	    }
	}

	if (j != imax)
	{
	    for (k=1; k<=n; k++)
	    {
		dum = a[imax][k];
		a[imax][k] = a[j][k];
		a[j][k] = dum;
	    }
	    vv[imax] = vv[j];
	}

	index[j] = imax;
	if (a[j][j] == 0.0)
	    a[j][j] = TINY;

	if (j != n)
	{
	    dum = 1.0/(a[j][j]);

	    for (i=j+1; i<=n; i++)
		a[i][j] *= dum;
	}
    }

    free_vector(vv,1,n);
}


/****************************************************************/
/* nrutil.c 	Functions to reserve memory fo rthe storage of	*/
/*		matrices and vectors. From Press et al (1988)	*/
/*		See Appendix D pp.705-709.			*/
/* 		V.1.0, Jo Wood, 9th December, 1994.  	  	*/
/****************************************************************/

#include <stdio.h>

/****************************************************************/
/* Set up a 1D floating point matrix with range [nl to nh]    	*/
/* See Press et al (1988) p.705.				*/
/****************************************************************/

float *vector(nl,nh)
    int	nl,nh;
{
     float *v;

     v = (float *) malloc((unsigned) (nh-nl+1)*sizeof(float));

     if (!v)
     {
	fprintf(stderr,"ERROR: Can't allocate memory for vector\n");
	exit(-1);
     }	

     return (v-nl); 
}


/****************************************************************/
/* Set up a 1D integer matrix with range [nl to nh]	    	*/
/* See Press et al (1988) p.706.				*/
/****************************************************************/

int *ivector(nl,nh)
    int	nl,nh;
{
     int *v;

     v = (int *) malloc((unsigned) (nh-nl+1)*sizeof(int));

     if (!v)
     {
	fprintf(stderr,"ERROR: Can't allocate memory for vector\n");
	exit(-1);
     }	

     return (v-nl); 
}


/****************************************************************/
/* Set up a 2D floating point matrix				*/
/* with range [nrl to nrh][ncl to nch] 			   	*/
/* See Press et al (1988) p.706.				*/
/****************************************************************/

float **matrix(nrl,nrh,ncl,nch)
    int nrl,nrh,ncl,nch;
{
    int     i;
    float **m;

    m = (float **) malloc((unsigned) (nch-ncl+1)*sizeof(float));

    if (!m) 
    {
	fprintf(stderr,"ERROR: Can't allocate memory for matrix rows\n");
	exit(-1);
    }

    for (i=nrl; i<=nrh; i++)
    {
	m[i] = (float *) malloc((unsigned) (nch-ncl+1)*sizeof(float));

	if (!m[i])
	{
	    fprintf(stderr,"ERROR: Can't allocate memory for matrix columns\n");
	    exit(-1);
	}
    	m[i] -= ncl;
    }

    return (m);
}

    
/****************************************************************/
/* Free memory used for storing 1D floating point matrix.    	*/
/* See Press et al (1988) p.707.				*/
/****************************************************************/
 
free_vector(v,nl,nh)
    float *v;
    int   nl,nh;
{
    free((char *) (v+nl));
}


/****************************************************************/
/* Free memory used for storing 1D integer matrix.	    	*/
/* See Press et al (1988) p.707.				*/
/****************************************************************/
 
free_ivector(v,nl,nh)
    int *v,
         nl,nh;
{
    free((char *) (v+nl));
}


/****************************************************************/
/* Free memory used for storing 2D floating point matrix.    	*/
/* See Press et al (1988) p.708.				*/
/****************************************************************/

free_matrix(m,nrl,nrh,ncl,nch)
    float **m;
    int   nrl,nrh,ncl,nch;
{
    int i;

    for (i=nrh; i>=nrl; i--)
    	free ((char *) (m[i]+ncl));

    free((char *) (m+nrl));
}
/*****************************************************************************/
/***                                                                       ***/
/***                             process()                                 ***/
/***          Reads in a raster file row by row for processing.		   ***/
/***           Jo Wood, Project ASSIST, V1.0 7th February 1993             ***/
/***                                                                       ***/
/*****************************************************************************/

#include "param.h"

process()
{

    /*--------------------------------------------------------------------------*/
    /*                              INITIALISE					*/
    /*--------------------------------------------------------------------------*/ 


    CELL		*row_in,	/* Buffer large enough to hold `wsize' 	*/
			*row_out,	/* raster rows. When GRASS reads in a	*/
					/* raster row, each element is of type	*/
					/* CELL (probably of type int).		*/

			*window_ptr,	/* Stores local terrain window.		*/

			centre;		/* Elevation of central cell in window.	*/

    struct Cell_head	region;		/* Structure to hold region information	*/
    struct Categories	cats;		/* Category file structure for raster	*/

    int			nrows,		/* Will store the current number of 	*/
			ncols,		/* rows and columns in the raster.	*/

			row,col,	/* Counts through each row and column 	*/
					/* of the input raster.			*/

			wind_row,	/* Counts through each row and column	*/
			wind_col,	/* of the local neighbourhood window.	*/

			row_mem,	/* Memory to hold one raster row.	*/

			*index_ptr;	/* Row permutation vector for LU decomp.*/

    float		**normal_ptr,	/* Cross-products matrix.		*/
			*obs_ptr;	/* Observed vector.			*/

    double		*weight_ptr;	/* Weighting matrix for observed values.*/


    /*--------------------------------------------------------------------------*/
    /*               	   GET RASTER AND WINDOW DETAILS			*/
    /*--------------------------------------------------------------------------*/ 

    G_get_window(&region);		/* Fill out the region structure (the	*/
					/* geographical limits etc.)		*/
					
    nrows = G_window_rows();		/* Find out the number of rows and 	*/
    ncols = G_window_cols();		/* columns of the raster.		*/


    if ((region.ew_res/region.ns_res >= 1.01) || /* If EW and NS resolns are	*/
	(region.ns_res/region.ew_res >= 1.01))   /* >1% different, warn user.	*/
    {
	G_warning("E-W and N-S grid resolutions are different. Taking average.");
	resoln = (region.ns_res + region.ew_res)/2;
    }
    else
	resoln = region.ns_res;



    /*--------------------------------------------------------------------------*/
    /*              RESERVE MEMORY TO HOLD Z VALUES AND MATRICES		*/
    /*--------------------------------------------------------------------------*/ 


    row_in = (CELL *) G_malloc(ncols*sizeof(CELL)*wsize);
					/* Reserve `wsize' rows of memory.	*/

    row_out = G_allocate_cell_buf();	/* Initialise output row buffer. 	*/

    window_ptr = (CELL *) G_malloc(wsize*wsize*sizeof(CELL));	
					/* Reserve enough memory for local wind.*/

    weight_ptr = (double *) G_malloc(wsize*wsize*sizeof(double));	
					/* Reserve enough memory weights matrix.*/

    normal_ptr = matrix(1,6,1,6);	/* Allocate memory for 6*6 matrix	*/
    index_ptr  = ivector(1,6);		/* and for 1D vector holding indices	*/
    obs_ptr    = vector(1,6);		/* and for 1D vector holding observed z */


    /* ---------------------------------------------------------------- */
    /* -            CALCULATE LEAST SQUARES COEFFICIENTS              - */
    /* ---------------------------------------------------------------- */
    
    /*--- Calculate weighting matrix. ---*/

    find_weight(weight_ptr);

    /* Initial coefficients need only be found once since they are 
       constant for any given window size. The only element that 
       changes is the observed vector (RHS of normal equations). */

    /*--- Find normal equations in matrix form. ---*/

    find_normal(normal_ptr,weight_ptr);


    /*--- Apply LU decomposition to normal equations. ---*/

    if (constrained){
	ludcomp(normal_ptr,5,index_ptr);   /* To constrain the quadtratic 
					      through the central cell, ignore 
					      the calculations involving the
					      coefficient f. Since these are 
					      all in the last row and column of
					      the matrix, simply redimension.	*/
	/* disp_matrix(normal_ptr,obs_ptr,obs_ptr,5);
	*/
    }
	
    else{
    	ludcomp(normal_ptr,6,index_ptr);
	/* disp_matrix(normal_ptr,obs_ptr,obs_ptr,6);
	*/
    }


    /*--------------------------------------------------------------------------*/
    /*          PROCESS INPUT RASTER AND WRITE OUT RASTER LINE BY LINE		*/
    /*--------------------------------------------------------------------------*/ 

    G_zero_cell_buf(row_out);	
    for (wind_row=0; wind_row<EDGE; wind_row++)
	G_put_map_row(fd_out,row_out);	/* Write out the edge cells as zeros.	*/
    
    for (wind_row=0; wind_row<wsize-1; wind_row++)
    	G_get_map_row(fd_in,row_in+(wind_row*ncols),wind_row);
					/* Read in enough of the first rows to	*/
					/* allow window to be examined.		*/

    for (row=EDGE; row<(nrows-EDGE); row++)
    { 
	G_percent(row+1,nrows-EDGE,2);

	G_get_map_row(fd_in,row_in+((wsize-1)*ncols),row+EDGE); 

	for (col=EDGE; col<(ncols-EDGE); col++)
	{
					/* Find central z value */
	    centre = *(row_in + EDGE*ncols + col);

	    for (wind_row=0; wind_row<wsize; wind_row++)
		for (wind_col=0; wind_col<wsize; wind_col++)

					/* Express all window values relative	*/
					/* to the central elevation.		*/

		    *(window_ptr+(wind_row*wsize)+wind_col) = 
			*(row_in+(wind_row*ncols)+col+wind_col-EDGE) - centre;



    	    /*--- Use LU back substitution to solve normal equations. ---*/

	    find_obs(window_ptr,obs_ptr,weight_ptr);

    	    			/*	disp_wind(window_ptr); 
					disp_matrix(normal_ptr,obs_ptr,obs_ptr,6);
				*/
	
	    if (constrained) 
	    {
	    	lubksub(normal_ptr,5,index_ptr,obs_ptr);
		/*
	 	   disp_matrix(normal_ptr,obs_ptr,obs_ptr,5);
		*/
	    }

	    else
	    {
	    	lubksub(normal_ptr,6,index_ptr,obs_ptr);
	/*	
	 	  disp_matrix(normal_ptr,obs_ptr,obs_ptr,6);
	*/
		
	    }			

	    /*--- Calculate terrain parameter based on quad. coefficients. ---*/

	    if (mparam == FEATURE)
		*(row_out+col) = feature(obs_ptr);
	    else
	        *(row_out+col) = param(mparam,obs_ptr);

	    if (mparam == ELEV)
		*(row_out+col) += centre;	/* Add central elevation back */
	
	}				
	G_put_map_row(fd_out,row_out);	/* Write the row buffer to the output	*/
					/* raster.				*/
         
					/* 'Shuffle' rows down one, and read in	*/
					/*  one new row.			*/
	for (wind_row=0;wind_row<wsize-1;wind_row++)
	   for (col=0; col<ncols; col++)
            *(row_in+(wind_row*ncols)+col) = *(row_in+((wind_row+1)*ncols)+col);
    }

    G_zero_cell_buf(row_out);	
    for (wind_row=0; wind_row<EDGE; wind_row++)
	G_put_map_row(fd_out,row_out);	/* Write out the edge cells as zeros.	*/

    /*--------------------------------------------------------------------------*/
    /*     FREE MEMORY USED TO STORE RASTER ROWS, LOCAL WINDOW AND MATRICES	*/
    /*--------------------------------------------------------------------------*/ 

    free(row_in);
    free(row_out);
    free(window_ptr);
    free_matrix(normal_ptr,1,6,1,6);
    free_vector(obs_ptr,1,6);
    free_ivector(index_ptr,1,6);
}
/*****************************************************************************/
/***                                                                       ***/
/***                                param()                                ***/
/***     Returns a terrain parameter based on the 6 quadratic coefficents  ***/
/***	 that define a local trend surface. 			    	   ***/
/***     Jo Wood, Department of Geography, V2.0 15th December, 1994        ***/
/***                                                                       ***/
/*****************************************************************************/

#include "param.h"
#include <math.h>


CELL param(ptype,coeff)
    int ptype;			/* Type of terrain parameter to calculate */
    float *coeff;		/* Set of six quadratic coefficents.	  */

{

    /* Quadratic function in the form of
	
		z = ax^2 + by^2 + cxy + dx + ey +f			  */

    double	a=C_A*zscale,		/* Rescale coefficients if a 	  */
		b=C_B*zscale,		/* Z scaling is required.	  */
		c=C_C*zscale,
		d=C_D*zscale,
		e=C_E*zscale,
		f=C_F;			/* f does not need rescaling as   */
					/* it is only used for smoothing. */

    switch(ptype)
    {
	case ELEV:
		return((CELL)rint(f));
		break;

	case SLOPE:
		return((CELL)rint(atan(sqrt(d*d + e*e))*RAD2DEG));
		break;

	case ASPECT:
		return((CELL)rint(atan2(e,d)*RAD2DEG));
		break;

	case PROFC:
		if ((d == 0) && (e == 0))
		    return((CELL)0);
		else
		    return((CELL)rint(-200.0*resoln*wsize*(a*d*d + b*e*e + c*e*d) /
			   	      ((e*e + d*d) * pow(1.0 + d*d + e*e,1.5)) ));
		break;

	case PLANC:
		if ((d == 0) && (e == 0))
		    return((CELL)0);
		else
		    return((CELL)rint(200.0*resoln*wsize*(b*d*d + a*e*e - c*d*e) /
		 		      powf(e*e + d*d,1.5) ));
		break;

	case LONGC:
		if ((d == 0) && (e ==0))
		    return((CELL) 0);
		else	
		    return((CELL)rint(-20.0*resoln*wsize*(a*d*d + b*e*e + c*d*e)/(d*d + e*e)));
	case CROSC:
		if ((d == 0) && (e ==0))
		    return((CELL) 0);
		else	
		    return((CELL)rint(-20.0*resoln*wsize*(b*d*d + a*e*e - c*d*e)/(d*d + e*e)));

	case MINIC:
		return((CELL)rint(20.0*resoln*wsize*(-a-b-sqrt((a-b)*(a-b) + c*c))));

	case MAXIC:
		return((CELL)rint(20.0*resoln*wsize*(-a-b+sqrt((a-b)*(a-b) + c*c))));

	default:
		return((CELL)0);
    }
}
/*****************************************************************************/
/***                                                                       ***/
/***                              feature()                                ***/
/***     Returns a terrain feature based on the 6 quadratic coefficents    ***/
/***	 that define a local trend surface. 			    	   ***/
/***     Jo Wood, Department of Geography, V2.1 30th March, 1995           ***/
/***                                                                       ***/
/*****************************************************************************/

#include "param.h"
#include <math.h>


CELL feature(coeff)
    float *coeff;		/* Set of six quadratic coefficents. 	*/

{

    /* Quadratic function in the form of
	
		z = ax^2 + by^2 + cxy + dx + ey +f			*/

    double	a=C_A*zscale,	/* Scale parameters if necessary.	*/
		b=C_B*zscale,
		c=C_C*zscale,
		d=C_D*zscale,
		e=C_E*zscale,
		f=C_F*zscale;

    double maxic,minic,		/* Minimium and maximum curvature.	*/
	   slope,		/* Slope.				*/
	   crosc;		/* Cross-sectional curvature.		*/

    minic = 20*wsize*resoln*(-a-b-sqrt((a-b)*(a-b) + c*c));
    maxic = 20*wsize*resoln*(-a-b+sqrt((a-b)*(a-b) + c*c));
    slope = RAD2DEG*atan(sqrtf((d*d) + (e*e)));
    crosc = -20*wsize*resoln*(b*d*d + a*e*e - c*d*e)/(d*d + e*e);


    /* Case 1: Surface is sloping. Cannot be a peak,pass or pit. Therefore
	       calculate the cross-sectional curvature to characterise as
	       channel, ridge or planar.				   */

    if (slope > slope_tol)
    {
	if (crosc > curve_tol)
	    return(RIDGE);

	if (crosc < -curve_tol)
	    return(CHANNEL);

	else
	    return(FLAT);
    }


    /* Case 2: Surface has (approximately) vertical slope normal. Feature
	       can be of any type.					  */

    if (maxic > curve_tol)
    {
	if (minic > curve_tol)
	    return(PEAK);

	if (minic < -curve_tol)
	    return(PASS);

	else
	    return (RIDGE);
    }
    else
    	if (minic < -curve_tol)
    	{
	    if (maxic < -curve_tol)
	    	return (PIT);
	
	    else
	   	return (CHANNEL);
    	}

    return (FLAT);
}
/*****************************************************************************/
/***                                                                       ***/
/***                            write_cats()                               ***/
/***   	        Writes out category file for morphometric features	   ***/
/***               Jo Wood, Project ASSIST, 7th February 1995              ***/
/***                                                                       ***/
/*****************************************************************************/

#include "param.h"

write_cats()
{
    /*------------------------------------------------------------------------*/
    /*                            INITIALISE                                  */
    /*------------------------------------------------------------------------*/ 

    struct Categories	cats;

    G_init_cats(NUM_CATS,"Surface Features",&cats);

    /*------------------------------------------------------------------------*/
    /*                      FILL OUT CATEGORIES STRUCTURE                     */
    /*------------------------------------------------------------------------*/ 

    
    G_set_cat(PIT,    " Pit",          &cats);
    G_set_cat(PEAK,   " Peak",         &cats);
    G_set_cat(RIDGE,  " Ridge",        &cats);
    G_set_cat(CHANNEL," Channel",      &cats);
    G_set_cat(PASS,   " Pass (saddle)",&cats);
    G_set_cat(FLAT,   " Planar",       &cats);


    /*------------------------------------------------------------------------*/
    /*                     WRITE OUT CATEGORIES STRUCTURE                     */
    /*------------------------------------------------------------------------*/ 

    if (G_write_cats(rast_out_name,&cats) <=0)
    {
	char warn[255];
	sprintf(warn,"Can't write category file for <%s>",rast_out_name);
	G_warning(warn);
    }

    G_free_cats(&cats);

}
/*****************************************************************************/
/***                                                                       ***/
/***                            write_cols()                               ***/
/***   	         Writes out colour file for morphometric features
/***               Jo Wood, Project ASSIST, 21st February 1995             ***/
/***                                                                       ***/
/*****************************************************************************/

#include "param.h"


write_cols()
{
    /*------------------------------------------------------------------------*/
    /*                            INITIALISE                                  */
    /*------------------------------------------------------------------------*/ 

    struct Colors	colours;

    G_init_colors(&colours);

    /*------------------------------------------------------------------------*/
    /*                       FILL OUT COLORS STRUCTURE                        */
    /*------------------------------------------------------------------------*/ 

    G_add_color_rule(	FLAT,   255,255,255,			/* White      */
    			PIT,    0,  0,  0,  &colours);		/* Black      */
    G_add_color_rule(	CHANNEL,0,  0,  255,			/* Blue       */
    			PASS,   0,  255,0,  &colours);		/* Green      */
    G_add_color_rule(	RIDGE,  255,255,0,			/* Yellow     */
    			PEAK,   255,0,  0,  &colours);		/* Red        */
 

    /*------------------------------------------------------------------------*/
    /*                       WRITE OUT COLORS STRUCTURE                       */
    /*------------------------------------------------------------------------*/ 

    G_write_colors(rast_out_name,mapset_out,&colours);

    G_free_colors(&colours);

}
/*****************************************************************************/
/***                                                                       ***/
/***                             close_down()                              ***/
/***   	   Closes all input and output raster files and frees memory.	   ***/
/***               Jo Wood, Project ASSIST, 7th February 1993              ***/
/***                                                                       ***/
/*****************************************************************************/

#include "param.h"


close_down()
{
    /* Close connection with existing input raster. */

    G_unopen_cell(fd_in);

    /* Write output raster file and close connection. */

    G_close_cell(fd_out);
}
