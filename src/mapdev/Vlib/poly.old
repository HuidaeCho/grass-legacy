#include "digit.h"
#include "linkm.h"
#include <math.h>

/*
**
** Vect_get_point_in_area (Map, area, x, y)  get point inside area
** Vect_get_point_in_poly (Points, X, Y)     get point inside polygon
**
**   This routine returns a point which is guaranteed to be somewhere 
**   inside the given polygon.  It will use the polygon centroid that
**   is inside, else:
** 
**   it picks a the median Y value to form a line segment from the smallest
**   to the largest X value.  Then it takes a breadth first approach
**   at dividing the segments untill it finds a point which is inside the
**   polygon.
**
**   I have not proven that this is guaranteed to find a point inside the
**   polygon, but it sounds good.
*/

static void destroy_links ();
static int Vect__divide_and_conquer ();

/* returns 0 on success and -1 on failure */
int
Vect_get_point_in_area (Map, area, x, y)
    struct Map_info *Map;
    int area;
    double *x, *y;
{
    static struct line_pnts *BPoints;
    static int first_time = 1;
    int n_points;

    if (first_time)
    {
	BPoints = Vect_new_line_struct ();
	first_time = 0;
    }
    if (0 > (n_points = Vect_get_area_points (Map, area, BPoints)))
	return -1;

    return Vect_get_point_in_poly (BPoints, x, y);
}

struct Slink {
    double x;
    struct Slink *next;
};
	
/* returns 0 on success and -1 on failure */
int
Vect_get_point_in_poly (Points, X, Y)
    struct line_pnts *Points;
    double *X, *Y;
{
    double cent_x, cent_y;
    struct Slink *Head;
    static VOID_T *Token;
    struct Slink *tmp;
    static int first_time = 1;
    register int i;
    double x_max, x_min;
    int ret;

	/* get centroid */
    Vect_find_poly_centroid (Points, &cent_x, &cent_y);
	/* is it w/in poly? */
    if (dig_point_in_poly (cent_x, cent_y, Points))
    {
	*X = cent_x;
	*Y = cent_y;
	/*
	return 0;
	*/
/*********  Check for point in islands */
    }

/* guess we have to do it the hard way... */
    /* get min and max x values */
    x_max = x_min = Points->x[0];
    for (i = 0 ; i < Points->n_points ; i++)
    {
	if (x_min > Points->x[i]) x_min = Points->x[i];
	if (x_max < Points->x[i]) x_max = Points->x[i];
    }


/* init the linked list */
    if (first_time)
    {
	/* will never call link_cleanup ()  */
	link_exit_on_error (1);	/* kill program if out of memory */
	Token = (VOID_T *) link_init (sizeof (struct Slink));
	first_time = 0;
    }

    Head = (struct Slink *) link_new (Token);
    tmp = (struct Slink *) link_new (Token);

    Head->next = tmp;
    tmp->next = NULL;

    Head->x = x_min;
    tmp->x = x_max;

    *Y = cent_y;   /* pick line segment (x_min, cent_y) - (x_max, cent_y) */
    ret = Vect__divide_and_conquer (Head, Points, Token, X, Y, 10);

    destroy_links (Head);

    if (ret < 0)
    {
	fprintf (stderr, "Could not find point in polygon\n");
	return -1;
    }

/*DEBUG*/ fprintf (stderr, "Found point in %d iterations\n", 10 - ret);

    return 0;
}


/*
** provide a breadth first binary search of real space along line segment
**  looking for a point w/in the polygon.
**
**  This routine walks along the list of points on line segment
**  and divides each pair in half. It sticks that new point right into
**  the list, and then checks to see if it is inside the poly. 
**
**  after going through the whole list, it calls itself.  The list 
**   now has a whole extra set of points to divide again.
**
**  returns # levels it took  or -1 if exceeded # of levels
*/
static int
Vect__divide_and_conquer (Head, Points, Token, X, Y, levels)
    struct Slink *Head;
    struct line_pnts *Points;
    VOID_T *Token;
    double *X, *Y;
    int levels;
{
    struct Slink *A, *B, *C;

/*DEBUG*/ fprintf (stderr, "		LEVEL %d\n", levels);
    A = Head;
    B = Head->next;

    do {
	C = (struct Slink *) link_new (Token);
	A->next = C;
	C->next = B;

	C->x = (A->x + B->x) / 2.;

	if (dig_point_in_poly (C->x, *Y, Points))
	{
	    *X = C->x;
	    return levels;
	}

	A = B;
	B = B->next;
    } while (B != NULL);

    /*
    **  If it got through the entire loop and still no hits,
    **   then lets go a level deeper and divide again.
    */

    if (levels <= 0)
	return -1;

    return Vect__divide_and_conquer (Head, Points, Token, X, Y, --levels);
}


static void
destroy_links (Head)
    struct Slink *Head;
{
    struct Slink *p, *tmp;

    p = Head;

    while (p != NULL)
    {
	tmp = p->next;
	link_destroy (Head, p);
	p = tmp;
    }
}







/* returns 0 always */

Vect_find_poly_centroid (points, cent_x, cent_y)
    struct line_pnts *points;
    double *cent_x, *cent_y;
{
    int i;
    double *xptr1, *yptr1;
    double *xptr2, *yptr2;
    double cent_weight_x, cent_weight_y;
    double len, tot_len;

    tot_len = 0.0;
    cent_weight_x = 0.0;
    cent_weight_y = 0.0;

    xptr1 = points->x;
    yptr1 = points->y;
    xptr2 = points->x + 1;
    yptr2 = points->y + 1;

    for(i=1; i<points->n_points; i++)
    {
	len = hypot(*xptr1-*xptr2, *yptr1-*yptr2);
	cent_weight_x += len * ((*xptr1 + *xptr2) / 2.);
	cent_weight_y += len * ((*yptr1 + *yptr2) / 2.);
	tot_len += len;
	xptr1++ ; xptr2++ ; yptr1++; yptr2++;
    }

    if (tot_len != 0.0)
    {
	*cent_x = cent_weight_x / tot_len;
	*cent_y = cent_weight_y / tot_len;
    }
    
    return(0);
}
