/*  %W%  %G%  */
/*
**  Written by Dave Gerdes  5/1988
**  US Army Construction Engineering Research Lab
*/

#include "digit.h"
#include "head.h"
#include <stdio.h>

int tell_area_label ();
int tell_area_unlabel ();
int make_area_label ();
int tell_line_label();	/* function called by find_line_with_mouse() */

static double local_x;	/* filled by label_area  */
static double local_y;	/* used by tell_area_label */
static int local_area;
static int local_prev;
static P_AREA local_struct;

int
Label()
{
    int command;		/* command user enters */
    int ret;			/* get return values from subrs */
    int Pass;			/* Holds value to return to caller */
    int chr;
    int cat;

    Pass = 0;
    Set_G_Mask (MG_LABEL, OFF);

    while(1) 
    {
	_Clear_info ();
	update_global_menu ();
	Write_generic_win(&M_label);

	if ((command = get_menu_command (&M_label, &chr)) > 0)
	{
	    switch(command)
	    {
	    case MLC_LAREA:
		while (1)
		{
		    Clear_base ();
		    Clear_info ();
		    cat = ask_cat ();
		    if (!cat) break;
		    label_area (CM, cat);
		}
		break;
	    case MLC_LLINE:
		while (1)
		{
		    Clear_base ();
		    Clear_info ();
		    cat = ask_cat ();
		    if (!cat) break;
		    label_lines (CM, cat);
		}
		break;
	    case MLC_LSITE:
		while (1)
		{
		    Clear_base ();
		    Clear_info ();
		    cat = ask_cat ();
		    if (!cat) break;
		    label_sites (CM, cat);
		}
		break;
	    case MLC_LLINES:
		Clear_base ();
		Clear_info ();
		if (!curses_yes_no_default (2, "This function will label EVERY unlabeled line. Proceed?", 0))
		    break;
		cat = ask_cat ();
		if (!cat) break;
		label_all_lines (CM, cat);
		break;
	    case MLC_ULAREA:
		unlabel_area (CM);
		break;
	    case MLC_ULLINE:
		unlabel_lines (CM);
		break;
	    case MLC_ULSITE:
		unlabel_sites (CM);
		break;
	    case MLC_SLINES:
		display_llines (CM);
		break;
	    case MLC_SAREAS:
		display_lareas (CM);
		break;
	    case MLC_QUIT:
		Pass = 0;
		goto LABEL_END;
		break;
	    default:
		break;	 /* should not get here */
	    }
	}
	else
	{
	    if ((ret = global_menu (chr, &M_label)) > 0)
	    {
		Pass = ret;
		break;  /* return and execute new command */
	    }
	    if (ret < 0)
		BEEP;
	}
    }
LABEL_END:
    
    Set_G_Mask (MG_LABEL, ON);
    return (Pass);
}

ask_cat ()
{
    int cat;
    char buf[500];

    Write_info ( 4, "   Enter Category Number (0 to END): ") ;
    Get_curses_text (buf) ;
    /*
    sscanf (buf, "%d", &cat) ;
    return (cat);
    */
    return (atoi (buf));
}

/* ask user to select area to label and create  new area and label */
/* returns 0 OK  or -1 no area created */
label_area  (map, cat)
    struct Map_info *map;
    int cat;
{
    int line, area, att;
    double x, y;
    int ret;

    while (1)
    {
	Clear_info ();
	/* find_line_with_mouse  fills Gpoints */
	new_point_with_mouse (&x, &y, "Select point within area:");
	if (x == 0.0 && y == 0.0)
	    return (-1);

	/* change color so they know something happend */
	R_standard_color (dcolors[CLR_AMARK]); 
	Blot (&x, &y);
	local_x = x; local_y = y;	/* store these for tell_area_label() */

	local_prev = 0;	/* reset static flag */
	/* find_line loads global struct: Garea */
	if (0>=(line = find_line_with_mouse (AREA, "Select a Boundary line:", tell_area_label)))
	{
	    unset_dot (x, y);
	    continue;
	}
	if (make_area_label (map, line) >= 0)	/* completed an area? */
	{

	  if (1==(ret=mouse_yes_no ("Accept this area? ")) || ret==3) /* yes? */
	  {
	    /* if this far, then an area is selected, either old or new */
	    /*  if local_area, then is old, else  Garea holds area info */
	    if (local_area)
	    {
		P_ATT *AP;
		char buf[100];

		if (!map->Area[local_area].att)
		{
/*DEBUG*/ debugf ("Label area: creating new attribute\n");
		    map->Area[local_area].att = 
			dig_new_att (map, local_x, local_y, AREA, local_area, cat);
		}
		else
		{
/*DEBUG*/ debugf ("Label area: attribute exists changing it\n");
		    AP = &(map->Att[map->Area[local_area].att]);
		    sprintf (buf, "%d", AP->cat);
		    R_standard_color (dcolors[CLR_ERASE]);
		    _Blot (&(AP->x), &(AP->y));
		    Adot (&(AP->x), &(AP->y), buf);
		    AP->cat = cat;
		    AP->x = x;
		    AP->y = y;
		    dig_update_att (map, map->Area[local_area].att);
		}

		display_area (local_area, map);
		area = local_area;
	    }
	    else
	    {
/*DEBUG*/ debugf ("Label area: new area:  ");
		area = dig_new_area (map, &Garea, 0);	/* give dummy att info*/
		if (area < 0) return (-1);		/* out of memory? */
/*DEBUG*/ debugf (" creating new attribute\n");
		att = dig_new_att (map, x, y, AREA, area, cat);	/* create new att  */
		if (att < 0)
		    return (-1);
		if (att < 0) return (-1);		/* out of memory? */
		map->Area[area].att = att;		/* stick in att info */
		display_area (area, map);
	    }
	    display_area_label (area, map);
	    Changes_Made = 1;
	  }
	  else	/* cleanup and leave */
	  {
	    display_line (map->Line[line].type, &Gpoints, line, map);
	    R_standard_color (dcolors[CLR_ERASE]);
	    Blot (&local_x, &local_y);
	    if (Disp_outline && local_area && AREA_LABELED (&(map->Area[local_area])))
		display_area (local_area, map);
	    else
		if (local_area)
		    reset_area (local_area, map);
		else
		    _reset_area (&Garea, map);
	  }
	}
	else  /* area not made */
	{
	    R_standard_color (dcolors[CLR_ERASE]);
	    Blot (&local_x, &local_y);
	}
    }
}

label_lines  (map, cat)
    struct Map_info *map;
    int cat;
{
    int line;

    while (1)
    {
	Clear_info ();
	/* find_line_with_mouse  fills Gpoints */
	if (0 >= (line = find_line_with_mouse (LINE | AREA, "Choose line:", tell_line_label)))
	{
	    return (-1);
	}

	if (0 > label_line (map, line, cat, &Gpoints))
	    return (-1);
    }
}

label_sites  (map, cat)
    struct Map_info *map;
    int cat;
{
    int line;

    while (1)
    {
	Clear_info ();
	/* find_line_with_mouse  fills Gpoints */
	if (0 >= (line = find_line_with_mouse (DOT, "Choose site:", tell_line_label)))
	{
	    return (-1);
	}

	if (0 > label_line (map, line, cat, &Gpoints))
	    return (-1);
    }
}
    
label_line (map, line, cat, Points)
    struct Map_info *map;
    int line;
    int cat;
    struct line_pnts *Points;
{
    int att;
    double x, y;
    int line_type;


    line_type = map->Line[line].type;

    /* area and line lines all get labelled as LINE */
    if (line_type == AREA)
	line_type = LINE;

    /* remove old label from screen */
    erase_line (map->Line[line].type, Points, line, map);
    if (map->Line[line].att)
    {
	map->Att[map->Line[line].att].cat = cat;
	Changes_Made = 1;
	dig_update_att (map, map->Line[line].att);
    }
    else
    {
	get_line_center (&x, &y, Points);
	att = dig_new_att (map, x, y, line_type, line, cat);
	if (att < 0)
	    return (-1);
	map->Line[line].att = att;
	Changes_Made = 1;
    }
    display_line (map->Line[line].type, Points, line, map);
    return (0);
}

unlabel_area  (map, cat)
    struct Map_info *map;
    int cat;
{
    int line, area, att;
    double x, y;

    while (1)
    {
	Clear_info ();
	/* find_line_with_mouse  fills Gpoints */
	new_point_with_mouse (&x, &y, "Select point within area:");
	if (x == 0.0 && y == 0.0)
	{
	    unset_dot (x, y);
	    return (-1);
	}
	R_standard_color (dcolors[CLR_AMARK]);
	Blot (&x, &y);
	local_x = x; local_y = y;	/* store these for tell_area_label() */

	if (0>=(line = find_line_with_mouse (AREA, "Select a Boundary line:", tell_area_unlabel)))
	{
	    /* is a bug here.  if accept a line that does not make an area */
	    /* this line will stay highlit */
	    /* if they aborted w/out choosing a line, there will be no line */
	    /* lit.  the previous is the one that needs to be taken care of */
	    /* should probly be fixed in find_w_mouse */
	    unset_dot (x, y);
	    continue;
	}
	unset_dot (x, y);

	if (local_area && AREA_LABELED (&(map->Area[local_area])))
	{
	    P_AREA *Area;
	    P_ATT *Att;
	    char buf[50];

	    Area = &(map->Area[local_area]);
	    Changes_Made = 1;

	    Att = &(map->Att[Area->att]);	

	    /* remove cat on screen */
	    R_standard_color (dcolors[CLR_ERASE]);
	    _Blot (&(Att->x), &(Att->y));
	    sprintf (buf, "%d", Att->cat);
	    Adot (&(Att->x), &(Att->y), buf);
	    _reset_area (Area, map);

	    dig_del_att (map, Area->att);	/* delete its attribute */
	    Area->att = 0;
	    /*  this is too drastic, lets leave the area alone
	    Del_area (map, local_area);
	    */
	}
	else
	{
/*DEBUG*/ debugf ("No attribute.  no action taken\n");
	}
    }
}

unlabel_lines  (map, cat)
    struct Map_info *map;
    int cat;
{
    int line;

    while (1)
    {
	Clear_info ();
	/* find_line_with_mouse  fills Gpoints */
	if (0 >= (line = find_line_with_mouse (LINE | AREA, "Choose labeled line:", tell_line_label)))
	{
	    return (-1);
	}
	if (map->Line[line].att)
	{
	    erase_line (map->Line[line].type, &Gpoints, line, map);
	    dig_del_att (map, map->Line[line].att);
	    map->Line[line].att = 0;
	    Changes_Made = 1;
	    display_line (map->Line[line].type, &Gpoints, line, map);
	}
    }
}

unlabel_sites (map, cat)
    struct Map_info *map;
    int cat;
{
    int line;

    while (1)
    {
	Clear_info ();
	/* find_line_with_mouse  fills Gpoints */
	if (0 >= (line = find_line_with_mouse (DOT, "Choose labeled Site:", tell_line_label)))
	    return (-1);
	if (map->Line[line].att)
	{
	    dig_del_att (map, map->Line[line].att);
	    map->Line[line].att = 0;
	    Changes_Made = 1;
	    display_line (map->Line[line].type, &Gpoints, line, map);
	}
    }
}

tell_line_label (map, line)
    struct Map_info *map;
    int line;
{
    char buf[200];

    if (map->Line[line].att)
    {
	sprintf (buf, "Line is Category %d", map->Att[map->Line[line].att].cat);
	Write_info (2, buf);
    }
    else
	Write_info(2, "Line is Not labeled");
    return (0);
}


/* Document this !!   return values?? */
/* called by find_line_w_mouse */
make_area_label (map, line)
    struct Map_info *map;
    int line;
{
    int area;
    char buf[200];

    if (local_prev)
	if (local_area)
	    display_area (local_area, map);
	else
	    _display_area (&Garea, map);
	
    if ((area = check_area (map, line, local_x, local_y)) > 0)
    {
	local_prev = 1;
	local_area = area;

	if (Auto_Window && area_outside_window (&(map->Area[local_area])))
	{
	    P_AREA *Area;

	    Area = &(map->Area[local_area]);
	    expand_window (Area->N, Area->S, Area->E, Area->W);
	}

	highlight_area (area, map);
	if (map->Area[area].att)
	    sprintf (buf, "Area is Category %d", map->Att[map->Area[area].att].cat);
	else
	    sprintf (buf, "Area is not labeled");
	Write_info(2, buf);
	return (1);
    }
    else
    {
	local_area = 0;
	if (0 >= build_area (map, local_x, local_y, line, &Garea))	/* create new area */
	{
	    BEEP;
	    Write_info (2, "Could not create area.");
	    sleep (2);
	    local_prev = 0;
	    display_line (AREA, &Gpoints, line, map);	/* undo highlight */
	    return (-1);	/* NO Current Area */
	}
	else
	{
	    if (Auto_Window && area_outside_window (&Garea))
		expand_window (Garea.N, Garea.S, Garea.E, Garea.W);
	    _highlight_area (&Garea, map);
	}
    }

    return (0);
}

tell_area_unlabel (map, line)
    struct Map_info *map;
    int line;
{
    int area;
    char buf[1024];

    Clear_info ();
    local_area = 0;
    if ((area = check_area (map, line, local_x, local_y)) > 0 &&
	map->Area[area].att)
    {
	sprintf (buf, "Area is labeled as category %d", 
	    map->Att[map->Area[area].att].cat);
	Write_info (1, buf);
	local_area = area;
	return (0);
    }
    else
    {
	Write_info (1, "Area is not labeled");
	local_area = 0;
	return (-1);
    }
}


tell_area_label (map, line)
    struct Map_info *map;
    int line;
{
    int area;
    char buf[1024];

    Clear_info ();
    local_area = 0;
    if ((area = check_area (map, line, local_x, local_y)) > 0 &&
	map->Area[area].att)
    {
	sprintf (buf, "Area is labeled as category %d", 
	    map->Att[map->Area[area].att].cat);
	Write_info (1, buf);
	local_area = area;
    }
    else
    {
	Write_info (1, "Area is not labeled");
	local_area = 0;
    }
    return (0);
}

/* given x, y  and line number,  check if x, y is within a predefined 
**  area bounded by  line
*/
check_area (map, line, x, y)
    struct Map_info *map;
    int line;
    double x, y;
{
    line = ABS (line);
/*DEBUG*/ debugf ("Check_area: line %d R %d L %d (%lf, %lf)\n", line, map->Line[line].right, map->Line[line].left, x, y);
    if (map->Line[line].right > 0)   /* ISLE */
	if (dig_point_in_area (map, x, y, &(map->Area[map->Line[line].right])) > 0.)
	{
/*DEBUG*/ debugf ("Check_area:  POINT IN AREA(right)  returned TRUE\n");
	    return (map->Line[line].right);
	}
    if (map->Line[line].left > 0)   /* ISLE */
	if (dig_point_in_area (map, x, y, &(map->Area[map->Line[line].left])) > 0.)
	{
/*DEBUG*/ debugf ("Check_area:  POINT IN AREA(left) returned TRUE\n");
	    return (map->Line[line].left);
	}
/*DEBUG*/ debugf ("Check_area:  POINT IN AREA returned FALSE\n");
    return (0);
}

/* need a point to place label on line.
**  for a line w/ > 2 points just pick the middle point
**  for a line w/ only 2 points we dont want to label the node (> 1 line)
**  so we calculate a mid-point
*/
get_line_center (x, y, Points)
    double *x, *y;
    struct line_pnts *Points;
{
    int which_coor;

    if (Points->n_points < 1)
	return (-1);

    if (Points->n_points < 2)
    {
	*x = Points->x[0];
	*y = Points->y[0];
	return (0);
    }
    if (Points->n_points > 2)
    {
	which_coor = Points->n_points >> 1;
	*x = Points->x[which_coor];
	*y = Points->y[which_coor];
	return (0);
    }

    /* calculate the middle of a two points line */
    *x = (Points->x[0] + Points->x[1]) / 2.0;
    *y = (Points->y[0] + Points->y[1]) / 2.0;
    return (0);
}

display_labeled_areas (map)
    struct Map_info *map;
{
    display_all_areas (map);
}

display_all_areas (map)
    struct Map_info *map;
{
    register int i;
    int ret = 0 ;
    char buf[100];

    set_keyboard ();
    for (i = 1 ; i <= map->n_areas ; i++)
    {
	if (key_hit (buf))
	{
	    if (*buf == ESC)
	    {
		ret = -1;
		break;
	    }
	}
	if (AREA_LABELED (&(map->Area[i])))
	    display_area (i, map);
    }
    unset_keyboard ();
    R_flush ();
    return (ret);
}

display_labeled_lines (map)
    struct Map_info *map;
{
    register int i;
    for (i = 1 ; i <= map->n_lines ; i++)
	if (LINE_ALIVE (&(map->Line[i])) && map->Line[i].att && 
		line_in_window (&(map->Line[i]))) 
	{
	    dig__Read_line (&Gpoints, map->digit, map->Line[i].offset);
	    _display_line (map->Line[i].type, &Gpoints, i, map);
	}
    R_flush ();
}

/* this is (no longer) a hidden feature for whatever use */
label_all_lines (map, cat)
    struct Map_info *map;
    int cat;
{
    int line, att;
    double x, y;

    Write_info (2, "Processing ...");
    for (line = 1 ; line <= map->n_lines ; line++)
    {
	Clear_info ();

	/* only do this for LINE lines */
	/* if already labeled, leave it alone */
	if (LINE_ALIVE (&(map->Line[line])) && map->Line[line].type == LINE && !map->Line[line].att)
	{

	    if(0 > dig__Read_line(&Gpoints, map->digit, map->Line[line].offset))
		return (-1);
	    /*
	    erase_line (map->Line[line].type, &Gpoints, line, map);
	    */
	    get_line_center (&x, &y, &Gpoints);
	    att = dig_new_att (map, x, y, LINE, line, cat);
	    if (att < 0)
		return (-1);
	    map->Line[line].att = att;
	    Changes_Made = 1;
	    display_line (map->Line[line].type, &Gpoints, line, map);
	}
    }
    Write_info (2, "Processing ...   DONE");
}
