#include "xgrass_dlib.h"
#include "gis.h"
#include "image.h"



char           *malloc();

XImage *
#ifdef _NO_PROTO
XgdRasterImage(obj, scrn, vinfo, name, mapset, colorsfixedmin)
     XgdObject      *obj;
     int             scrn;
     XVisualInfo     vinfo;
     char           *name, *mapset;
     int             colorsfixedmin;
#else
XgdRasterImage(XgdObject *obj,
	       int scrn,
	       XVisualInfo vinfo,
	       char *name, *mapset,
	       int colorsfixedmin)
#endif
{
  char            buf[120];
  double          xl, xr, yt, yb;
  int             fd, row, col, next_col;
  int             x, y, crow, ccol;
  int             width, height;
  register CELL  *cell;
  double          delta_x, delta_y, row_inc, col_inc;
  int             nrows, ncols;
  int             bitmap_pad;
  float           gap;
  XImage         *grimage;
  int             i, j;
  
  
  nrows = G_window_rows();
  ncols = G_window_cols();
  
  if (obj->width == ncols && obj->height == nrows) {
    col_inc = 1.0;
    row_inc = 1.0;
    crow = obj->height;
    ccol = obj->width;
    gap = 0.0;
  }
  else {
    gap = 0.5;
    XgSetwh(obj->Obj.GeoFrame.region,
	    &col_inc, &row_inc, obj->width, obj->height);
    if (row_inc < 0.0 && col_inc < 0.0) {
      newwidth = (int) (double) (ncols - 1) / col_inc + 1;
      newheight = (int) (double) (nrows - 1) / row_inc + 1;
    }
    else {
      newwidth = (int) 	((double) (ncols - 0.5) / col_inc) + 2;
      newheight = (int) ((double) (nrows - 0.5) / row_inc) + 2;
    }
  }
  
  bitmap_pad = _XgdGetBitmapPad(vinfo);
  
  grimage = XCreateImage(obj->display, vinfo.visual,
			 vinfo.depth, ZPixmap, 0,
			 None, newwidth, newheight,
			 bitmap_pad, 0);
  
  if (!grimage)
    XgdError("Could not create image in XgdRasterImage");
  
  if ((grimage->data = XtMalloc(newheight * newwidth)) == NULL) {
    XgdWarning(" Insufficient memory to allocate raster image \n");
    return (NULL);
  }
  
  /*
   * if (G_read_colors(name, mapset, &colors) == -1)
   * G_fatal_error("Color file not available");
   */
  
  fd = G_open_cell_old(name, mapset);
  if (fd < 0) {
    sprintf(buf, "%s in %s -can't open cell file", name, mapset);
    G_fatal_error(buf);
  }
  cell = G_allocate_cell_buf();
  /* end of gis part */
  
  if (col_inc >= 1.0 && row_inc >= 1.0) {
    crow = 0;
    /* loop over rows */
    for (row = 0; row < nrows; row = (int) (crow * row_inc + gap)) {
      if (G_get_map_row(fd, cell, row) < 0)
	XgdError("Error reading Raster map.")
      
      ccol = 1;
      col = 0;
      
      /* loop over cols */
      while (col < ncols) {
	XPutPixel(grimage, (ccol - 1), crow,
		  obj->Obj.GeoFrame.lookup_tbl[cell[col] -colorsfixedmin + 1]);
	col = (int) (ccol * col_inc + gap);
	ccol++;
	
      }
      XPutImage(obj->display, obj->Obj.GeoFrame.pixmap, obj->objgc,
		grimage, 0, 0, 0, 0, ccol, 1);
      crow++;
    }
  }
  else {
    int             rrow;
    int             rcol;
    crow = 0;
    /* loop over rows */
    for (row = 0; row < newheight - 1; row++) {
      rrow = (int) (row_inc * row);
      if (rrow >= nrows)
	rrow = nrows - 1;
      if (G_get_map_row(fd, cell, rrow) < 0)
	exit();
      
      ccol = 1;
      col = 0;
      
      /* loop over cols */
      while (col < newwidth - 1) {
	rcol = (int) (double) col *col_inc;
	if (rcol >= ncols)
	  rcol = ncols - 1;
	XPutPixel(grimage, (ccol - 1), crow,
		  obj->Obj.GeoFrame.lookup_tbl[cell[rcol] - colorsfixedmin + 1]);
	col++;
	ccol++;
	
      }
      XPutImage(obj->display, obj->Obj.GeoFrame.pixmap, obj->objgc,
		grimage, 0, crow, obj->x, obj->y + crow, ccol, 1);
      crow++;
    }
  }
  
  
  newwidth = ccol;
  newheight = crow + 1;
  grimage->width = newwidth;
  grimage->height = newheight;
  
  /* change cell property */
/*  XFlush(dpy);*/
  G_close_cell(fd);
  return (XImage *) grimage;
}
