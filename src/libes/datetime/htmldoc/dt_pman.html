<title>
GRASS DateTime Library
</title>
<h1>
<center>
GRASS DateTime Library
</center>
</h1>
<hr>
<h2>
Introduction
</h2>
<h3>
Purpose 
</h3>
This Library may be used to record, manipulate, and perform arithmetic 
on date and time information.  It is anticipated that 
<a href="G_ts.html"> GRASS database access routines </a>
will utilize this library to "timestamp" data files 
and perform temporal analysis.  This library could also be used to 
generate, format and compare dates for labels, titles, or site 
descriptions.

<h3>
Relative vs. Absolute
</h3>
Successfully using this library requires understanding the two basic
modes of DateTimes: 1) Absolute DateTimes express a single
time or date referenced to the English calendar (e.g. 14 Feb 1995),
and 2) Relative DateTimes express a difference or length of time 
(e.g., 201 days 6 hours).  An interval for a DateTime is defined
by its greatest unit (from) and its smallest unit (to).  The absolute 
DateTime "14 Feb 1995" has the interval: from=year, to=day.  There
are specific rules for legal intervals.  The mode and interval
define the "type" of a DateTime.  When doing DateTime artithmetic
certain type combinations are not allowed because the result would
be undefined.

<h3>
Calendar Assumptions
</h3>
This library uses the modern English calendar, correcting for leap
years using the convention of the past two centuries: 
((year%4 == 0 && year%100 != 0) || year%400 == 0) , but also 
extrapolating those leap years back in time.  There are no leap 
second corrections and there is no correction for the missing 
11 days of September 1752 or prior corrections.  
The year is always considered to start on January 1 and end 365 or
366 days later on December 31.

<h3>
Authors
</h3>
Michael Shapiro & Bill Brown

<hr>
<h2>
Include Files
</h2>
<pre>
       #include &lt datetime.h &gt
</pre>

<hr>
<h2>
DateTime Structure
</h2>

<pre>
    typedef struct {
	int mode; 	     /* absolute or relative */
	int from, to;        /* range of values */
	int positive;	     /* positive/negative datetime */
	int year, month, day;
	int hour, minute;
	double second;
	int fracsec;	     /* #decimal place in printed seconds */
	int tz;		     /* timezone - minutes from UTC */
    } DateTime;
</pre>
DateTimes have a 3-part <em>type</em> consisting of <strong>mode</strong> and
range qualifiers <strong>from</strong> and <strong>to</strong>.
<br>
<br>
<strong>mode</strong>: one of
<br>
<pre>
    #define DATETIME_ABSOLUTE 1
    #define DATETIME_RELATIVE 2
</pre>
<strong>from, to</strong>: one of
<pre>
    #define DATETIME_YEAR   1
    #define DATETIME_MONTH  2
    #define DATETIME_DAY    3
    #define DATETIME_HOUR   4
    #define DATETIME_MINUTE 5
    #define DATETIME_SECOND 6
</pre>
<ul {>
<li>
The values for the from/to #defines must increase from YEAR to SECOND
In other words YEAR < MONTH < DAY < HOUR < MINUTE < SECOND. The idea
is that the higher elements represent higher precision for a date/time.
For example, having seconds in the time is more precise than if seconds
are not present.
<br>
<br>
<li>
There are some restrictions on legal values for from/to:
<ol {>
  <li> from <= to
  <li> if the 'mode' is ABSOLUTE, then 'from' must be YEAR
  <li> if the 'mode' is RELATIVE, then
    'from' and 'to' must be in {YEAR,MONTH} or in {DAY,HOUR,MINUTE,SECOND}
</ol }>
</ul }>

<strong>year, month, day, hour, minute, second</strong>:
<ul {>
    <li> These are non-negative values.
<P>
    <li> For ABSOLUTE types<tab id=t1>, these must be valid date/time values:
    <ul {>
      <li><strong>year</strong>    
      <ul>
      <li>a complete year (not just the last 2 digits) 
      <li>must be positive (since 0 isn't a legal year).
      </ul>
      <li><strong>month</strong>   <tab to=t1>[1,12]
      <li><strong>day</strong>     <tab to=t1>[1,n] where n depends on the year/month.
      <li><strong>hour</strong>    <tab to=t1>[0,23]
      <li><strong>minute</strong>  <tab to=t1>[0,59]
      <li><strong>second</strong>  <tab to=t1>[0.0,<60.0]
    </ul }>
<P>
    <li>For RELATIVE types, the value corresponding to 'from' is
    unrestricted (except that it can't be negative). The other values
    are restricted as follows:
    <br>
      if from==YEAR, month is [0,11]
    <br>
      if from==DAY,  hour is [0,23], min is [0,59], sec is [0.0,<60.0]
    <br>
      if from==HOUR, min is [0,59], sec is [0.0,<60.0]
    <br>
      if from==MINUTE, sec is [0.0,<60.0]

</ul }>

<strong>fracsec</strong>:
<ul {>
    <li> This controls the number of decimal places to print after the seconds.
    <li> It is only used if the 'to' element is SECOND. 
    <li> It must be non-negative.
</ul }>

<strong>tz</strong>:
<ul {>
    <li>The time (hour/minute) in ABSOLUTE types is in local time.
    <li>The specification of a timezone (tz) is an (subtractive)
    offset to convert from local time to UTC.
    <li>To get UTC from localtime: LT - TZ

    <li>tz is expressed in minutes from -720 to 780
    <br>
    (720 == 12 hours, 780 minutes == 13 hours). 
    <br>
    [See ANSI X3.51-1975, section 2.2.3]

    <li>For a timezone to be allowed, the 'to' field must be one of
    {MINUTE, SECOND}
</ul }>

<strong>positive</strong>:
<ul {>
    <li>this indicates if the datetime value is to considered 
    "positive" (!=0) or "negative" (==0)
    <li>For mode ABSOLUTE, positive==0 means BC
</ul }>

<hr>
<h2>
C - API
</h2>
<h3>
<a href="dtf_index.html">Function Index (by function)</a>
<br>
<a href="dtf_alpha_index.html">Function Index (alphabetical)</a>
<P>
Contents:
</h3>
<strong>
<ul>
<li><a href="#h3a">Error Handling</a>
<li><a href="#h3b">Ascii Representation</a>
<li><a href="#h3c">Initializing, Creating and Checking DateTime Structures</a>
<li><a href="#h3d">Getting & Setting Values from DateTime Structure</a>
<li><a href="#h3e">DateTime Arithmetic</a>
<li><a href="#h3f">Timezone</a>
<li><a href="#h3g">Utilities</a>
</ul>
</strong>
<hr>
<h3> <a name="h3a">Error Handling</a>
</h3>
All datetime functions that return int status codes should return:
<ul {>
	    <li>0 (or positive) if OK;
	    <li>a negative integer if not;
</ul }>
and register the error with a call to 
<a href="#FuNc100">datetime_error()</a>
<P>
Applications can test for error by:
<pre>
    if (datetime_function() < 0) {process the error}
</pre>

<dl>
<code>
<strong>
<dt>
    int
<a name="FuNc100"> datetime_error </a>
    (int code, char *msg)
</strong>
</code>
<dd>
	record 'code' and 'msg' as error code/msg (in static variables)
<br>
	code==0 will clear the error (ie set msg=NULL)
<br>
	returns 'code' so that it can be used like:
<br>
<code>
		return datetime_error (-1, "bad date");
</code>
<p>
<code>
<strong>

<dt>
    char *
<a name="FuNc110"> datetime_get_error_msg </a>
    ()
</strong>
</code>
<dd>
	returns pointer to static error msg (which is NULL if no error)
<p>
<code>
<strong>
<dt>
    int
<a name="FuNc120"> datetime_get_error_code </a>
    ()
</strong>
</code>
<dd>
	returns error code
<p>
<code>
<strong>
<dt>
    void
<a name="FuNc130"> datetime_clear_error </a>
    ()
</strong>
</code>
<dd>
	clears error code and message
</dl>


<hr>
<h3>
<a name="h3b">Ascii Representation</a>
</h3>
<pre>
    The ascii representation of DateTime is:

    ABSOLUTE:  15 Jan 1994 [bc] 10:35:23.456 -0500
    RELATIVE:  [-] 2 years 5 months
	       [-] 100 days 15 hours 25 minutes 35.34 seconds
    The parts can be missing.
    ABSOLUTE:  1994 [bc]
	       Jan 1994 [bc]
	       15 jan 1000 [bc]
	       15 jan 1994 [bc] 10 [+0000]
	       15 jan 1994 [bc] 10:00 [+0100]
	       15 jan 1994 [bc] 10:00:23.34 [-0500]
    RELATIVE:  [-] 2 years
	       [-] 5 months
	       [-] 2 years 5 months
	       [-] 100 days
	       [-] 15 hours 25 minutes 35.34 seconds
	       [-] 100 days 25 minutes
	       [-] 1000 hours 35.34 seconds
		    etc.
    NOTE: values missing between the from/to are assumed 
    to be zero; when scanning, they can be missing; when 
    formatting they will appear as 0 (to preserve the from/to):

       1000 hours 0 minutes 35.34 seconds
       0 days 10 hours 0 minutes

    NOTE: when scanning the from/to are determined by the 
    fields present. Compare:
       10 hours 0 minutes 35.34 seconds [from=HOUR,to=SECOND]
    and
       0 days 10 hours 0 minutes 35.34 seconds [from=DAY,to=SECOND]
</pre>
<dl>
<code>
<strong>
<dt>
    int
<a name="FuNc200"> datetime_scan </a>
    (DateTime *dt, char *string)
</strong>
</code>
<dd>

	    Convert the ascii string into a DateTime.
	    This determines the mode/from/to based on the string,
	    inits 'dt' and then sets values in 'dt' based on the
	    'string'
<P>
	    Returns 0 if 'string' is legal, -1 if not.

<P>
<code>
<strong>
<dt>
    void
<a name="FuNc210"> datetime_format </a>
    (DateTime *dt, char *string)
</strong>
</code>
<dd>

	    Convert 'dt' to a printable string. 'string' should
	    be large enough to hold the result, perhaps 80 bytes.


</dl>
<hr>
<h3>
<a name="h3c">Initializing, Creating and Checking DateTime Structures</a>
</h3>

<dl>
<code>
<strong>
<dt>
    int
<a name="FuNc300"> datetime_set_type </a>
    (DateTime *dt; int mode, from, to, fracsec)
</strong>
</code>
<dd>
<ul {>
    <li><strong><em>This routine must be called 
    <blink> before any use of dt </blink>
    can be made with other datetime functions.
    </em></strong>

	<li>initialize all the elements in dt.
	<li>Set all values to zero except:
	<br>
	    <strong>tz</strong>        (set to illegal value - 99*24)
	<br>
	    <strong>positive</strong>  (set to 1 for positive)

	<li>Set the type info in dt: mode, from, to, fracsec
	<li>validate the mode/from/to/fracsec (according to the rules for the mode)
	<li>return the return value from 
	<a href="#FuNc320">datetime_check_type</a>(dt)

</ul {>
<P>
<code>
<strong>
<dt>
    void
<a name="FuNc310"> datetime_get_type </a>
    (DateTime *dt; int *mode, *from, *to, *fracsec)
</strong>
</code>
<dd>

	extract the mode, from, to, and fracsec out of dt.
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc320"> datetime_check_type </a>
    (DateTime *dt)
</strong>
</code>
<dd>

	checks the mode/from/to/fracsec in dt. 
<P>
	returns:
<br>
<ul>
	   <li> 0: OK
	   <li>-1: mode is invalid - not one of {ABSOLUTE,RELATIVE}
	   <li>-2: from is invalid - not one of {YEAR,MONTH,DAY,HOUR,MINUTE,SECOND}
	   <li>-3: to is invalid   - not one of {YEAR,MONTH,DAY,HOUR,MINUTE,SECOND}
	   <li>-4: from/to are reversed (from>to is illegal)
	   <li>-5: invalid from/to combination for RELATIVE mode:
	   <br>
		from in {YEAR,MONTH} but to is not, or
	   <br>
		from in {DAY,HOUR,MINUTE,SECOND} but to is not
	   <li>-6: from is invalid for ABSOLUTE mode (from != YEAR is illegal)
	   <li>-7: fracsec is negative (only if to==SECOND)
</ul>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc330"> datetime_is_valid_type </a>
    (DateTime *dt)
</strong>
</code>
<dd>

	returns:
	<br>
	1 if <a href="#FuNc320">datetime_check_type()</a> returns 0
	<br>
	0 if not.
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc340"> datetime_change_from_to </a>
    (DateTime *dt; int from, to; int round)
</strong>
</code>
<dd>
<ul>
	<li>changes the from/to of the type for dt.

	<li>The 'from/to' must be legal values for the mode of dt;
	(if they are not legal, then the original values are preserved,
	dt is not changed). 

	<li>returns:
	<br>
	0 OK
	<br>
	-1 invalid 'dt'
	<br>
	-2 invalid 'from/to'

	<li>round = 
	<br>
	negative implies floor()          [decrease magnitude]
	<br>
	0       implies normal rounding, [incr/decr magnitude]
	 <br>
	positive implies ceil()           [increase magnitude]


	<li>If dt.from < 'from' (losing "lower" elements), convert the
	    "lost" values to the equivalent value for the new 'from'
	    Lost elements are then set to zero.
	    (This case can only occur for dt.mode relative):
<br>
		months += lost years * 12      ; years = 0
<br>
		hours  += lost days * 24       ; days = 0
<br>
		minutes += lost hours * 60     ; hours = 0
<br>
		seconds += lost minutes * 60.0 ; minutes = 0

	<li>If dt.from > 'from' (adding "lower" elements), the new elements
	    are set to zero.

	<li>If dt.to < 'to' (adding "higher" elements), the new elements
	    are set to zero.

	<li>If dt.to > 'to' (losing "higher" elements), the
	    the new 'to' is adjusted according to the value for 'round'	
	    After rounding the "lost" elements are set to zero.

</ul>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc350"> datetime_is_absolute </a>
    (DateTime *dt)
</strong>
</code>
<dd>
	Returns:
	<br>
	    1 if dt.mode is absolute
	<br>
	    0 if not (even if dt.mode is not defined)
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc360"> datetime_is_relative </a>
    (DateTime *dt)
</strong>
</code>
<dd>
	Returns 
	<br>
	    1 if dt.mode is relative
	<br>
	    0 if not (even if dt.mode is not defined)

<P>
<code>
<strong>
<dt>
    void
<a name="FuNc400"> datetime_copy </a>
    (DateTime *dst, *src)
</strong>
</code>
<dd>

	Copies the DateTime <strong>src</strong> to <strong>dst</strong>

<P>
<code>
<strong>
<dt>
    int
<a name="FuNc500"> datetime_is_same </a>
    (DateTime *dt1, *dt2)
</strong>
</code>
<dd>

	Returns
	<br>
	    1 if dt1 is exactly the same as dt2
	<br>
	    0 if they differ 

</dl>
<hr>
<h3>
<a name="h3d">Getting & Setting Values from DateTime Structure</a>
</h3>

    These routines get/set elements of 'dt'. They return:
<ul {>
	<li>0 if OK
	<li>-1 if the value being gotten or set is not a legal value
	<li>-2 if the from/to for 'dt' doesn't include this value
</ul }>
    Values don't get set if they are invalid.
<dl>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc600"> datetime_set_year </a>
    (DateTime *dt, int year)
</strong>
</code>
<dd>
	if dt.mode = ABSOLUTE, this also sets dt.day = 0
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc605"> datetime_get_year </a>
    (DateTime *dt, int *year)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc610"> datetime_set_month </a>
    (DateTime *dt, int month)
</strong>
</code>
<dd>
	if dt.mode = ABSOLUTE, this also sets dt.day = 0
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc615"> datetime_get_month </a>
    (DateTime *dt, int *month)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc620"> datetime_set_day </a>
    (DateTime *dt, int day)
</strong>
</code>
<dd>

	if dt.mode = ABSOLUTE, then
	'day' must be less than or equal to the number of days in
	the dt.year,dt.month:
<br>
	      if (day > 
	      <a href="#FuNc1000">datetime_days_in_month</a>
	      (dt.year, dt.month))
<br>
		    {error}
<P>

	<em>This implies that year/month must be set 
	<blink>before days</blink>
	for ABSOLUTE datetimes.</em>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc625"> datetime_get_day </a>
    (DateTime *dt, int *day)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc630"> datetime_set_hour </a>
    (DateTime *dt, int hour)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc635"> datetime_get_hour </a>
    (DateTime *dt, int *hour)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc640"> datetime_set_minute </a>
    (DateTime *dt, int minute)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc645"> datetime_get_minute </a>
    (DateTime *dt, int *minute)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc650"> datetime_set_second </a>
    (DateTime *dt, double second)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc655"> datetime_get_second </a>
    (DateTime *dt, double *second)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc660"> datetime_set_fracsec </a>
    (DateTime *dt, int fracsec)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc665"> datetime_get_fracsec </a>
    (DateTime *dt, int *fracsec)
</strong>
</code>
<dd>
</dl>

<dl>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc700"> datetime_check_year </a>
    (DateTime *dt, int year)
</strong>
</code>
<dd>
	Returns:
	<br>
	0 is legal year for dt
	<br>
	-1 illegal year for this dt
	<br>
	-2 dt has no year component
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc705"> datetime_check_month </a>
    (DateTime *dt, int month)
</strong>
</code>
<dd>
	Returns:
	<br>
	0 is legal month for dt
	<br>
	-1 illegal month for this dt
	<br>
	-2 dt has no month component
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc710"> datetime_check_day </a>
    (DateTime *dt, int day)
</strong>
</code>
<dd>
	Returns:
	<br>
	0 is legal day for dt
	<br>
	-1 illegal day for this dt
	<br>
	-2 dt has no day component
	<P>
	Note: if dt.mode is ABSOLUTE, then dt.year and dt.month
		must also be legal, since the 'day' must be a legal
		value for the dt.year/dt.month
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc715"> datetime_check_hour </a>
    (DateTime *dt, int hour)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc720"> datetime_check_minute </a>
    (DateTime *dt, int minute)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc725"> datetime_check_second </a>
    (DateTime *dt, double second)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc730"> datetime_check_fracsec </a>
    (DateTime *dt, int fracsec)
</strong>
</code>
<dd>


</dl>

<hr>
<h3>
<a name="h3e">DateTime Arithmetic</a>
</h3>

These functions perform addition/subtraction on datetimes. 

<dl>
<code>
<strong>
<dt>
    int
<a name="FuNc800"> datetime_increment </a>
     (DateTime *src, *incr)
</strong>
</code>
<dd>

	This function changes the 'src' date/time data based on the 'incr'
	<br>
	The type (mode/from/to) of the 'src' can be anything.
	<br>
	The mode of the 'incr' must be RELATIVE,
	and the type (mode/from/to) for 'incr' must be a valid increment
	for 'src'. See 
	<a href="#FuNc850">datetime_is_valid_increment()</a>, 
	<a href="#FuNc860">datetime_check_increment()</a>
<P>
	returns:
	<br>
	    0: OK
	<br>
	   -1: 'incr' is invalid increment for 'src'
<P>
	For src.mode ABSOLUTE,
	<ul>
	    <li>positive 'incr' moves into the future,
	    <li>negative 'incr' moves into the past.
	    <li>BC implies the year is negative, but all else is positive.
	    Also, year==0 is illegal: adding 1 year to 1[bc] gives 1[ad]
	</ul>
<P>
	The 'fracsec' in 'src' is preserved.
	<br>
	The 'from/to' of the 'src' is preserved.
	<br>
	A timezone in 'src' is allowed - it's presence is ignored.
	<br>
	<em>NOTE</em>: There is no datetime_decrement()
	      To decrement, set the 'incr' negative.
<P>
<code>
<strong>
<dt>
    void
<a name="FuNc810"> datetime_set_positive </a>
    (DateTime *dt)
</strong>
</code>
<dd>
	Makes the DateTime positive. (A.D. for ABSOLUTE DateTimes)
<P>
<code>
<strong>
<dt>
    void
<a name="FuNc820"> datetime_set_negative </a>
    (DateTime *dt)
</strong>
</code>
<dd>
	Makes the DateTime negative. (B.C. for ABSOLUTE DateTimes)
<P>
<code>
<strong>
<dt>
    void
<a name="FuNc830"> datetime_invert_sign </a>
    (DateTime *dt)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc840"> datetime_is_positive </a>
    (DateTime *dt)
</strong>
</code>
<dd>
	Returns:
	<br>
	1 if the Datetime is positive
	<br>
	0 otherwise
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc845"> datetime_difference </a>
    (DateTime *a, *b, *result)
</strong>
</code>
<dd>
<ul >
	<li>This performs the formula:   result = a - b;

	<li>both a and b must be absolute.
	<li>result will be relative
	<li>If a is "earlier" than b, then result will be set negative.

	<li>b must be no more "precise" than a.
	<br>
	   (a copy of b is "extended" to the precision of a)

	<li>If result.to == SECOND, then result.fracsec is a.fracsec

	<li>result will have the following from/to based on a.to:
	<pre>
		     result
	a.to      from    to
	YEAR      YEAR    YEAR
	MONTH     YEAR    MONTH
	DAY       DAY     DAY
	HOUR      DAY     HOUR
	MINUTE    DAY     MINUTE
	SECOND    DAY     SECOND
	</pre>

	<li>If either 'a' or 'b' has a timezone, both must have a timezone.
	The difference will account for the differences in the time zones.

</ul >
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc850"> datetime_is_valid_increment </a>
    (DateTime *src, *incr)
</strong>
</code>
<dd>
	Returns:
	<br>
	    <a href="#FuNc860">datetime_check_increment</a>(src, incr) == 0
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc860"> datetime_check_increment </a>
    (DateTime *src, *incr)
</strong>
</code>
<dd>
	This checks if the type of 'incr' is valid for
	incrementing/decrementing 'src'.
<br>	
	The type (mode/from/to) of the 'src' can be anything.
<br>	
	The incr.mode must be RELATIVE
<br>	
	A timezone in 'src' is allowed - it's presence is ignored.
<br>	
	To aid in setting the 'incr' type, 
	see 
	<a href="#FuNc870">datetime_get_increment_type()</a>.
<P>
	Returns:
	<ul>
	    <li>0 valid increment
	    <li>1 src is not a legal DateTime, error code/msg
		are those set by 
		<a href="#FuNc330">datetime_is_valid_type()</a>
	    <li>2 incr is not a legal DateTime, error code/msg
		are those set by 
		<a href="#FuNc330">datetime_is_valid_type()</a>
	   <li>-1 incr.mode not relative
	   <li>-2 incr more precise that src
	   <li>-3 illegal incr, must be YEAR-MONTH
	   <li>-4 illegal incr, must be DAY-SECOND
	</ul>

<P>
<code>
<strong>
<dt>
    int
<a name="FuNc870"> datetime_get_increment_type </a>
    (DateTime *src; int *mode, *from, *to, *fracsec)
</strong>
</code>
<dd>

	This returns the components of a type (mode/from/to/fracsec) that
	can be used to construct a DateTime object that can be used
	to increment the 'src'. Also see 
	<a href="#FuNc880">datetime_set_increment_type()</a>.
<P>
	returns:
	<br>
	0 dt is legal
	<br>
	!=0 why dt is illegal
<P>
	Implemented as follows:
<pre>
    *mode    = RELATIVE
    *to      = src.to
    *fracsec = src.fracsec

    if src.mode is ABSOLUTE
	if src.to is in {YEAR,MONTH} then
	    *from = YEAR
	if src.to is in {DAY,HOUR,MINUTE,SECOND} then 
	    *from = DAY

    if src.mode is RELATIVE, then
	*from = src.from
</pre>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc880"> datetime_set_increment_type </a>
    (DateTime *src, *incr)
</strong>
</code>
<dd>
	src must be legal
	<br>
	This is a convenience routine which is implemented as follows:
	<br>
<pre>
    int mode, from ,to;
    int fracsec;

    if(<a href="#FuNc870">datetime_get_increment_type</a>(src, &mode, &from, &to, &fracsec))
	return <a href="#FuNc120">datetime_get_error_code()</a>;
    return <a href="#FuNc300">datetime_set_type</a> (incr, mode, from, to, fracsec);
</pre>

</dl>

<hr>
<h3>
<a name="h3f">Timezone</a>
</h3>
    
    Timezones are represented in minutes from GMT in the range [-720,+780].
    For a DateTime to have a timezone, it must be of type ABSOLUTE, 
    and "to" must be in {MINUTE,SECOND}.
<P>
    The next 3 functions return:
    <br>
	  0: OK
    <br>
	 -1: mode not ABSOLUTE
    <br>
	 -2: dt.to not in {MINUTE,SECOND}
    <br>
	 -3: minutes not valid - not in the range [-720,+780]
<dl>
<code>
<strong>
<dt>
    int
<a name="FuNc900"> datetime_check_timezone </a>
    (DateTime *dt, int minutes)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc910"> datetime_set_timezone </a>
    (DateTime *dt, int minutes)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc920"> datetime_get_timezone </a>
    (DateTime *dt, int *minutes)
</strong>
</code>
<dd>

<P>
<code>
<strong>
<dt>
    int
<a name="FuNc930"> datetime_is_valid_timezone </a>
    (int minutes)
</strong>
</code>
<dd>
	Returns:
    <br>
	 1 OK: -720 <= minutes <= 780 (720 = 12 hours; 780 = 13 hours)
    <br>
	 0 NOT OK
<P>
<code>
<strong>
<dt>
    void
<a name="FuNc940"> datetime_unset_timezone </a>
    (DateTime *dt)
</strong>
</code>
<dd>
	Remove timezone from 'dt'
    <br>
	dt.tz = 99*60 (some illegal value)
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc950"> datetime_change_timezone </a>
    (DateTime *dt; int minutes)
</strong>
</code>
<dd>
	if dt has a timezone,
	    increment dt by minutes-dt.tz MINUTES and
	    set dt.tz = minutes 
<P>
	Returns:
    <br>
	0 OK 
    <br>
	<a href="#FuNc900">datetime_check_timezone</a>
	(dt) if not
    <br>
	-4 if minutes invalid
    <br>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc960"> datetime_change_to_utc </a>
    (DateTime *dt)
</strong>
</code>
<dd>
	return <a href="#FuNc950">datetime_change_timezone</a> (dt, 0);
<P>
<code>
<strong>
<dt>
    void
<a name="FuNc970"> datetime_decompose_timezone </a>
    (int tz, int *hour, int *minute)
</strong>
</code>
<dd>
	tz = abs(tz)
    <br>
	*hour = tz/60
    <br>
	*minute = tz%60
<P>
	Note: hour,minute are non-negative. Must look at sign of tz
	itself to see if the tz is negative offset or not. This routine
	would be used to format tz for output. For example if tz=-350
	this would be hour=5 minute=50, but negative. Output might encode
	this as -0550: printf ("%s%02d%02d", tz<0?"-":"", hour, minute)

<P>
<code>
<strong>
<dt>
    int
<a name="FuNc980"> datetime_get_local_timezone </a>
    (int *minutes)
</strong>
</code>
<dd>
	Returns:
	<br>
	0 OK
	<br>
	-1 local timezone info not available
<P>
<code>
<strong>
<dt>
    void
<a name="FuNc990"> datetime_get_local_time </a>
    (DateTime *dt)
</strong>
</code>
<dd>

	set mode/from/to ABSOLUTE/YEAR/SECOND
	<br>
	set the local time into 'dt'
	<br>
	does not set timezone.

</dl>

<hr>
<h3>
<a name="h3g">Utilities</a>
</h3>
<dl>
<code>
<strong>
<dt>
    int
<a name="FuNc1000"> datetime_days_in_month </a>
    (int month, year)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc1010"> datetime_is_leap_year </a>
    (int year, ad)
</strong>
</code>
<dd>
<P>
<code>
<strong>
<dt>
    int
<a name="FuNc1020"> datetime_days_in_year </a>
    (int year, ad)
</strong>
</code>
<dd>

</dl>

<hr>
<h3>  
Implementation Notes on precision/overflow
</h3>  
........
<hr>

<A HREF="http://www.cecer.army.mil/grass/GRASS.main.html">
<IMG SRC="http://www.cecer.army.mil/grass/grassbutton.gif"ALT="GRASS ICON"></A> 
<A HREF="http://www.cecer.army.mil/grass/viz/VIZ.html">
<IMG SRC="http://www.cecer.army.mil/grass/viz/vizbutton.gif"ALT="VIZ-MOD ICON"></A> 

<hr>
<address>HTML documentation by brown@gis.uiuc.edu</address>
