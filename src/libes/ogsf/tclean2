/************************************************************************/
gsd_get_los(vect, sx, sy)
float vect[2][3];
short sx, sy;       /* screen coordinates */
{
static int first;

#ifdef SGI_GL
static Object Vobj;
float fx, fy, fz, tx, ty, tz;

    GS_ready_draw();
    pushmatrix();
    if(first){
	first = 0;
	makeobj(Vobj = genobj());
    }
    else
	makeobj(Vobj);

    gsd_do_scale(1);
    closeobj();
    popmatrix();

    mapw(Vobj, sx, sy, &fx, &fy, &fz, &tx, &ty, &tz);

    vect[FROM][X] = fx;
    vect[FROM][Y] = fy;
    vect[FROM][Z] = fz;
    vect[TO][X] = tx;
    vect[TO][Y] = ty;
    vect[TO][Z] = tz;

    /* DEBUG - should just be a dot */
    frontbuffer(1);
    pushmatrix();
    gsd_do_scale(1);
    gsd_linewidth(3);
    gsd_color_func(0x8888FF);
    bgnline();
    v3f(vect[FROM]);
    v3f(vect[TO]);
    endline();
    gsd_linewidth(1);
    popmatrix();
    frontbuffer(0);

    return(1);

#elif USE_OGL

double fx, fy, fz, tx, ty, tz;
GLdouble modelMatrix[16], projMatrix[16];
GLint viewport[4];

    GS_ready_draw();
    glPushMatrix();

    gsd_do_scale(1);
    glGetDoublev(GL_MODELVIEW_MATRIX, modelMatrix);
    glGetDoublev(GL_PROJECTION_MATRIX, projMatrix);
    glGetIntegerv(GL_VIEWPORT, viewport);
    glPopMatrix();

	/* OGLXXX XXX I think this is backwards gluProject(XXX); */
	/* WAS: mapw(Vobj, sx, sy, &fx, &fy, &fz, &tx, &ty, &tz); */
    gluUnProject((GLdouble)sx, (GLdouble)sy, 0.0, modelMatrix, 
		projMatrix, viewport, &fx, &fy, &fz);
    gluUnProject((GLdouble)sx, (GLdouble)sy, 1.0, modelMatrix, 
		projMatrix, viewport, &tx, &ty, &tz);

    vect[FROM][X] = fx;
    vect[FROM][Y] = fy;
    vect[FROM][Z] = fz;
    vect[TO][X] = tx;
    vect[TO][Y] = ty;
    vect[TO][Z] = tz;

    /* DEBUG - should just be a dot */
	/* OGLXXX frontbuffer: other possibilities include GL_FRONT_AND_BACK */
    glDrawBuffer((1) ? GL_FRONT : GL_BACK);
    glPushMatrix();
    gsd_do_scale(1);
    gsd_linewidth(3);
    gsd_color_func(0x8888FF);
	/* OGLXXX for multiple, independent line segments: use GL_LINES */
    glBegin(GL_LINE_STRIP);
    glVertex3fv(vect[FROM]);
    glVertex3fv(vect[TO]);
    glEnd();
    gsd_linewidth(1);
    glPopMatrix();
	/* OGLXXX frontbuffer: other possibilities include GL_FRONT_AND_BACK */
    glDrawBuffer((0) ? GL_FRONT : GL_BACK);

    return(1);


#endif

}


/************************************************************************/
