
/*  gsd_prim.c
    Bill Brown, USACERL  
    January 1993
    Primitive drawing functions
*/

#include "gstypes.h"

/*
#ifndef SGI_GL
#define SGI_GL
#endif
*/

#ifdef SGI_GL
#include "gl.h"
#include <gl/sphere.h>
#elif USE_OGL
#include "GL/gl.h"
#endif

/* DEBUG */
#include <stdio.h>

static int Shade;


/************************************************************************/
gsd_colormode(cm)
int cm;
{

#ifdef SGI_GL
    switch(cm){
	case CM_COLOR:
	    lmcolor (LMC_COLOR);
	    break;
	case CM_EMISSION:
	    lmcolor (LMC_EMISSION);
	    break;
	case CM_DIFFUSE:
	    lmcolor (LMC_DIFFUSE);
	    break;
	case CM_AD:
	    lmcolor (LMC_AD);
	    break;
	case CM_NULL:
	    lmcolor (LMC_NULL);
	    break;
	default:
	    lmcolor (LMC_COLOR);
	    break;
    }
#endif

}

/************************************************************************/

gsd_circ(x, y, rad)
float x, y, rad;
{
#ifdef SGI_GL
    circ(x, y, rad);
#endif
}


/************************************************************************/
gsd_sphere(center, siz)
float center[3], siz;
{
#ifdef SGI_GL
float params[4];
static int first=1;

    if(first){
        /* set sphere mode */
        sphmode(SPH_ORIENT, FALSE);
        first = 0;
    }
    
    params[0]=center[0];
    params[1]=center[1];
    params[2]=center[2];
    params[3]=siz;
    sphdraw(params);
#endif
}
/************************************************************************/
gsd_zwritemask(n)
unsigned long n;
{
#ifdef SGI_GL
    zwritemask(n);
#endif
}

/************************************************************************/
gsd_backface(n)
int n;
{
#ifdef SGI_GL
    backface(n);
#endif
}

/************************************************************************/
gsd_frontface(n)
int n;
{
#ifdef SGI_GL
    frontface(n);
#endif
}

/************************************************************************/
gsd_linewidth(n)
short n;
{
#ifdef SGI_GL
    linewidth(n);
#endif
}

/************************************************************************/
gsd_bgntmesh()
{
#ifdef SGI_GL
    bgntmesh();
#endif
}

/************************************************************************/
gsd_endtmesh()
{
#ifdef SGI_GL
    endtmesh();
#endif
}

/************************************************************************/
gsd_swaptmesh()
{
#ifdef SGI_GL
    swaptmesh();
#endif
}

/************************************************************************/
gsd_bgnpolygon()
{
#ifdef SGI_GL
    bgnpolygon();
#endif
}

/************************************************************************/
gsd_endpolygon()
{
#ifdef SGI_GL
    endpolygon();
#endif
}

/************************************************************************/
gsd_bgnline()
{
#ifdef SGI_GL
    bgnline();
#endif
}

/************************************************************************/
gsd_endline()
{
#ifdef SGI_GL
    endline();
#endif
}

/************************************************************************/
gsd_frontbuffer(bool)
int bool;
{
#ifdef SGI_GL
    frontbuffer(bool);
#endif
}

/************************************************************************/
gsd_shademodel(bool)
int bool;
{
    Shade = bool;
#ifdef SGI_GL
    if(bool)
	shademodel(GOURAUD);
    else
	shademodel(FLAT);
#endif
}

/************************************************************************/
gsd_getshademodel()
{
    return(Shade);
}

/************************************************************************/
gsd_backbuffer(bool)
int bool;
{
#ifdef SGI_GL
    backbuffer(bool);
#endif
}

/************************************************************************/
gsd_swapbuffers()
{
#ifdef SGI_GL
    swapbuffers();
#endif
}

/************************************************************************/
gsd_popmatrix()
{
#ifdef SGI_GL
    popmatrix();
#endif
}

/************************************************************************/
gsd_pushmatrix()
{
#ifdef SGI_GL
    pushmatrix();
#endif
}

/************************************************************************/
gsd_scale(xs,ys,zs)
float xs, ys, zs;
{
#ifdef SGI_GL
    scale(xs, ys, zs);
#endif
}

/************************************************************************/
gsd_translate(dx,dy,dz)
float dx, dy, dz;
{
#ifdef SGI_GL
    translate(dx, dy, dz);
#endif
}

/************************************************************************/
gsd_rot(angle, axis)
float angle;
char axis;
{
#ifdef SGI_GL
    rot(angle, axis);
#endif
}

/************************************************************************/
gsd_litvert_func(norm, col, pt)
float norm[3];
unsigned long col;
float pt[3];
{
#ifdef SGI_GL
    n3f(norm);
    cpack(col);
    v3f(pt);
#endif
}

/************************************************************************/
gsd_vert_func(pt)
float pt[3];
{
#ifdef SGI_GL
    v3f(pt);
#endif
}

/************************************************************************/
gsd_color_func(col)
int col;
{
#ifdef SGI_GL
    cpack(col);
#endif
}

#ifdef SGI_GL
static float sgi_light[MAX_LIGHTS][14];
static float sgi_material[19];
static float sgi_lmodel[4];
#endif
/************************************************************************/
gsd_init_lightmodel()
{
#ifdef SGI_GL

    sgi_material[0] = AMBIENT;
    sgi_material[1] = 0.1;
    sgi_material[2] = 0.1;
    sgi_material[3] = 0.1;
    sgi_material[4] = DIFFUSE;
    sgi_material[5] = 0.8;
    sgi_material[6] = 0.8;
    sgi_material[7] = 0.8;
    sgi_material[8] = SPECULAR;
    sgi_material[9] = 0.45;
    sgi_material[10] = 0.45;
    sgi_material[11] = 0.45;
    sgi_material[12] = EMISSION;
    sgi_material[13] = 0.0;
    sgi_material[14] = 0.0;
    sgi_material[15] = 0.0;
    sgi_material[16] = SHININESS;
    sgi_material[17] = 25.0;
    sgi_material[18] = LMNULL;

    sgi_lmodel[0] = ATTENUATION;
    sgi_lmodel[1] = 1.0;
    sgi_lmodel[2] = 0.0;
    sgi_lmodel[3] = LMNULL;

    lmdef(DEFLMODEL, 1, 4, sgi_lmodel);
    lmdef(DEFMATERIAL, 1, 19, sgi_material);

    lmbind(LMODEL,1);
    lmbind(MATERIAL,1);

#endif
}

/************************************************************************/
gsd_set_material(set_shin, set_emis, sh, em, emcolor)
int set_shin, set_emis;  /* flags */
float sh, em; /* sh & em should be 0. - 1. */
int emcolor;  /* packed colors to use for emission */
{
#ifdef SGI_GL

    if(set_shin){
	sgi_material[17] = 60. + (int)(sh * 68.);
	sgi_material[9] = sh;
	sgi_material[10] = sh;
	sgi_material[11] = sh;
    }

    if(set_emis){
	sgi_material[13] = (em * (emcolor & 0x0000FF))/255.;
	sgi_material[14] = (em * ((emcolor & 0x00FF00)>>8))/255.;
	sgi_material[15] = (em * ((emcolor & 0xFF0000)>>16))/255.;
    }
    lmdef(DEFMATERIAL, 1, 19, sgi_material);
#endif
}

/************************************************************************/
gsd_deflight(num, vals)
int num;
struct lightdefs *vals;
{
#ifdef SGI_GL
    if(num > 0 && num <= MAX_LIGHTS){
	sgi_light[num - 1][0] = POSITION;
	sgi_light[num - 1][1] = vals->position[X];
	sgi_light[num - 1][2] = vals->position[Y];
	sgi_light[num - 1][3] = vals->position[Z];
	sgi_light[num - 1][4] = vals->position[W];
	sgi_light[num - 1][5] = LCOLOR;
	sgi_light[num - 1][6] = vals->color[0];
	sgi_light[num - 1][7] = vals->color[1];
	sgi_light[num - 1][8] = vals->color[2];
	sgi_light[num - 1][9] = AMBIENT;
	sgi_light[num - 1][10] = vals->ambient[0];
	sgi_light[num - 1][11] = vals->ambient[1];
	sgi_light[num - 1][12] = vals->ambient[2];
	sgi_light[num - 1][13] = LMNULL;

	lmdef(DEFLIGHT, num, 14, sgi_light[num-1]);
    }
#endif

}

/************************************************************************/
/* on = 0 turns them off */
gsd_switchlight(num, on)
int num, on;
{
#ifdef SGI_GL
short defin;

    defin = on? num: 0 ;  
    switch(num){
	case 0:
	    break;
	case 1:
	    lmbind(LIGHT1,defin);
	    break;
	case 2:
	    lmbind(LIGHT2,defin);
	    break;
	case 3:
	    lmbind(LIGHT3,defin);
	    break;
	case 4:
	    lmbind(LIGHT4,defin);
	    break;
	case 5:
	    lmbind(LIGHT5,defin);
	    break;
    }
#endif

}

/************************************************************************/
gsd_getimage(pixbuf, xsize, ysize)
unsigned long **pixbuf;
int *xsize, *ysize;
{
#ifdef SGI_GL
Screencoord l, r, b, t;

    getviewport (&l, &r, &b, &t);

    *xsize = r - l + 1; 
    *ysize = t - b + 1; 

    if(NULL == (*pixbuf = 
	    (unsigned long *)malloc(*xsize * *ysize * sizeof(unsigned long))))
	return (0);
    readsource(SRC_FRONT);
    lrectread(l,b,r,t, *pixbuf);
    return(1);
#endif
    return(0);
}

/************************************************************************/
gsd_viewport(l,r,b,t)
int l,r,b,t;
/* Screencoord */
{
#ifdef SGI_GL
    viewport((Screencoord)l, (Screencoord)r, (Screencoord)b, (Screencoord)t);
#endif
}

/************************************************************************/
gsd_blend(yesno)
int yesno;
{
#ifdef SGI_GL
    if(yesno)
	blendfunction(BF_SA, BF_MSA);
    else
	blendfunction(BF_ONE, BF_ZERO);
#endif
}

/************************************************************************/
gsd_def_clipplane(num, params)
int num;
float *params;
{
#ifdef SGI_GL
    clipplane(num, CP_DEFINE, params);
#endif
}

/************************************************************************/
gsd_set_clipplane(num, able)
int num, able;
{
float params[4]; /* ignored */
#ifdef SGI_GL
    clipplane(num, able? CP_ON: CP_OFF, params);
#endif
}
/************************************************************************/
/* gl_flush or finish */
gsd_finish()
{
#ifdef SGI_GL
    finish();
#endif
}
/************************************************************************/


