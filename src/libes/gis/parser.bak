/***************************************************************************
 * Routines used to assist in command line parsing.  
 ***************************************************************************
 * G_define_flag()
 *
 * Returns a pointer to a flag structure.
 * Flags are always represented by single letters.  A user "turns them on"
 * at the command line using a minus sign followed by the character
 * representing the flag.
 *
 ***************************************************************************
 * G_define_option()
 *
 * Returns a pointer to a flag structure.
 * Options are provided by user on command line using the standard
 * format:  key=value
 * Options identified as REQUIRED must be specified by user on command line.
 * The option string can either specify a range of values (e.g. "10-100") or
 * a list of acceptable values (e.g. "red,orange,yellow").  Unless the option
 * string is NULL, user provided input will be evaluated agaist this string.
 *
 ***************************************************************************
 * G_parser(argc, argv)
 *    int argc ;
 *    char **argv ;
 *
 * Parses the command line provided through argc and argv.  Example:
 * Assume the previous calls:
 *
 *  opt1 = G_define_option() ;
 *  opt1->key        = "map",
 *  opt1->type       = STRING,
 *  opt1->required   = YES,
 *  opt1->checker    = sub,
 *  opt1->description= "Name of an existing cell file" ;
 *
 *  opt2 = G_define_option() ;
 *  opt2->key        = "color",
 *  opt2->type       = STRING,
 *  opt2->required   = NO,
 *  opt2->answer     = "white",
 *  opt2->options    = "red,orange,blue,white,black",
 *  opt2->description= "Color used to display the map" ;
 *
 *  opt3 = G_define_option() ;
 *  opt3->key        = "number",
 *  opt3->type       = DOUBLE,
 *  opt3->required   = NO,
 *  opt3->answer     = "12345.67",
 *  opt3->options    = "0-99999",
 *  opt3->description= "Number to test parser" ;
 *
 * parser() will respond to the following command lines as described:
 *
 * command      (No command line arguments)
 *    Parser will treat this as a request for help and will provide
 *    command line syntax and option meaning information.
 *
 * command map=map.name
 *    Parser will accept this line.  Map will be set to "map.name", the
 *    'a' and 'b' flags will remain off and the num option will be set
 *    to the default of 5.
 *
 * command -ab map=map.name num=9
 * command -a -b map=map.name num=9
 * command -ab map.name num=9
 * command map.name num=9 -ab
 * command num=9 -a map=map.name -b
 *    These are all treated as acceptable and identical. Both flags are
 *    set to on, the map option is "map.name" and the num option is "9".
 *    Note that the "map=" may be omitted from the command line if it
 *    is part of the first option (flags do not count).
 *
 * command num=12
 *    This command line is in error in two ways.  The user will be told 
 *    that the "map" option is required and also that the number 12 is
 *    out of range.  The acceptable range (or list) will be printed.
 *
 * On error, G_parser() prints call G_usage() and exits. Otherwise returns 0
 *
 ***************************************************************************
*/

#include "gis.h"

#define BAD_SYNTAX  1
#define OUT_OF_RANGE    2
#define MISSING_VALUE   3

static int n_opts = 0 ;
static int n_flags = 0 ;

static struct Flag first_flag ;    /* First flag in a linked list      */
static struct Flag *current_flag ; /* Pointer for traversing list      */

static struct Option first_option ;
static struct Option *current_option ;

static char *me = "";

struct Flag *
G_define_flag()
{
    struct Flag *flag ;
    char *ptr ;
    int i ;

/* Allocate memory if not the first flag */

    if (n_flags)
    {
        flag = (struct Flag *)G_malloc(sizeof(struct Flag)) ;
        current_flag->next_flag = flag ;
    }
    else
        flag = &first_flag ;
    
/* Zero structure */

    for(ptr=(char *)flag, i=0; i<sizeof(struct Flag); i++, *ptr++ = NULL)
        ;

    current_flag = flag ;
    n_flags++ ;
    return(flag) ;
}

struct Option *
G_define_option()
{
    struct Option *opt ;
    char *ptr ;
    int i ;

/* Allocate memory if not the first option */

    if (n_opts)
    {
        opt = (struct Option *)G_malloc(sizeof(struct Option)) ;
        current_option->next_opt = opt ;
    }
    else
        opt = &first_option ;

    opt->required = NO ;
    opt->multiple = NO ;
    
/* Zero structure */

    for(ptr=(char *)opt, i=0; i<sizeof(struct Option); i++, *ptr++ = NULL)
        ;

    current_option = opt ;
    n_opts++ ;

    return(opt) ;
}

/* The main parsing routine */

G_parser(argc, argv)
    int argc ;
    char **argv ;
{
    int need_first_opt ;
    int error ;
    char *ptr ;
    int i;

    error = 0 ;
    need_first_opt = 1 ;
    i = strlen(me = argv[0]) ;
    while (--i >= 0)
    {
	if (me[i] == '/')
	{
	    me += i+1;
	    break;
	}
    }

/* If there are NO arguments, give a usage/syntax message */

    if (argc < 2)
    {
	G_usage();
	exit(1);
    }
/* If first arg is "help" give a usage/syntax message */
    if (strcmp(argv[1],"help") == 0)
    {
        G_usage();
	exit(0);
    }

    argc-- ;

/* Loop thru all command line arguments */

    while(argc--)
    {
        ptr = *(++argv) ;

    /* If we see a flag */
        if(*ptr == '-')
            while(*(++ptr))
                error += set_flag(*ptr) ;

    /* If we see standard option format (option=val) */
        else if (contains(ptr, '='))
        {
            error += set_option(ptr) ;
            need_first_opt = 0 ;
        }
    
    /* If we see the first option with no equal sign */
        else if (need_first_opt && n_opts)
        {
            first_option.answer = G_store(ptr) ;
            strcpy(first_option.answer, ptr) ;
            need_first_opt = 0 ;
        }
    }

    /* Split options where multiple answers are OK */
    split_opts() ;

    /* Check answers against options and check subroutines */
    error += check_opts() ;

    /* Make sure all required options are set */
    error += check_required() ;

    if(error)
    {
	G_usage();
	exit(1);
    }
    return(0) ;
}

/**************************************************************************
 *
 * The remaining routines are all local (static) routines used to support
 * the parsing process.
 *
 **************************************************************************
*/
G_usage()
{
    struct Option *opt ;
    struct Flag *flag ;

    fprintf(stderr,"Syntax");
    if (*me) /* me is a static global set by G_parser() */
	fprintf(stderr," for %s:\n", me) ;

/* Print help info for flags */

    if(n_flags)
    {
        flag=&first_flag;
        while(flag != NULL)
        {
            printf("  -%c  (%s)\n",
                flag->key, flag->description) ;
            flag = flag->next_flag ;
        }
    }

/* Print help info for options */

    if(n_opts)
    {
        opt=&first_option;
        while(opt != NULL)
        {
            if( opt->required )
            {
                if (opt->type == STRING)
                    printf("  %s=name", opt->key) ;
                else if (opt->type == INT || opt->type == DOUBLE)
                    printf("  %s=value", opt->key) ;

                if (opt->multiple)
                {
                    if (opt->type == STRING)
                        printf("[,name...]") ;
                    else if (opt->type == INT || opt->type == DOUBLE)
                        printf("[,value...]");
                }
            }
            
            else
	    {
                if (opt->type == STRING)
                    printf("  [%s=name", opt->key) ;
                else if (opt->type == INT || opt->type == DOUBLE)
                    printf("  [%s=value", opt->key) ;

		if (opt->multiple)
                {
                    if (opt->type == STRING)
		        printf(",name") ;
                    else if (opt->type == INT || opt->type == DOUBLE)
                        printf(",value") ;   
                }           
	        printf("]") ;
	    }
	    printf("\n        (%s)\n", opt->description) ;

            opt = opt->next_opt ;
        }
    }
}

static
set_flag(f)
    char f ;
{
    struct Flag *flag ;

/* Flag is not valid if there are no flags to set */

    if(!n_flags)
    {
        fprintf(stderr,"Sorry, <%c> is not a valid flag\n", f) ;
        return(1) ;
    }

/* Find flag with corrrect keyword */

    flag=&first_flag;
    while(flag != NULL)
    {
        if( flag->key == f)
        {
            flag->answer = 1 ;
            return(0) ;
        }
        flag = flag->next_flag ;
    }

    fprintf(stderr,"Sorry, <%c> is not a valid flag\n", f) ;
    return(1) ;
}

/* contents() is used to find things strings with characters like commas and
 * dashes.
 */
static
contains(s, c)
    char *s ;
    char c ;
{
    while(*s)
    {
        if(*s == c)
            return(1) ;
        s++ ;
    }
    return(0) ;
}

static
set_option(string)
    char *string ;
{
    struct Option *opt ;

/* Find option with same keyword */
    opt=&first_option;
    while(opt != NULL)
    {
        if( ! strncmp(opt->key,string,strlen(opt->key)) )
        {
            while(*(string++) != '=') ;
        /* Allocate memory where answer is stored */
            opt->answer = G_malloc(strlen(string)) ;
            strcpy(opt->answer, string) ;
            return(0) ;
        }

        opt = opt->next_opt ;
    }

    fprintf(stderr,"Sorry, <") ;
    while(*string != '=')
        putc(*(string++), stderr) ;
    fprintf(stderr,"> is not a valid option\n") ;
    return(1) ;
}

static
check_opts()
{
    struct Option *opt ;
    int error ;
    int ans ;

    error = 0 ;

    if(! n_opts)
        return(0) ;

    opt=&first_option;
    while(opt != NULL)
    {
        /* Check answer against options if any */

        if(opt->options && opt->answer)
        {
            if(opt->multiple == 0)
                error += check_an_opt(opt->key, opt->type,
                     opt->options, opt->answer) ;
            else
            {
                for(ans=0; opt->answers[ans] != NULL; ans++)
                    error += check_an_opt(opt->key, opt->type,
                         opt->options, opt->answers[ans]) ;
            }
        }

        /* Check answer against user's check subroutine if any */

        if(opt->checker)
            error += opt->checker(opt->answer) ;

        opt = opt->next_opt ;
    }
    return(error) ;
}

static
check_an_opt(key, type, options, answer)
    char *key ;
    int type ;
    char *options, *answer ;
{
    int error ;

    error = 0 ;

    switch(type)
    {
    case INT:
        error = check_int(answer,options) ;
        break ;
    case DOUBLE:
        error = check_double(answer,options) ;
        break ;
    case STRING:
        error = check_string(answer,options) ;
        break ;
    }
    switch(error)
    {
    case 0:
        break ;
    case BAD_SYNTAX:
        fprintf(stderr,"Error: illegal range syntax for option %s\n",
            key) ;
        fprintf(stderr,"       Presented as: %s\n", options) ;
        break ;
    case OUT_OF_RANGE:
        fprintf(stderr,"Error: value <%s> out of range for option <%s>\n",
            answer, key) ;
        fprintf(stderr,"       Legal range: %s\n", options) ;
        break ;
    case MISSING_VALUE:
        fprintf(stderr,"Error: Missing value for option <%s>\n",
            key) ;
    }
    return(error) ;
}

static
check_int(ans, opts)
    char *ans ;
    char *opts ;
{
    int d, lo, hi;

    if (1 != sscanf(ans,"%d", &d))
        return(MISSING_VALUE) ;

    if (contains(opts, '-'))
    {
        if (2 != sscanf(opts,"%d-%d",&lo, &hi))
            return(BAD_SYNTAX) ;
        if (d < lo || d > hi)
            return(OUT_OF_RANGE) ;
        else
            return(0) ;
    }
    else if (contains(opts, ','))
    {
        for(;;)
        {
            if (1 != sscanf(opts,"%d",&lo))
                return(BAD_SYNTAX) ;
            if (d == lo)
                return(0) ;
            while(*opts != NULL && *opts != ',')
                opts++ ;
            if (*opts == NULL)
                return(OUT_OF_RANGE) ;
            if (*(++opts) == NULL)
                return(OUT_OF_RANGE) ;
        }
    }
    else
    {
        if (1 != sscanf(opts,"%d",&lo))
            return(BAD_SYNTAX) ;
        if (d == lo)
            return(0) ;
        return(OUT_OF_RANGE) ;
    }
}

static
check_double(ans, opts)
    char *ans ;
    char *opts ;
{
    double d, lo, hi;

    if (1 != sscanf(ans,"%lf", &d))
        return(MISSING_VALUE) ;

    if (contains(opts, '-'))
    {
        if (2 != sscanf(opts,"%lf-%lf",&lo, &hi))
            return(BAD_SYNTAX) ;
        if (d < lo || d > hi)
            return(OUT_OF_RANGE) ;
        else
            return(0) ;
    }
    else if (contains(opts, ','))
    {
        for(;;)
        {
            if (1 != sscanf(opts,"%lf",&lo))
                return(BAD_SYNTAX) ;
            if (d == lo)
                return(0) ;
            while(*opts != NULL && *opts != ',')
                opts++ ;
            if (*opts == NULL)
                return(OUT_OF_RANGE) ;
            if (*(++opts) == NULL)
                return(OUT_OF_RANGE) ;
        }
    }
    else
    {
        if (1 != sscanf(opts,"%lf",&lo))
            return(BAD_SYNTAX) ;
        if (d == lo)
            return(0) ;
        return(OUT_OF_RANGE) ;
    }
}

static
check_string(ans, opts)
    char *ans ;
    char *opts ;
{
    if (*opts == NULL)
        return(0) ;

    if (contains(opts, ','))
    {
        for(;;)
        {
            if ((! strncmp(ans, opts, strlen(ans)))
                && *(opts+strlen(ans)) == ',')
                return(0) ;
            while(*opts != NULL && *opts != ',')
                opts++ ;
            if (*opts == NULL)
                return(OUT_OF_RANGE) ;
            if (*(++opts) == NULL)
                return(OUT_OF_RANGE) ;
        }
    }
    else
    {
        if (! strcmp(ans, opts))
            return(0) ;
        return(OUT_OF_RANGE) ;
    }
}
static
check_required()
{
    struct Option *opt ;
    int err ;

    err = 0 ;

    if(! n_opts)
        return(0) ;

    opt=&first_option;
    while(opt != NULL)
    {
        if(opt->required && opt->answer == NULL)
        {
            fprintf(stderr,"Required option <%s> not set (%s).\n",
                opt->key, opt->description) ;
            err++ ;
        }
        opt = opt->next_opt ;
    }

    return(err) ;
}

static
split_opts()
{
    struct Option *opt ;
    char *ptr1 ;
    char *ptr2 ;
    int allocated ;
    int ans_num ;
    int len ;


    if(! n_opts)
        return ;

    opt=&first_option;
    while(opt != NULL)
    {
    if (opt->multiple && opt->answer != NULL)
    {
        /* Allocate some memory to store array of pointers */
        allocated = 10 ;
        opt->answers = (char **)G_malloc(allocated * sizeof(char *)) ;

        ans_num = 0 ;
        ptr1 = opt->answer ;
        opt->answers[ans_num] = NULL ;

        for(;;)
        {
            for(len=0, ptr2=ptr1; *ptr2 != NULL && *ptr2 != ','; ptr2++, len++)
                ;
            opt->answers[ans_num]=G_malloc(len+1) ;
            G_copy(opt->answers[ans_num], ptr1, len) ;

            if(*ptr2 == NULL)
                break ;
            
            ptr1 = ptr2+1 ;
                
            if(*ptr1 == NULL)
                break ;
            
            ans_num++ ;

            if(ans_num >= allocated)
            {
                allocated += 10 ;
                opt->answers =
                    (char **)G_realloc((char *)opt->answers,
                        allocated * sizeof(char *)) ;
            }

            opt->answers[ans_num] = NULL ;
        }
    }
    opt = opt->next_opt ;
    }
}

