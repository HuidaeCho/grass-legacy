

proc get_feature { type } {

  set dir ""
  case $type in {

       {raster} {
                      set dir "cell"
                  }

       {vector} {
                      set dir "dig"
                  }

       {sites} {
                      set dir "site_lists"
                  }

       {label} {
                      set dir "paint/labels"
                  }

       {group} {
                      set dir "group"
                  }

       {icon} {
                      set dir "paint/icons"
                  }

       {region} {
                      set dir "windows"
                  }

       {dlg} {
                      set dir "dlg"
                  }

       {dlg_ascii} {
                      set dir "dlg_ascii"
                  }

  }
  return $dir

}




proc put_list { the_listbox the_list } {

  $the_listbox delete 0 end
  foreach i $the_list {
      $the_listbox insert end $i
  }
}




proc get_list { path } {
  set list ""
  if { [file isdirectory $path] != 1 } {
     return $list
  }
  set current_dir [exec pwd]
  cd $path
  foreach i [exec ls -a [exec pwd]] {
     if { [string compare $i "."] != 0 && [string compare $i ".."] != 0 } {
        lappend list $i
     }
  }
  cd $current_dir
  return $list
}




proc mapset_listbox { type } {

  global database
  global location
  global mapset
  global feature

  global file_name
  set file_name ""

  toplevel .mapset

  wm geometry .mapset +100+100
  wm title .mapset {spatial layer}

  set feature [get_feature $type]

  global mapset_list

  frame .mapset.frame0 \
    -borderwidth {2} \
    -relief {flat}

  label .mapset.frame0.label \
    -anchor {w} \
    -text "Mapset"

  entry .mapset.frame0.mapset \
    -relief {sunken} \
   -width 20

  menubutton .mapset.frame0.mapsets \
    -bitmap {@../bitmap/arrow} \
    -menu {.mapset.frame0.mapsets.pulldown}

  menu .mapset.frame0.mapsets.pulldown

  set mapset_list [get_list "$database/$location"]
  foreach i $mapset_list {
      .mapset.frame0.mapsets.pulldown add command \
          -label $i \
          -command {
                     set mapset [lindex $mapset_list \
                               [.mapset.frame0.mapsets.pulldown index active] ]
                     .mapset.frame0.mapset delete 0 end
                     .mapset.frame0.mapset insert 0 $mapset
                     put_list .mapset.frame1.listbox \
                         [get_list "$database/$location/$mapset/$feature"]
                     set file_name ""
                   }
  }

  pack append .mapset.frame0 \
    .mapset.frame0.label { left } \
    .mapset.frame0.mapset { left } \
    .mapset.frame0.mapsets { right }

  frame .mapset.frame1 \
    -borderwidth {2} \
    -relief {raised}

  listbox .mapset.frame1.listbox \
    -relief {sunken} \
    -geometry 20x10 \
    -yscrollcommand {.mapset.frame1.vscrollbar set}

  scrollbar .mapset.frame1.vscrollbar \
    -command {.mapset.frame1.listbox yview}

  pack append .mapset.frame1 \
    .mapset.frame1.listbox { left expand fill } \
    .mapset.frame1.vscrollbar { right fill }

  frame .mapset.frame2 \
    -borderwidth {2}

  frame .mapset.frame2.frame

  button .mapset.frame2.frame.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command { if { $file_name != "" } {
                   destroy .mapset
               }
              }

  button .mapset.frame2.frame.cancel \
    -text Cancel \
    -relief raised \
    -padx 10 \
    -command { set file_name ""
               destroy .mapset
             }

  pack append .mapset.frame2.frame \
    .mapset.frame2.frame.ok { left expand } \
    .mapset.frame2.frame.cancel { right expand }

  pack append .mapset.frame2 \
    .mapset.frame2.frame { bottom frame center fill }

  pack append .mapset \
    .mapset.frame0 { top expand fill } \
    .mapset.frame1 { top expand fill } \
    .mapset.frame2 { bottom expand fill }

  bind .mapset.frame1.listbox <Button-1> {
        %W select from [%W nearest %y]
        %W select to [%W nearest %y]
	    set file_name [%W get [%W nearest %y]]
  }

  bind .mapset.frame1.listbox <ButtonRelease-1> {
        %W select from [%W nearest %y]
        %W select to [%W nearest %y]
	    set file_name [%W get [%W nearest %y]]
  }

  bind .mapset.frame1.listbox <Double-ButtonPress-1> {
        %W select from [%W nearest %y]
        %W select to [%W nearest %y]
	    set file_name [%W get [%W nearest %y]]
  }

  .mapset.frame0.mapset delete 0 end
  .mapset.frame0.mapset insert 0 $mapset

  .mapset.frame1.listbox delete 0 end
  put_list .mapset.frame1.listbox \
             [get_list "$database/$location/$mapset/$feature"]

  grab set .mapset
  tkwait window .mapset

  return $file_name

}




proc binary_map { } {


  toplevel .binary_map

  wm geometry .binary_map +100+20
  wm title .binary_map "binary_map"


  global pname


  frame .binary_map.frame0 \
    -relief {flat}

  label .binary_map.frame0.label \
    -anchor {w} \
    -text {Binary (1/0) raster map layer:} \
    -padx {2}

  scrollbar .binary_map.frame0.hscrollbar \
    -command {.binary_map.frame0.entry view} \
    -orient {horizontal}

  entry .binary_map.frame0.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.binary_map.frame0.hscrollbar set}

  button .binary_map.frame0.button \
    -relief {raised} \
    -anchor {n} \
    -text {raster} \
    -command { set file [mapset_listbox raster]
                if { $file != "" } {
                   set pname $file
                   .binary_map.frame0.entry delete 0 end
                   .binary_map.frame0.entry insert 0 $file
                   set_command_entry
                }
             }


  pack append .binary_map.frame0 \
    .binary_map.frame0.label { top fillx } \
    .binary_map.frame0.button { right frame n } \
    .binary_map.frame0.entry { top fill } \
    .binary_map.frame0.hscrollbar { top fillx }



  bind .binary_map.frame0.entry <Return> {
       set pname [%W get] }


  frame .binary_map.frame1 \
     -borderwidth {2}

  button .binary_map.frame1.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command {
                  set pname [.binary_map.frame0.entry get]
                 destroy .binary_map }

  button .binary_map.frame1.cancel \
     -text Cancel \
     -relief raised \
     -padx 10 \
     -command {
                  set pname ""
                 destroy .binary_map }

  pack append .binary_map.frame1 \
    .binary_map.frame1.ok { left expand } \
    .binary_map.frame1.cancel { right expand }



  pack append .binary_map \
    .binary_map.frame0 { top expand fill } \
    .binary_map.frame1 { bottom expand fill }



  grab set .binary_map
  tkwait window .binary_map

}




proc height { } {


  toplevel .height

  wm geometry .height +100+20
  wm title .height "height"


  global ovalue


  frame .height.frame0 \
    -relief {flat}

  label .height.frame0.label \
    -anchor {w} \
    -text {Height of the observer above the viewing point's elevation:} \
    -padx {2}

  scrollbar .height.frame0.hscrollbar \
    -command {.height.frame0.entry view} \
    -orient {horizontal}

  entry .height.frame0.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.height.frame0.hscrollbar set}

  pack append .height.frame0 \
    .height.frame0.label { top fillx } \
    .height.frame0.entry { top fillx } \
    .height.frame0.hscrollbar { bottom fillx }

  .height.frame0.entry configure -state normal

  bind .height.frame0.entry <Return> {
       set ovalue [%W get] }



  frame .height.frame1 \
     -borderwidth {2}

  button .height.frame1.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command {
                  set ovalue [.height.frame0.entry get]
                 destroy .height }

  button .height.frame1.cancel \
     -text Cancel \
     -relief raised \
     -padx 10 \
     -command {
                  set ovalue ""
                 destroy .height }

  pack append .height.frame1 \
    .height.frame1.ok { left expand } \
    .height.frame1.cancel { right expand }



  pack append .height \
    .height.frame0 { top expand fill } \
    .height.frame1 { bottom expand fill }



  grab set .height
  tkwait window .height

}




proc distance { } {


  toplevel .distance

  wm geometry .distance +100+20
  wm title .distance "distance"


  global mvalue


  frame .distance.frame0 \
    -relief {flat}

  label .distance.frame0.label \
    -anchor {w} \
    -text {Maximum distance from the viewing point:} \
    -padx {2}

  scrollbar .distance.frame0.hscrollbar \
    -command {.distance.frame0.entry view} \
    -orient {horizontal}

  entry .distance.frame0.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.distance.frame0.hscrollbar set}

  pack append .distance.frame0 \
    .distance.frame0.label { top fillx } \
    .distance.frame0.entry { top fillx } \
    .distance.frame0.hscrollbar { bottom fillx }

  .distance.frame0.entry configure -state normal

  bind .distance.frame0.entry <Return> {
       set mvalue [%W get] }



  frame .distance.frame1 \
     -borderwidth {2}

  button .distance.frame1.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command {
                  set mvalue [.distance.frame0.entry get]
                 destroy .distance }

  button .distance.frame1.cancel \
     -text Cancel \
     -relief raised \
     -padx 10 \
     -command {
                  set mvalue ""
                 destroy .distance }

  pack append .distance.frame1 \
    .distance.frame1.ok { left expand } \
    .distance.frame1.cancel { right expand }



  pack append .distance \
    .distance.frame0 { top expand fill } \
    .distance.frame1 { bottom expand fill }



  grab set .distance
  tkwait window .distance

}




proc put_command { } {


  global iname
  global oname
  global coordinate
  global pname
  global ovalue
  global mvalue


  set cmd ""

  if {  $iname != "" } {
         set cmd "$cmd input=$iname"
  }

  if {  $oname != "" } {
         set cmd "$cmd output=$oname"
  }

  if {  $coordinate != "" } {
         set cmd "$cmd coordinate=$coordinate"
  }

  if {  $pname != "" } {
         set cmd "$cmd patt_map=$pname"
  }

  if {  $ovalue != "" } {
         set cmd "$cmd obs_elev=$ovalue"
  }

  if {  $mvalue != "" } {
         set cmd "$cmd max_dist=$mvalue"
  }

  if { $cmd != "" } {
     set cmd "r.los $cmd"
  }
}




proc set_command_entry { } {

  .cmd.frame0.entry configure -state normal
  .cmd.frame0.entry delete 0 end
  .cmd.frame0.entry insert 0 [put_command]
  .cmd.frame0.entry configure -state disabled

}


proc proc_r.los { } {


  global iname
  global oname
  global coordinate
  global pname
  global ovalue
  global mvalue


  toplevel .cmd

  wm geometry .cmd +100+20

  wm title .cmd "Perform Line-of-Sight Analysis"


  frame .cmd.frame0 \
    -relief {flat}

  label .cmd.frame0.label \
    -anchor {w} \
    -text {Command:} \
    -padx {2}

  scrollbar .cmd.frame0.hscrollbar \
    -command {.cmd.frame0.entry view} \
    -orient {horizontal}

  entry .cmd.frame0.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame0.hscrollbar set}

  pack append .cmd.frame0 \
    .cmd.frame0.label { top fillx } \
    .cmd.frame0.entry { top fillx } \
    .cmd.frame0.hscrollbar { bottom fillx }

  .cmd.frame0.entry delete 0 end
  .cmd.frame0.entry insert 0 {r.los}

  .cmd.frame0.entry configure -state disabled



  frame .cmd.frame1 \
    -relief {flat}

  label .cmd.frame1.label \
    -anchor {w} \
    -text {Description:} \
    -padx {2}

  scrollbar .cmd.frame1.hscrollbar \
    -command {.cmd.frame1.entry view} \
    -orient {horizontal}

  entry .cmd.frame1.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame1.hscrollbar set}

  pack append .cmd.frame1 \
    .cmd.frame1.label { top fillx } \
    .cmd.frame1.entry { top fillx } \
    .cmd.frame1.hscrollbar { bottom fillx }

  .cmd.frame1.entry delete 0 end
  .cmd.frame1.entry insert 0 {r.los generates a raster map output in which the cells that are visible from a user-specified observer location are marked with integer vlues that represent the vertical angle (in degrees) required to see those cells.}

  .cmd.frame1.entry configure -state disabled



  frame .cmd.frame2 \
    -relief {flat}

  label .cmd.frame2.label \
    -anchor {w} \
    -text {Raster map containing elevation data:} \
    -padx {2}

  scrollbar .cmd.frame2.hscrollbar \
    -command {.cmd.frame2.entry view} \
    -orient {horizontal}

  entry .cmd.frame2.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame2.hscrollbar set}

  button .cmd.frame2.button \
    -relief {raised} \
    -anchor {n} \
    -text {raster} \
    -command { set file [mapset_listbox raster]
                if { $file != "" } {
                   set iname $file
                   .cmd.frame2.entry delete 0 end
                   .cmd.frame2.entry insert 0 $file
                   set_command_entry
                }
             }


  pack append .cmd.frame2 \
    .cmd.frame2.label { top fillx } \
    .cmd.frame2.button { right frame n } \
    .cmd.frame2.entry { top fill } \
    .cmd.frame2.hscrollbar { top fillx }



  bind .cmd.frame2.entry <Return> {
       set iname [%W get] }


  frame .cmd.frame3 \
    -relief {flat}

  label .cmd.frame3.label \
    -anchor {w} \
    -text {File to contain output:} \
    -padx {2}

  scrollbar .cmd.frame3.hscrollbar \
    -command {.cmd.frame3.entry view} \
    -orient {horizontal}

  entry .cmd.frame3.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame3.hscrollbar set}

  pack append .cmd.frame3 \
    .cmd.frame3.label { top fillx } \
    .cmd.frame3.entry { top fillx } \
    .cmd.frame3.hscrollbar { bottom fillx }

  .cmd.frame3.entry configure -state normal

  bind .cmd.frame3.entry <Return> {
       set oname [%W get] }



  frame .cmd.frame4 \
    -relief {flat}

  label .cmd.frame4.label \
    -anchor {w} \
    -text {Geographic coordinates identifying the viewing point:} \
    -padx {2}

  scrollbar .cmd.frame4.hscrollbar \
    -command {.cmd.frame4.entry view} \
    -orient {horizontal}

  entry .cmd.frame4.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame4.hscrollbar set}

  pack append .cmd.frame4 \
    .cmd.frame4.label { top fillx } \
    .cmd.frame4.entry { top fillx } \
    .cmd.frame4.hscrollbar { bottom fillx }

  .cmd.frame4.entry configure -state normal

  bind .cmd.frame4.entry <Return> {
       set coordinate [%W get] }



  frame .cmd.frame5 \
    -relief {flat}

  label .cmd.frame5.label \
    -anchor {w} \
    -text {Other options available:} \
    -padx {2}

  button .cmd.frame5.button0 \
     -text "binary_map ..." \
     -relief raised \
     -padx 10 \
     -command "binary_map
                set_command_entry"


  button .cmd.frame5.button1 \
     -text "height ..." \
     -relief raised \
     -padx 10 \
     -command "height
                set_command_entry"


  button .cmd.frame5.button2 \
     -text "distance ..." \
     -relief raised \
     -padx 10 \
     -command "distance
                set_command_entry"


  frame .cmd.frame6 \
     -borderwidth {2}

  button .cmd.frame6.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command { 
		if {  $iname != "" && $oname != "" && $coordinate != "" } {
 		set cmd [put_command]
 		if { $cmd != "" } {
 		   eval " exec xterm -title r.los -geometry 50x5 -exec $cmd " 
 		   destroy .cmd
 		}
 	}
 }

  button .cmd.frame6.cancel \
     -text Cancel \
     -relief raised \
     -padx 10 \
     -command { destroy .cmd }

  pack append .cmd.frame6 \
    .cmd.frame6.ok { left expand } \
    .cmd.frame6.cancel { right expand }

  pack append .cmd.frame5 \
    .cmd.frame5.label { top fillx } \
    .cmd.frame5.button0 { left } \
    .cmd.frame5.button1 { left } \
    .cmd.frame5.button2  { left }



  pack append .cmd \
    .cmd.frame1 { top expand fill } \
    .cmd.frame2 { top expand fill } \
    .cmd.frame3 { top expand fill } \
    .cmd.frame4 { top expand fill } \
    .cmd.frame5 { top expand fill } \
    .cmd.frame0 { top expand fill } \
    .cmd.frame6 { bottom expand fill }


bind .cmd.frame3.entry <KeyRelease> {
		set oname [.cmd.frame3.entry get]
		set_command_entry
}

bind .cmd.frame3.entry <Return> {
		set oname [.cmd.frame3.entry get]
		set_command_entry
}

bind .cmd.frame4.entry <KeyRelease> {
		set coordinate [.cmd.frame4.entry get]
		set_command_entry
}

bind .cmd.frame4.entry <Return> {
		set coordinate [.cmd.frame4.entry get]
		set_command_entry
}

  grab set .cmd
  tkwait window .cmd

}

global iname
set iname ""

global oname
set oname ""

global coordinate
set coordinate ""

global pname
set pname ""

global ovalue
set ovalue ""

global mvalue
set mvalue ""


global database
global location
global mapset
global feature
if { [info exists env(GISDBASE)] == 0 ||
     [info exists env(LOCATION_NAME)] == 0 ||
     [info exists env(MAPSET)] == 0 } {
   puts stdout "GISDBASE, LOCATION_NAME and MAPSET must be set !!!"
   return
}
set database $env(GISDBASE)
set location $env(LOCATION_NAME)
set mapset $env(MAPSET)
set feature ""

proc_r.los
