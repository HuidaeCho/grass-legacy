

proc get_feature { type } {

  set dir ""
  case $type in {

       {raster} {
                      set dir "cell"
                  }

       {vector} {
                      set dir "dig"
                  }

       {sites} {
                      set dir "site_lists"
                  }

       {label} {
                      set dir "paint/labels"
                  }

       {group} {
                      set dir "group"
                  }

       {icon} {
                      set dir "paint/icons"
                  }

       {region} {
                      set dir "windows"
                  }

       {dlg} {
                      set dir "dlg"
                  }

       {dlg_ascii} {
                      set dir "dlg_ascii"
                  }

  }
  return $dir

}




proc put_list { the_listbox the_list } {

  $the_listbox delete 0 end
  foreach i $the_list {
      $the_listbox insert end $i
  }
}




proc get_list { path } {
  set list ""
  if { [file isdirectory $path] != 1 } {
     return $list
  }
  set current_dir [exec pwd]
  cd $path
  foreach i [exec ls -a [exec pwd]] {
     if { [string compare $i "."] != 0 && [string compare $i ".."] != 0 } {
        lappend list $i
     }
  }
  cd $current_dir
  return $list
}




proc mapset_listbox { type } {

  global database
  global location
  global mapset
  global feature

  global file_name
  set file_name ""

  toplevel .mapset

  wm geometry .mapset +100+100
  wm title .mapset {spatial layer}

  set feature [get_feature $type]

  global mapset_list

  frame .mapset.frame0 \
    -borderwidth {2} \
    -relief {flat}

  label .mapset.frame0.label \
    -anchor {w} \
    -text "Mapset"

  entry .mapset.frame0.mapset \
    -relief {sunken} \
   -width 20

  menubutton .mapset.frame0.mapsets \
    -bitmap {@../bitmap/arrow} \
    -menu {.mapset.frame0.mapsets.pulldown}

  menu .mapset.frame0.mapsets.pulldown

  set mapset_list [get_list "$database/$location"]
  foreach i $mapset_list {
      .mapset.frame0.mapsets.pulldown add command \
          -label $i \
          -command {
                     set mapset [lindex $mapset_list \
                               [.mapset.frame0.mapsets.pulldown index active] ]
                     .mapset.frame0.mapset delete 0 end
                     .mapset.frame0.mapset insert 0 $mapset
                     put_list .mapset.frame1.listbox \
                         [get_list "$database/$location/$mapset/$feature"]
                     set file_name ""
                   }
  }

  pack append .mapset.frame0 \
    .mapset.frame0.label { left } \
    .mapset.frame0.mapset { left } \
    .mapset.frame0.mapsets { right }

  frame .mapset.frame1 \
    -borderwidth {2} \
    -relief {raised}

  listbox .mapset.frame1.listbox \
    -relief {sunken} \
    -geometry 20x10 \
    -yscrollcommand {.mapset.frame1.vscrollbar set}

  scrollbar .mapset.frame1.vscrollbar \
    -command {.mapset.frame1.listbox yview}

  pack append .mapset.frame1 \
    .mapset.frame1.listbox { left expand fill } \
    .mapset.frame1.vscrollbar { right fill }

  frame .mapset.frame2 \
    -borderwidth {2}

  frame .mapset.frame2.frame

  button .mapset.frame2.frame.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command { if { $file_name != "" } {
                   destroy .mapset
               }
              }

  button .mapset.frame2.frame.cancel \
    -text Cancel \
    -relief raised \
    -padx 10 \
    -command { set file_name ""
               destroy .mapset
             }

  pack append .mapset.frame2.frame \
    .mapset.frame2.frame.ok { left expand } \
    .mapset.frame2.frame.cancel { right expand }

  pack append .mapset.frame2 \
    .mapset.frame2.frame { bottom frame center fill }

  pack append .mapset \
    .mapset.frame0 { top expand fill } \
    .mapset.frame1 { top expand fill } \
    .mapset.frame2 { bottom expand fill }

  bind .mapset.frame1.listbox <Button-1> {
        %W select from [%W nearest %y]
        %W select to [%W nearest %y]
	    set file_name [%W get [%W nearest %y]]
  }

  bind .mapset.frame1.listbox <ButtonRelease-1> {
        %W select from [%W nearest %y]
        %W select to [%W nearest %y]
	    set file_name [%W get [%W nearest %y]]
  }

  bind .mapset.frame1.listbox <Double-ButtonPress-1> {
        %W select from [%W nearest %y]
        %W select to [%W nearest %y]
	    set file_name [%W get [%W nearest %y]]
  }

  .mapset.frame0.mapset delete 0 end
  .mapset.frame0.mapset insert 0 $mapset

  .mapset.frame1.listbox delete 0 end
  put_list .mapset.frame1.listbox \
             [get_list "$database/$location/$mapset/$feature"]

  grab set .mapset
  tkwait window .mapset

  return $file_name

}




proc flags { } {


  toplevel .flags

  wm geometry .flags +100+20
  wm title .flags "flags"


  global h


  frame .flags.frame0 \
    -relief {flat}

  checkbutton .flags.frame0.checkbutton \
     -text "Suppress the print out of page headers" \
     -relief flat \
     -anchor {w} \
     -onvalue "h" \
     -offvalue "" \
     -variable h

  pack append .flags.frame0 \
    .flags.frame0.checkbutton { left }

  global f


  frame .flags.frame1 \
    -relief {flat}

  checkbutton .flags.frame1.checkbutton \
     -text "Use formfeeds between pages when printing report output" \
     -relief flat \
     -anchor {w} \
     -onvalue "f" \
     -offvalue "" \
     -variable f

  pack append .flags.frame1 \
    .flags.frame1.checkbutton { left }

  global q


  frame .flags.frame2 \
    -relief {flat}

  checkbutton .flags.frame2.checkbutton \
     -text "Run quietly, without printing program messages to standard output" \
     -relief flat \
     -anchor {w} \
     -onvalue "q" \
     -offvalue "" \
     -variable q

  pack append .flags.frame2 \
    .flags.frame2.checkbutton { left }


  frame .flags.frame3 \
     -borderwidth {2}

  button .flags.frame3.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command {
                 destroy .flags }

  button .flags.frame3.cancel \
     -text Cancel \
     -relief raised \
     -padx 10 \
     -command {
                 destroy .flags }

  pack append .flags.frame3 \
    .flags.frame3.ok { left expand } \
    .flags.frame3.cancel { right expand }


bind .flags.frame0.checkbutton <Return> {
     focus .flags.frame1.checkbutton
}

bind .flags.frame1.checkbutton <Return> {
     focus .flags.frame2.checkbutton
}

bind .flags.frame2.checkbutton <Return> {
     focus .flags.frame0.checkbutton
}


  pack append .flags \
    .flags.frame0 { top expand fill } \
    .flags.frame1 { top expand fill } \
    .flags.frame2 { top expand fill } \
    .flags.frame3 { bottom expand fill }



  grab set .flags
  tkwait window .flags

}




proc units { } {


  toplevel .units

  wm geometry .units +100+20
  wm title .units "units"


  global uname


  frame .units.frame0 \
    -relief {flat}

  label .units.frame0.label \
     -anchor {w} \
     -text {Unit of measure in which results are to be reported:} \
     -padx {2}

  listbox .units.frame0.listbox \
     -relief sunken \
     -yscrollcommand {.units.frame0.vscrollbar set}

  scrollbar .units.frame0.vscrollbar \
     -command {.units.frame0.listbox yview}


  pack append .units.frame0 \
    .units.frame0.label { top fillx } \
    .units.frame0.listbox { left expand fill } \
    .units.frame0.vscrollbar { right fill }

  bind .units.frame0.listbox <Button-1> {
       %W select from [%W nearest %y]
       %W select to [%W nearest %y]
       set uname [%W get [%W nearest %y]]
  }

  bind .units.frame0.listbox <ButtonRelease-1> {
       %W select from [%W nearest %y]
       %W select to [%W nearest %y]
       set uname [%W get [%W nearest %y]]
  }

  bind .units.frame0.listbox <Double-ButtonPress-1> {
       %W select from [%W nearest %y]
       %W select to [%W nearest %y]
       set uname [%W get [%W nearest %y]]
  }

  .units.frame0.listbox delete 0 end
  foreach i {mi me k a h c p} {
      .units.frame0.listbox insert 0 $i
  }


  frame .units.frame1 \
     -borderwidth {2}

  button .units.frame1.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command {
                 destroy .units }

  button .units.frame1.cancel \
     -text Cancel \
     -relief raised \
     -padx 10 \
     -command {
                 destroy .units }

  pack append .units.frame1 \
    .units.frame1.ok { left expand } \
    .units.frame1.cancel { right expand }



  pack append .units \
    .units.frame0 { top expand fill } \
    .units.frame1 { bottom expand fill }



  grab set .units
  tkwait window .units

}




proc page_width { } {


  toplevel .page_width

  wm geometry .page_width +100+20
  wm title .page_width "page_width"


  global pwvalue


  frame .page_width.frame0 \
    -relief {flat}

  scale .page_width.frame0.scale \
     -label "Page width, in characters, in which the report will be output" \
     -from 0 \
     -to 132 \
     -length 350 \
     -orient {horizontal}

  pack append .page_width.frame0 \
    .page_width.frame0.scale { left expand fill }

  .page_width.frame0.scale set 79


  frame .page_width.frame1 \
     -borderwidth {2}

  button .page_width.frame1.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command {
                  set pwvalue [.page_width.frame0.scale get]
                 destroy .page_width }

  button .page_width.frame1.cancel \
     -text Cancel \
     -relief raised \
     -padx 10 \
     -command {
                  set pwvalue ""
                 destroy .page_width }

  pack append .page_width.frame1 \
    .page_width.frame1.ok { left expand } \
    .page_width.frame1.cancel { right expand }



  pack append .page_width \
    .page_width.frame0 { top expand fill } \
    .page_width.frame1 { bottom expand fill }



  grab set .page_width
  tkwait window .page_width

}




proc put_command { } {


  global h
  global m
  global f
  global q
  global mname
  global oname
  global uname
  global plvalue
  global pwvalue


  set cmd ""

  if {  $h != "" || $m != "" || $f != "" || $q != "" } {
         set cmd "$cmd -$h$m$f$q"
  }

  if {  $mname != "" } {
         set cmd "$cmd map=$mname"
  }

  if {  $oname != "" } {
         set cmd "$cmd output=$oname"
  }

  if {  $uname != "" } {
         set cmd "$cmd units=$uname"
  }

  if {  $plvalue != "" } {
         set cmd "$cmd pl=$plvalue"
  }

  if {  $pwvalue != "" } {
         set cmd "$cmd pw=$pwvalue"
  }

  if { $cmd != "" } {
     set cmd "r.report $cmd"
  }
}




proc set_command_entry { } {

  .cmd.frame0.entry configure -state normal
  .cmd.frame0.entry delete 0 end
  .cmd.frame0.entry insert 0 [put_command]
  .cmd.frame0.entry configure -state disabled

}


proc proc_r.report { } {


  global h
  global m
  global f
  global q
  global mname
  global oname
  global uname
  global plvalue
  global pwvalue


  toplevel .cmd

  wm geometry .cmd +100+20

  wm title .cmd "Report Raster Statistics"


  frame .cmd.frame0 \
    -relief {flat}

  label .cmd.frame0.label \
    -anchor {w} \
    -text {Command:} \
    -padx {2}

  scrollbar .cmd.frame0.hscrollbar \
    -command {.cmd.frame0.entry view} \
    -orient {horizontal}

  entry .cmd.frame0.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame0.hscrollbar set}

  pack append .cmd.frame0 \
    .cmd.frame0.label { top fillx } \
    .cmd.frame0.entry { top fillx } \
    .cmd.frame0.hscrollbar { bottom fillx }

  .cmd.frame0.entry delete 0 end
  .cmd.frame0.entry insert 0 {r.report}

  .cmd.frame0.entry configure -state disabled



  frame .cmd.frame1 \
    -relief {flat}

  label .cmd.frame1.label \
    -anchor {w} \
    -text {Description:} \
    -padx {2}

  scrollbar .cmd.frame1.hscrollbar \
    -command {.cmd.frame1.entry view} \
    -orient {horizontal}

  entry .cmd.frame1.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame1.hscrollbar set}

  pack append .cmd.frame1 \
    .cmd.frame1.label { top fillx } \
    .cmd.frame1.entry { top fillx } \
    .cmd.frame1.hscrollbar { bottom fillx }

  .cmd.frame1.entry delete 0 end
  .cmd.frame1.entry insert 0 {r.report reports statistics for raster map layers.}

  .cmd.frame1.entry configure -state disabled



  frame .cmd.frame2 \
    -relief {flat}

  label .cmd.frame2.label \
    -anchor {w} \
    -text {Existing raster map layer(s) to be reported on:} \
    -padx {2}

  scrollbar .cmd.frame2.hscrollbar \
    -command {.cmd.frame2.entry view} \
    -orient {horizontal}

  entry .cmd.frame2.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame2.hscrollbar set}

  button .cmd.frame2.button \
    -relief {raised} \
    -anchor {n} \
    -text {raster} \
    -command { set file [mapset_listbox raster]
                if { $file != "" } {
                   set mname $file
                   .cmd.frame2.entry delete 0 end
                   .cmd.frame2.entry insert 0 $file
                   set_command_entry
                }
             }


  pack append .cmd.frame2 \
    .cmd.frame2.label { top fillx } \
    .cmd.frame2.button { right frame n } \
    .cmd.frame2.entry { top fill } \
    .cmd.frame2.hscrollbar { top fillx }



  bind .cmd.frame2.entry <Return> {
       set mname [%W get] }


  frame .cmd.frame3 \
    -relief {flat}

  label .cmd.frame3.label \
    -anchor {w} \
    -text {Name of the file to store the report in:} \
    -padx {2}

  scrollbar .cmd.frame3.hscrollbar \
    -command {.cmd.frame3.entry view} \
    -orient {horizontal}

  entry .cmd.frame3.entry \
    -relief {sunken} \
    -width 50 \
    -scrollcommand {.cmd.frame3.hscrollbar set}

  pack append .cmd.frame3 \
    .cmd.frame3.label { top fillx } \
    .cmd.frame3.entry { top fillx } \
    .cmd.frame3.hscrollbar { bottom fillx }

  .cmd.frame3.entry configure -state normal

  bind .cmd.frame3.entry <Return> {
       set oname [%W get] }



  frame .cmd.frame4 \
    -relief {flat}

  label .cmd.frame4.label \
    -anchor {w} \
    -text {Other options available:} \
    -padx {2}

  button .cmd.frame4.button0 \
     -text "flags ..." \
     -relief raised \
     -padx 10 \
     -command "flags
                set_command_entry"


  button .cmd.frame4.button1 \
     -text "units ..." \
     -relief raised \
     -padx 10 \
     -command "units
                set_command_entry"


  button .cmd.frame4.button2 \
     -text "page_width ..." \
     -relief raised \
     -padx 10 \
     -command "page_width
                set_command_entry"


  frame .cmd.frame5 \
     -borderwidth {2}

  button .cmd.frame5.ok \
     -text Ok \
     -relief raised \
     -padx 10 \
     -command { 
		if {  $mname != "" } {
 		set cmd [put_command]
 		if { $cmd != "" } {
		   catch {eval "exec $cmd" } retmes
 		   editor $retmes 
 		   destroy .cmd
 		}
 	}
 }

  button .cmd.frame5.cancel \
     -text Cancel \
     -relief raised \
     -padx 10 \
     -command { destroy .cmd }

  pack append .cmd.frame5 \
    .cmd.frame5.ok { left expand } \
    .cmd.frame5.cancel { right expand }

  pack append .cmd.frame4 \
    .cmd.frame4.label { top fillx } \
    .cmd.frame4.button0 { left } \
    .cmd.frame4.button1 { left } \
    .cmd.frame4.button2  { left }



  pack append .cmd \
    .cmd.frame1 { top expand fill } \
    .cmd.frame2 { top expand fill } \
    .cmd.frame3 { top expand fill } \
    .cmd.frame4 { top expand fill } \
    .cmd.frame0 { top expand fill } \
    .cmd.frame5 { bottom expand fill }


bind .cmd.frame3.entry <KeyRelease> {
		set oname [.cmd.frame3.entry get]
		set_command_entry
}

bind .cmd.frame3.entry <Return> {
		set oname [.cmd.frame3.entry get]
		set_command_entry
}

  grab set .cmd
  tkwait window .cmd

}

global h
set h ""

global m
set m ""

global f
set f ""

global q
set q ""

global mname
set mname ""

global oname
set oname ""

global uname
set uname ""

global plvalue
set plvalue ""

global pwvalue
set pwvalue ""


global database
global location
global mapset
global feature
if { [info exists env(GISDBASE)] == 0 ||
     [info exists env(LOCATION_NAME)] == 0 ||
     [info exists env(MAPSET)] == 0 } {
   puts stdout "GISDBASE, LOCATION_NAME and MAPSET must be set !!!"
   return
}
set database $env(GISDBASE)
set location $env(LOCATION_NAME)
set mapset $env(MAPSET)
set feature ""

proc_r.report
