#!/bin/sh
CHECK.MAP
if test $? = 1
	then
	exit
fi
tput clear
proj=`grep proj: $LOCATION/WIND | awk '/proj:/ {print $2}'`
if test $proj != 1 -a $proj != 4
        then
        echo ERROR: unable to process projection $proj
        exit
fi
zone=`grep zone: $LOCATION/WIND | awk '/zone:/ {print $2}'`
PARMS=`cat .PARMS`
if test ! -d fills
        then
        mkdir fills
fi
if test ! -d fills/cat
        then
        mkdir fills/cat
fi
if test ! -d legend
        then
        mkdir legend
fi

################ get map definition file ##################################
mdef=`date +"$H$M%S"`
while test ! -f $mdef
do
	echo -n "Enter the name of the map definition file [map.def]: "
	read mdef
	if test "$mdef" = ""
		then
		mdef=map.def
	fi
done
echo

############# GET DIG FILE ###############################################
Gask old "" dig "" tmp
. tmp
rm tmp
if test "$name" = ""; then
	exit
fi

########### GET NAME FOR THIS FILL #######################################
if test $# -eq 1; then
	out=$1
fi
if test -f fills/$out
	then
	echo -n "Fill $out exists. Do you want to redo it [y]es (n)o: "
	read answ
	echo
	if test "$answ" = "n"
		then
		out=""
	fi
fi
echo

while test "$out" = ""
do
echo -n "Enter the name for this fill overlay [$name.f]: "
read out
out=${out:-$name.f}
if test -f fills/$out
	then
	echo -n "Fill $out exists. Do you want to redo it [y]es (n)o: "
	read answ
	if test "$answ" = "n"
		then
		out=""
	fi
fi
done
echo
######################## END get overlay name ####################

############## GET PATTERNS ##############################################
answ=l
echo "Enter the list of the patterns to use or [l] to list the choices end with a ."
while test "$answ" = "l"
do
echo -n ": "
read answ
if test "$answ" = "blank"; then
	pat=$answ
	break
fi
if test "$answ" = "" -o "$answ" = "l"
        then
	answ=l
	echo -n "blank "
        ls -x $GRAPH/etc/pattern 2> /dev/null
elif test "$answ" = "."
	then
	answ=
elif test ! -f $GRAPH/etc/pattern/$answ
	then
		echo Error pattern $answ not found
		answ=l
else
		pat=`echo -n "$pat $answ"`
		fi
done
echo
echo $pat$answ



if test "$pat" = "blank" -a "$out" != "blank"; then
	echo Changing overlay file name to blank to accomodate make.leg!
	out=blank
else
{
######################## get pen number ######################################

echo -n 'Enter the pen number to use [1]: '
read pen
echo
if test "$pen" = ""
	then
	pen=1
fi

################### GET CATEGORIES TO FILL ##########################
tput clear
cattype=i
if test -f fills/cat/$out
	then
	rm fills/cat/$out
fi
while test "$cattype" != "d" -a "$cattype" != "n" -a "$cattype" != "f"
        do
        echo -n 'Select areas by category (d)escription, [n]umber, or (f)irst category: '
        read cattype
	cattype=${cattype:-n}
        if test "$cattype" = "d"
                then
                Gask old "" dig_cats "" tmp
                fi
        done
	echo
i=0
################# Get category numbers ###########################
if test "$cattype" != "f"
	then
	{
	while test "$select" != "t" -a "$select" != "f"
	do
        echo 'How do you want to enter the categories? Enter:'
        echo f -- to read from a file
        echo t -- to be prompted
        echo
        echo -n 'Enter (f)ile, [t]ype: '
        read select
	select=${select:-t}
	done
	if test $select = t
	        then
	        echo Enter the categories one per line end with a .
	        while test 1
	                do
	                echo -n :
	                read cat
	                if test "$cat" = "."
 	                       then
 	                       break
	                fi
	                echo "$cat" >> fills/cat/$out
	                i=`expr $i + 1`
 	               done
	elif test $select = f
	        then
	        echo -n 'Enter file name: '
	        read fil
	        cp $fil fills/cat/$out
	fi
	}
####################### End get category numbers ################################
else 
        echo -n > fills/cat/$out
fi
i=`wc -l < fills/cat/$out`
j=1
if test $cattype = d -a $i -ne 0
        then 
        catfile=`tr -d "'" < tmp | awk -F= '/file/ {print $2}'`
        rm tmp  2> /dev/null
	sort < fills/cat/$out > $out.tmp
	mv $out.tmp fills/cat/$out
        prev=""
	while test $j -le $i
        do
	cat=`head -$j < fills/cat/$out | tail -1`
        if test "$cat" != "$prev"
                then
#                echo $cat
                egrep ":$cat:" $catfile | awk -F: '{print $1}' >> $out.tmp
                prev=$cat
        fi
	j=`expr $j + 1`
        done
        mv $out.tmp fills/cat/tmp
else
	catfile=""
	cp fills/cat/$out fills/cat/tmp
fi
i=`wc -l  < fills/cat/tmp`

if test $i -gt 0
        then
	i="-S $i"
elif test $cattype = f
	then
	i=""
else
	echo ERROR no categories found for fill:
	rm fills/cat/$out
	exit
fi
}
fi

if test -f legend/$out
	then rm legend/$out
fi
echo
echo "Enter the legend text for fill $out end with a ."
cat=s
while test "$cat" != "."
do
echo -n ": "
read cat
if test "$cat" != "."
	then
	echo $cat >> legend/$out
fi
done

if test "$pat" != "blank"; then
{
#### calculate line spacing in meters on the ground ######
scale=`mapdef -v $mdef | awk '/scale/ {print $4}'` 

########## Store record of fill #######################
echo scale=$scale > fills/$out
echo pat=\"$pat\" >> fills/$out
echo pen=$pen >> fills/$out
echo name=$name >> fills/$out
echo zone=$zone >> fills/$out
echo proj=$proj >> fills/$out
echo mapset=$mapset >> fills/$out
echo map=$mdef >> fills/$out
echo cattype=$cattype >> fills/$out
echo catfile=$catfile >> fills/$out

############## DO FILS ###############################
if test -f ovm/$out
	then
	rm ovm/$out
fi
for j in $pat
do
echo Doing pattern $j
. $GRAPH/etc/pattern/$j
#space=`echo $scale $space | awk '{tot=$1 * $2 / 100; print tot}'`

if test $proj = 1
        then
	cmd="fill_dig -sp $space -c $pen -a $angle -sc $scale $i $mapset $name < fills/cat/tmp |\
        proj $PARMS +inv - "
elif test $proj = 4
        then
        cmd="fill_dig -sp $space -c $pen -a $angle -sc $scale $i $mapset $name < fills/cat/tmp |\
        proj $PARMS +inv - "
fi
if test "$line" = "solid"
	then
        cmd="$cmd | lines -c \"-d 1,2 \" -m $mdef -o $out.tmp"
else
	cmd="$cmd | lines -c \"-d 1,2 -ls .2 -lm 0x6666 -ld \" -m $mdef -o $out.tmp"
fi
eval $cmd
cat $out.tmp >> ovm/$out
done
rm $out.tmp fills/cat/tmp
}
fi
tput clear

echo " make.fill complete
	Map definition file	$mdef
	GRASS digit file	$name
	Overlay file created	ovm/$out
	Category list file	fills/cat/$out
	Parameters
		fill patterns	$pat
"
