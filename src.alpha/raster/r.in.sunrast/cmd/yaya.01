#!/bin/sh
# This is a shell archive (shar 3.10)
# made 10/05/1992 22:57 UTC by parghi@amber
# Source directory /net/grass.src/4.1/src.alpha/raster/r.in.sunrast/cmd
#
# existing files WILL be overwritten
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   5661 -rw-rw-r-- main.c
#   3309 -rw-rw-r-- diff.921005
#
touch 2>&1 | fgrep '[-amc]' > /tmp/s3_touch$$
if [ -s /tmp/s3_touch$$ ]
then
	TOUCH=can
else
	TOUCH=cannot
fi
rm -f /tmp/s3_touch$$
# ============= main.c ==============
echo "x - extracting main.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > main.c &&
X#include "gis.h"
X#include "rast.h"
X
X
Xint verbose;
Xint adjust;
X
X#define CUR_MAX_CLR 256
Xunsigned char *cats_used; /* dpg*/
Xunsigned char red[CUR_MAX_CLR], grn[CUR_MAX_CLR], blu[CUR_MAX_CLR];
X
X
Xmain(argc, argv) char *argv[];
X{
X    CELL cat;
X    struct Cell_head window;
X    struct Colors colors;
X    int nrows, ncols, depth;
X    int fd1, fd2;
X    struct Option *input, *output;
X    struct Flag *quiet, *noadjust;
X
X    G_gisinit (argv[0]);
X    G_get_window (&window);
X
X    input = G_define_option();
X    input->key = "input";
X    input->type = TYPE_STRING;
X    input->description = "Sun rasterfile to input";
X    input->required = YES;
X
X    output = G_define_option();
X    output->key = "output";
X    output->type = TYPE_STRING;
X    output->description = "GRASS raster map to be created";
X    output->required = YES;
X    output->gisprompt = "any,cell,raster";
X
X    noadjust = G_define_flag();
X    noadjust->key = 'a';
X    noadjust->description = "Don't adjust number of rows";
X
X    quiet = G_define_flag();
X    quiet->key = 'q';
X    quiet->description = "Run quietly";
X
X    if (G_parser(argc,argv))
X	exit(1);
X
X    cats_used = (unsigned char *)G_calloc (CUR_MAX_CLR,1);	/*dpg*/
X
X    verbose = !quiet->answer;
X    adjust  = !noadjust->answer;
X
X    fd1 = open_rasterfile (input->answer, &nrows, &ncols, &depth);
X    window.north = -0.5;
X    window.south = -(nrows+0.5);
X    window.west = 0.5;
X    window.east = ncols + 0.5;
X    window.ns_res = window.ew_res = 1.0;
X    G_set_window (&window);
X
X    fd2 = open_cellfile (output->answer);
X
X    if(rasttocell (fd1, fd2, nrows, ncols, depth) < 0)
X    {
X	perror (input->answer);
X	exit(1);
X    }
X    close (fd1);
X    G_close_cell (fd2);
X
X    G_init_colors (&colors);
X    for (cat = 0; cat < CUR_MAX_CLR; cat++)
X      if (cats_used[cat])
X	G_set_color (cat, (int)red[cat], (int)grn[cat], (int)blu[cat], &colors);
X
X    G_write_colors (output->answer, G_mapset(), &colors);
X    exit(0);
X}
X
Xopen_cellfile (name)
X    char *name;
X{
X    int fd;
X
X    fd = G_open_cell_new (name);
X    if (fd < 0) exit(1);
X    return fd;
X}
X
Xopen_rasterfile(name, nrows, ncols, depth)
X    char *name;
X    int *nrows, *ncols, *depth;
X{
X    int fd;
X
X    fd = open (name, 0);
X    if (fd < 0)
X    {
X	perror (name);
X	exit(1);
X    }
X
X    switch (read_header(fd, nrows, ncols, depth))
X    {
X    case -1:
X	fprintf (stderr, "%s - not a sun rasterfile\n", name);
X	exit(1);
X    case 0:
X	fprintf (stderr, "%s - this rasterfile format not supported\n", name);
X	exit(1);
X    default:
X	return fd;
X    }
X}
X
X
Xint					/* read an integer from the file and */
Xread_integer (fd, i, size)		/* arrange the bytes in the correct  */
X    int fd, *i, size;			/* order -- sunrast uses big-endian  */
X{
X    unsigned int temp;
X    int retcode;
X    unsigned char *p;
X
X    if (size != sizeof(int)) {
X	fprintf(stderr,
X		"read_integer: warning: possible bogus read for size %d\n",
X		size);
X    }
X
X    *i = 0;
X    p = (unsigned char *) &temp;
X
X    if ( (retcode = read(fd, &temp, sizeof(temp))) == sizeof(temp) ) {
X		/* WARNING: We're assuming an int is four bytes wide! */
X	*i = (p[0] <<24) + (p[1] <<16) + (p[2] <<8) + p[3];
X
X#ifdef DEBUG
X	fprintf(stderr,"read_int: read: %x|%x|%x|%x, converted to %x\n",
X		p[0],p[1],p[2],p[3], *i);
X#endif /* DEBUG */
X    }
X
X    return retcode;
X}
X
X
Xread_header (fd, nrows, ncols, depth)
X    int *nrows, *ncols, *depth;
X{
X    int x;
X    int colormap;
X
X    if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X    if (x != RAS_MAGIC) return -1;
X
X    if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X    *ncols = x;
X    if (*ncols <= 0) return -1;
X    if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X    *nrows = x;
X    if (*nrows <= 0) return -1;
X
X    if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X    *depth = x;
X    if (*depth != 8 && *depth != 1) return 0;	/* can't do this format */
X
X    if (read_integer(fd, &x, sizeof x) != sizeof x) return -1; /* length - don't need */
X    if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X    if (x != RT_STANDARD) return 0; /* can't do this format */
X
X    if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X    colormap = x;
X    if (*depth == 8 && colormap != RMT_EQUAL_RGB) return 0; /* can't do this format */
X    if (*depth == 1)
X    {
X	red[0] = grn[0] = blu[0] = 255;
X	red[1] = grn[1] = blu[1] = 0;
X    }
X
X    if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X    if (colormap)
X    {
X	if (x%3) return 0;
X	x /= 3;
X	if (x > CUR_MAX_CLR) return 0;
X
X	if (read(fd, red, x) != x) return -1;
X	if (read(fd, grn, x) != x) return -1;
X	if (read(fd, blu, x) != x) return -1;
X    }
X
X    if (verbose)
X	fprintf (stderr, "rasterfile is %d rows by %d columns\n", *nrows, *ncols);
X    return 1;
X}
X
Xrasttocell (rast_fd, cell_fd, nrows, ncols, depth)
X{
X    unsigned char *raster;
X    CELL *cell;
X    int row, col, inputcols;
X
X/* sun raster is padded to even number of cols */
X    if (depth == 8)
X	inputcols = ncols + (adjust?ncols%2:0);
X    else
X	inputcols = (ncols+7)/8;
X
X    cell = G_allocate_cell_buf();
X    raster = (unsigned char *) G_malloc(inputcols);
X
X    if (verbose)
X	fprintf (stderr, "complete ... ");
X    for (row = 0; row < nrows; row++)
X    {
X	if (verbose)
X	    G_percent (row, nrows, 2);
X	if (read (rast_fd, raster, inputcols) != inputcols)
X	    return -1;
X
X	for (col = 0; col < ncols; col++)
X	{
X	    register unsigned char tmp;
X
X	    if (depth == 8)
X		tmp =  raster[col];
X	    else
X		tmp =  (raster[col>>3] & (0200 >> (col & 7))) != 0 ;
X	    cats_used[tmp] = 1;		/* mark cat as existing */
X	    cell[col] = (CELL) tmp;
X	}
X
X	if (G_put_map_row (cell_fd, cell) < 0)
X	    exit(1);
X    }
X    if (verbose)
X	G_percent (row, nrows, 2);
X    return 1;
X}
SHAR_EOF
chmod 0664 main.c || echo "restore of main.c fails"
if [ $TOUCH = can ]
then
    touch -am 1005161992 main.c
fi
# ============= diff.921005 ==============
echo "x - extracting diff.921005 (Text)"
sed 's/^X//' << 'SHAR_EOF' > diff.921005 &&
X*** main.c.orig	Mon Oct  5 14:50:48 1992
X--- main.c	Mon Oct  5 16:19:00 1992
X***************
X*** 116,121 ****
X--- 116,152 ----
X  }
X  
X  
X+ int					/* read an integer from the file and */
X+ read_integer (fd, i, size)		/* arrange the bytes in the correct  */
X+     int fd, *i, size;			/* order -- sunrast uses big-endian  */
X+ {
X+     unsigned int temp;
X+     int retcode;
X+     unsigned char *p;
X+ 
X+     if (size != sizeof(int)) {
X+ 	fprintf(stderr,
X+ 		"read_integer: warning: possible bogus read for size %d\n",
X+ 		size);
X+     }
X+ 
X+     *i = 0;
X+     p = (unsigned char *) &temp;
X+ 
X+     if ( (retcode = read(fd, &temp, sizeof(temp))) == sizeof(temp) ) {
X+ 		/* WARNING: We're assuming an int is four bytes wide! */
X+ 	*i = (p[0] <<24) + (p[1] <<16) + (p[2] <<8) + p[3];
X+ 
X+ #ifdef DEBUG
X+ 	fprintf(stderr,"read_int: read: %x|%x|%x|%x, converted to %x\n",
X+ 		p[0],p[1],p[2],p[3], *i);
X+ #endif /* DEBUG */
X+     }
X+ 
X+     return retcode;
X+ }
X+ 
X+ 
X  read_header (fd, nrows, ncols, depth)
X      int *nrows, *ncols, *depth;
X  {
X***************
X*** 122,146 ****
X      int x;
X      int colormap;
X  
X!     if (read(fd, &x, sizeof x) != sizeof x) return -1;
X      if (x != RAS_MAGIC) return -1;
X  
X!     if (read(fd, &x, sizeof x) != sizeof x) return -1;
X      *ncols = x;
X      if (*ncols <= 0) return -1;
X!     if (read(fd, &x, sizeof x) != sizeof x) return -1;
X      *nrows = x;
X      if (*nrows <= 0) return -1;
X  
X!     if (read(fd, &x, sizeof x) != sizeof x) return -1;
X      *depth = x;
X      if (*depth != 8 && *depth != 1) return 0;	/* can't do this format */
X  
X!     if (read(fd, &x, sizeof x) != sizeof x) return -1; /* length - don't need */
X!     if (read(fd, &x, sizeof x) != sizeof x) return -1;
X      if (x != RT_STANDARD) return 0; /* can't do this format */
X  
X!     if (read(fd, &x, sizeof x) != sizeof x) return -1;
X      colormap = x;
X      if (*depth == 8 && colormap != RMT_EQUAL_RGB) return 0; /* can't do this format */
X      if (*depth == 1)
X--- 153,177 ----
X      int x;
X      int colormap;
X  
X!     if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X      if (x != RAS_MAGIC) return -1;
X  
X!     if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X      *ncols = x;
X      if (*ncols <= 0) return -1;
X!     if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X      *nrows = x;
X      if (*nrows <= 0) return -1;
X  
X!     if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X      *depth = x;
X      if (*depth != 8 && *depth != 1) return 0;	/* can't do this format */
X  
X!     if (read_integer(fd, &x, sizeof x) != sizeof x) return -1; /* length - don't need */
X!     if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X      if (x != RT_STANDARD) return 0; /* can't do this format */
X  
X!     if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X      colormap = x;
X      if (*depth == 8 && colormap != RMT_EQUAL_RGB) return 0; /* can't do this format */
X      if (*depth == 1)
X***************
X*** 149,155 ****
X  	red[1] = grn[1] = blu[1] = 0;
X      }
X  
X!     if (read(fd, &x, sizeof x) != sizeof x) return -1;
X      if (colormap)
X      {
X  	if (x%3) return 0;
X--- 180,186 ----
X  	red[1] = grn[1] = blu[1] = 0;
X      }
X  
X!     if (read_integer(fd, &x, sizeof x) != sizeof x) return -1;
X      if (colormap)
X      {
X  	if (x%3) return 0;
SHAR_EOF
chmod 0664 diff.921005 || echo "restore of diff.921005 fails"
if [ $TOUCH = can ]
then
    touch -am 1005175192 diff.921005
fi
exit 0
