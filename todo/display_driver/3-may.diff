? display.new
? 3-may.diff
? CMD/head/head
? CMD/next_step/i586-linux-elf
? display/D_translate_color.txt
? display/d.layers
? display/d.3d/OBJ.i586-linux-elf
? display/d.area/OBJ.i586-linux-elf
? display/d.ask/OBJ.i586-linux-elf
? display/d.barscale/OBJ.i586-linux-elf
? display/d.barscale/cmd/OBJ.i586-linux-elf
? display/d.colormode/OBJ.i586-linux-elf
? display/d.colormode/cmd/OBJ.i586-linux-elf
? display/d.colors/OBJ.i586-linux-elf
? display/d.colortable/OBJ.i586-linux-elf
? display/d.colortable/cmd/OBJ.i586-linux-elf
? display/d.display/OBJ.i586-linux-elf
? display/d.erase/OBJ.i586-linux-elf
? display/d.font/OBJ.i586-linux-elf
? display/d.font/cmd/OBJ.i586-linux-elf
? display/d.frame/OBJ.i586-linux-elf
? display/d.frame/cmd/OBJ.i586-linux-elf
? display/d.geodesic/OBJ.i586-linux-elf
? display/d.geodesic/cmd/OBJ.i586-linux-elf
? display/d.graph/OBJ.i586-linux-elf
? display/d.graph/cmd/OBJ.i586-linux-elf
? display/d.grid/OBJ.i586-linux-elf
? display/d.grid/cmd/OBJ.i586-linux-elf
? display/d.his/OBJ.i586-linux-elf
? display/d.his/cmd/OBJ.i586-linux-elf
? display/d.histogram/OBJ.i586-linux-elf
? display/d.histogram/cmd/OBJ.i586-linux-elf
? display/d.icons/OBJ.i586-linux-elf
? display/d.icons/cmd/OBJ.i586-linux-elf
? display/d.label/OBJ.i586-linux-elf
? display/d.label/cmd/OBJ.i586-linux-elf
? display/d.labels/OBJ.i586-linux-elf
? display/d.leg.thin/OBJ.i586-linux-elf
? display/d.legend/OBJ.i586-linux-elf
? display/d.legend/cmd/OBJ.i586-linux-elf
? display/d.mapgraph/OBJ.i586-linux-elf
? display/d.mapgraph/cmd/OBJ.i586-linux-elf
? display/d.measure/OBJ.i586-linux-elf
? display/d.measure/cmd/OBJ.i586-linux-elf
? display/d.measure/inter/OBJ.i586-linux-elf
? display/d.menu/OBJ.i586-linux-elf
? display/d.menu/cmd/OBJ.i586-linux-elf
? display/d.mon/OBJ.i586-linux-elf
? display/d.mon/cmd/OBJ.i586-linux-elf
? display/d.mon/inter/OBJ.i586-linux-elf
? display/d.mon/pgms/OBJ.i586-linux-elf
? display/d.p.labels/OBJ.i586-linux-elf
? display/d.p.labels/cmd/OBJ.i586-linux-elf
? display/d.pan/OBJ.i586-linux-elf
? display/d.param.scale/OBJ.i586-linux-elf
? display/d.points/OBJ.i586-linux-elf
? display/d.points/cmd/OBJ.i586-linux-elf
? display/d.profile/OBJ.i586-linux-elf
? display/d.rast/OBJ.i586-linux-elf
? display/d.rast/cmd/OBJ.i586-linux-elf
? display/d.rast.arrow/OBJ.i586-linux-elf
? display/d.rast.edit/OBJ.i586-linux-elf
? display/d.rast.num/OBJ.i586-linux-elf
? display/d.rast.zoom/OBJ.i586-linux-elf
? display/d.rgb/OBJ.i586-linux-elf
? display/d.rgb/cmd/OBJ.i586-linux-elf
? display/d.rhumbline/OBJ.i586-linux-elf
? display/d.rhumbline/cmd/OBJ.i586-linux-elf
? display/d.save/OBJ.i586-linux-elf
? display/d.scale/OBJ.i586-linux-elf
? display/d.scale/cmd/OBJ.i586-linux-elf
? display/d.siter/OBJ.i586-linux-elf
? display/d.sites/OBJ.i586-linux-elf
? display/d.sites/cmd/OBJ.i586-linux-elf
? display/d.sites.qual/OBJ.i586-linux-elf
? display/d.sites.qual/cmd/OBJ.i586-linux-elf
? display/d.text/OBJ.i586-linux-elf
? display/d.text/cmd/OBJ.i586-linux-elf
? display/d.title/OBJ.i586-linux-elf
? display/d.title/cmd/OBJ.i586-linux-elf
? display/d.vect/OBJ.i586-linux-elf
? display/d.vect/cmd/OBJ.i586-linux-elf
? display/d.vect.cats/OBJ.i586-linux-elf
? display/d.vect.zoom/OBJ.i586-linux-elf
? display/d.vect.zoom/cmd/OBJ.i586-linux-elf
? display/d.what.rast/OBJ.i586-linux-elf
? display/d.what.rast/cmd/OBJ.i586-linux-elf
? display/d.what.sites/OBJ.i586-linux-elf
? display/d.what.vect/OBJ.i586-linux-elf
? display/d.what.vect/cmd/OBJ.i586-linux-elf
? display/d.where/OBJ.i586-linux-elf
? display/d.where/cmd/OBJ.i586-linux-elf
? display/d.zoom/OBJ.i586-linux-elf
? display/d.zoom/cmd/OBJ.i586-linux-elf
? display/devices/XDRIVER2
? display/devices/CELL/OBJ.i586-linux-elf
? display/devices/HTMLMAP/OBJ.i586-linux-elf
? display/devices/XDRIVER/OBJ.i586-linux-elf
? display/devices/XDRIVER/XDRIVER24/OBJ.i586-linux-elf
? display/devices/XDRIVER/XDRIVER24/Raster.orig.c
? display/devices/XDRIVER/lib/old
? display/devices/XDRIVER/lib/OBJ.i586-linux-elf
? display/devices/XDRIVER/lib/LIB.i586-linux-elf
? display/devices/lib/OBJ.i586-linux-elf
? display/devices/lib/LIB.i586-linux-elf
? display/devices/monitorcap/OBJ.i586-linux-elf
? fonts/for_grass/OBJ.i586-linux-elf
? front.end/OBJ.i586-linux-elf
? general/g.access/OBJ.i586-linux-elf
? general/g.access/inter/OBJ.i586-linux-elf
? general/g.ask/OBJ.i586-linux-elf
? general/g.ask/cmd/OBJ.i586-linux-elf
? general/g.filename/OBJ.i586-linux-elf
? general/g.filename/cmd/OBJ.i586-linux-elf
? general/g.findfile/OBJ.i586-linux-elf
? general/g.findfile/cmd/OBJ.i586-linux-elf
? general/g.gisenv/OBJ.i586-linux-elf
? general/g.help/OBJ.i586-linux-elf
? general/g.manual/OBJ.i586-linux-elf
? general/g.manual/cmd/OBJ.i586-linux-elf
? general/g.manual/inter/OBJ.i586-linux-elf
? general/g.mapsets/OBJ.i586-linux-elf
? general/g.region/OBJ.i586-linux-elf
? general/g.region/cmd/OBJ.i586-linux-elf
? general/g.region/inter/OBJ.i586-linux-elf
? general/g.setproj/OBJ.i586-linux-elf
? general/g.tempfile/OBJ.i586-linux-elf
? general/g.version/OBJ.i586-linux-elf
? general/manage/OBJ.i586-linux-elf
? general/manage/LIB.i586-linux-elf
? imagery/i.rectify--
? imagery/i.rectify++
? imagery/i.rectify2++
? imagery/i.ask/OBJ.i586-linux-elf
? imagery/i.cca/OBJ.i586-linux-elf
? imagery/i.cca/cmd/OBJ.i586-linux-elf
? imagery/i.class/OBJ.i586-linux-elf
? imagery/i.cluster/OBJ.i586-linux-elf
? imagery/i.cluster/cmd/OBJ.i586-linux-elf
? imagery/i.cluster/inter/OBJ.i586-linux-elf
? imagery/i.colors/OBJ.i586-linux-elf
? imagery/i.composite/OBJ.i586-linux-elf
? imagery/i.fft/OBJ.i586-linux-elf
? imagery/i.fft/cmd/OBJ.i586-linux-elf
? imagery/i.find/OBJ.i586-linux-elf
? imagery/i.gensig/OBJ.i586-linux-elf
? imagery/i.gensig/cmd/OBJ.i586-linux-elf
? imagery/i.gensig/inter/OBJ.i586-linux-elf
? imagery/i.gensigset/OBJ.i586-linux-elf
? imagery/i.gensigset/cmd/OBJ.i586-linux-elf
? imagery/i.gensigset/inter/OBJ.i586-linux-elf
? imagery/i.grey.scale/OBJ.i586-linux-elf
? imagery/i.group/OBJ.i586-linux-elf
? imagery/i.group/colors/OBJ.i586-linux-elf
? imagery/i.group/editgroup/OBJ.i586-linux-elf
? imagery/i.group/menu/OBJ.i586-linux-elf
? imagery/i.group/subgroup/OBJ.i586-linux-elf
? imagery/i.group/title/OBJ.i586-linux-elf
? imagery/i.in.erdas/OBJ.i586-linux-elf
? imagery/i.in.gtc/OBJ.i586-linux-elf
? imagery/i.in.pri/OBJ.i586-linux-elf
? imagery/i.maxlik/OBJ.i586-linux-elf
? imagery/i.maxlik/cmd/OBJ.i586-linux-elf
? imagery/i.maxlik/inter/OBJ.i586-linux-elf
? imagery/i.ortho.photo/OBJ.i586-linux-elf
? imagery/i.ortho.photo/libes/OBJ.i586-linux-elf
? imagery/i.ortho.photo/libes/LIB.i586-linux-elf
? imagery/i.ortho.photo/menu/OBJ.i586-linux-elf
? imagery/i.ortho.photo/photo.2image/OBJ.i586-linux-elf
? imagery/i.ortho.photo/photo.2target/OBJ.i586-linux-elf
? imagery/i.ortho.photo/photo.camera/OBJ.i586-linux-elf
? imagery/i.ortho.photo/photo.elev/OBJ.i586-linux-elf
? imagery/i.ortho.photo/photo.init/OBJ.i586-linux-elf
? imagery/i.ortho.photo/photo.rectify/OBJ.i586-linux-elf
? imagery/i.ortho.photo/photo.target/OBJ.i586-linux-elf
? imagery/i.out.erdas/OBJ.i586-linux-elf
? imagery/i.out.erdas/cmd/OBJ.i586-linux-elf
? imagery/i.pca/OBJ.i586-linux-elf
? imagery/i.pca/cmd/OBJ.i586-linux-elf
? imagery/i.points/OBJ.i586-linux-elf
? imagery/i.quantize/OBJ.i586-linux-elf
? imagery/i.rectify/i.rectify.diff
? imagery/i.rectify/OBJ.i586-linux-elf
? imagery/i.rectify/xxxx
? imagery/i.rectify/test
? imagery/i.rectify/i.rectify.patch
? imagery/i.rectify2/OBJ.i586-linux-elf
? imagery/i.rectify2/i.rectify2.patch
? imagery/i.rectify2/i.rectify2.diff
? imagery/i.rgb.his/OBJ.i586-linux-elf
? imagery/i.rgb.his/cmd/OBJ.i586-linux-elf
? imagery/i.smap/OBJ.i586-linux-elf
? imagery/i.smap/cmd/OBJ.i586-linux-elf
? imagery/i.smap/cmd/bouman/OBJ.i586-linux-elf
? imagery/i.smap/cmd/bouman/LIB.i586-linux-elf
? imagery/i.smap/cmd/shapiro/OBJ.i586-linux-elf
? imagery/i.smap/inter/OBJ.i586-linux-elf
? imagery/i.tape.mss/OBJ.i586-linux-elf
? imagery/i.tape.mss.h/OBJ.i586-linux-elf
? imagery/i.tape.other/OBJ.i586-linux-elf
? imagery/i.tape.slc/OBJ.i586-linux-elf
? imagery/i.tape.spot/OBJ.i586-linux-elf
? imagery/i.tape.tm/OBJ.i586-linux-elf
? imagery/i.tape.tm.fast/OBJ.i586-linux-elf
? imagery/i.tape.tm.fast/cmd/OBJ.i586-linux-elf
? imagery/i.tape.tm.fast/inter/OBJ.i586-linux-elf
? imagery/i.target/OBJ.i586-linux-elf
? imagery/i.vpoints/OBJ.i586-linux-elf
? imagery/i.zc/OBJ.i586-linux-elf
? imagery/i.zc/cmd/OBJ.i586-linux-elf
? libes/LIB.i586-linux-elf
? libes/SAVE
? libes/D/OBJ.i586-linux-elf
? libes/bitmap/OBJ.i586-linux-elf
? libes/btree/OBJ.i586-linux-elf
? libes/coorcnv/OBJ.i586-linux-elf
? libes/datetime/OBJ.i586-linux-elf
? libes/dig_atts/OBJ.i586-linux-elf
? libes/display/OBJ.i586-linux-elf
? libes/dlg/OBJ.i586-linux-elf
? libes/dspf/OBJ.i586-linux-elf
? libes/dspf/LIB.i586-linux-elf
? libes/g3d/OBJ.i586-linux-elf
? libes/geom/OBJ.i586-linux-elf
? libes/geom/basic/OBJ.i586-linux-elf
? libes/geom/lia/OBJ.i586-linux-elf
? libes/geom/optri/OBJ.i586-linux-elf
? libes/geom/sos/OBJ.i586-linux-elf
? libes/gis/OBJ.i586-linux-elf
? libes/gis/status
? libes/gis/ststus
? libes/ibtree/OBJ.i586-linux-elf
? libes/icon/OBJ.i586-linux-elf
? libes/image3/OBJ.i586-linux-elf
? libes/image3/LIB.i586-linux-elf
? libes/imagery/OBJ.i586-linux-elf
? libes/libimage/LIB.i586-linux-elf
? libes/linkm/OBJ.i586-linux-elf
? libes/lock/OBJ.i586-linux-elf
? libes/ogsf/LIB.i586-linux-elf
? libes/proj/OBJ.i586-linux-elf
? libes/raster/OBJ.i586-linux-elf
? libes/rowio/OBJ.i586-linux-elf
? libes/rst_gmsl/OBJ.i586-linux-elf
? libes/rst_gmsl/data/OBJ.i586-linux-elf
? libes/rst_gmsl/data/LIB.i586-linux-elf
? libes/rst_gmsl/interp_float/OBJ.i586-linux-elf
? libes/rst_gmsl/interp_float/LIB.i586-linux-elf
? libes/rst_gmsl/tree/OBJ.i586-linux-elf
? libes/rst_gmsl/tree/LIB.i586-linux-elf
? libes/segment/OBJ.i586-linux-elf
? libes/segment/segment.patch
? libes/vask/OBJ.i586-linux-elf
? libes/vect32/Vlib/OBJ.i586-linux-elf
? libes/vect32/diglib/OBJ.i586-linux-elf
? libes/vect32/georef/OBJ.i586-linux-elf
? libes/vect32/georef/LIB.i586-linux-elf
? libes/vect32/libes/OBJ.i586-linux-elf
? libes/vect32/libes/LIB.i586-linux-elf
? libes/vect32/libes/transform/OBJ.i586-linux-elf
? mapdev/v.alabel/OBJ.i586-linux-elf
? mapdev/v.apply.census/OBJ.i586-linux-elf
? mapdev/v.area/OBJ.i586-linux-elf
? mapdev/v.autocorr/OBJ.i586-linux-elf
? mapdev/v.build/OBJ.i586-linux-elf
? mapdev/v.build/LIB.i586-linux-elf
? mapdev/v.build.polylines/OBJ.i586-linux-elf
? mapdev/v.build.polylines/cmd/OBJ.i586-linux-elf
? mapdev/v.cadlabel/OBJ.i586-linux-elf
? mapdev/v.clean/OBJ.i586-linux-elf
? mapdev/v.cutter/OBJ.i586-linux-elf
? mapdev/v.digit/OBJ.i586-linux-elf
? mapdev/v.distance/OBJ.i586-linux-elf
? mapdev/v.export/OBJ.i586-linux-elf
? mapdev/v.extract/OBJ.i586-linux-elf
? mapdev/v.extract/cmd/OBJ.i586-linux-elf
? mapdev/v.extract/inter/OBJ.i586-linux-elf
? mapdev/v.from.3/OBJ.i586-linux-elf
? mapdev/v.geom/OBJ.i586-linux-elf
? mapdev/v.geom/cmd/OBJ.i586-linux-elf
? mapdev/v.import/OBJ.i586-linux-elf
? mapdev/v.in.arc/OBJ.i586-linux-elf
? mapdev/v.in.ascii/OBJ.i586-linux-elf
? mapdev/v.in.dlg/OBJ.i586-linux-elf
? mapdev/v.in.dxf/OBJ.i586-linux-elf
? mapdev/v.in.dxf2/OBJ.i586-linux-elf
? mapdev/v.in.dxf3d/OBJ.i586-linux-elf
? mapdev/v.in.shape/OBJ.i586-linux-elf
? mapdev/v.in.tig.basic/OBJ.i586-linux-elf
? mapdev/v.in.tig.lndmk/OBJ.i586-linux-elf
? mapdev/v.in.transects/OBJ.i586-linux-elf
? mapdev/v.info/OBJ.i586-linux-elf
? mapdev/v.merge/OBJ.i586-linux-elf
? mapdev/v.mkgrid/OBJ.i586-linux-elf
? mapdev/v.mkquads/OBJ.i586-linux-elf
? mapdev/v.out.arc/OBJ.i586-linux-elf
? mapdev/v.out.dlg/OBJ.i586-linux-elf
? mapdev/v.out.dxf/OBJ.i586-linux-elf
? mapdev/v.out.idrisi/OBJ.i586-linux-elf
? mapdev/v.out.moss/OBJ.i586-linux-elf
? mapdev/v.out.shape/OBJ.i586-linux-elf
? mapdev/v.out.shape/gen2shp-0.2.3/OBJ.i586-linux-elf
? mapdev/v.out.shape/shapelib-1.2.7/OBJ.i586-linux-elf
? mapdev/v.patch/OBJ.i586-linux-elf
? mapdev/v.proj/OBJ.i586-linux-elf
? mapdev/v.prune/OBJ.i586-linux-elf
? mapdev/v.random/OBJ.i586-linux-elf
? mapdev/v.reclass/OBJ.i586-linux-elf
? mapdev/v.reclass/cmd/OBJ.i586-linux-elf
? mapdev/v.reclass/inter/OBJ.i586-linux-elf
? mapdev/v.spag/OBJ.i586-linux-elf
? mapdev/v.stats/OBJ.i586-linux-elf
? mapdev/v.support/OBJ.i586-linux-elf
? mapdev/v.surf.rst/OBJ.i586-linux-elf
? mapdev/v.to.rast/OBJ.i586-linux-elf
? mapdev/v.to.sites/OBJ.i586-linux-elf
? mapdev/v.transform/OBJ.i586-linux-elf
? mapdev/v.trim/OBJ.i586-linux-elf
? mapdev/v.what/OBJ.i586-linux-elf
? mapdev/v.what/cmd/OBJ.i586-linux-elf
? misc/m.dem.examine/OBJ.i586-linux-elf
? misc/m.dem.extract/OBJ.i586-linux-elf
? misc/m.dmaUSGSread/OBJ.i586-linux-elf
? misc/m.dted.examine/OBJ.i586-linux-elf
? misc/m.dted.extract/OBJ.i586-linux-elf
? misc/m.examine.tape/OBJ.i586-linux-elf
? misc/m.flip/OBJ.i586-linux-elf
? misc/m.gc2ll/OBJ.i586-linux-elf
? misc/m.gc2ll/cmd/OBJ.i586-linux-elf
? misc/m.in.e00/OBJ.i586-linux-elf
? misc/m.in.pl94.db3/OBJ.i586-linux-elf
? misc/m.in.stf1.db3/OBJ.i586-linux-elf
? misc/m.in.stf1.tape/OBJ.i586-linux-elf
? misc/m.ll2gc/OBJ.i586-linux-elf
? misc/m.ll2gc/cmd/OBJ.i586-linux-elf
? misc/m.ll2u/OBJ.i586-linux-elf
? misc/m.ll2u/cmd/OBJ.i586-linux-elf
? misc/m.lulc.USGS/OBJ.i586-linux-elf
? misc/m.lulc.read/OBJ.i586-linux-elf
? misc/m.proj/OBJ.i586-linux-elf
? misc/m.region.ll/OBJ.i586-linux-elf
? misc/m.rot90/OBJ.i586-linux-elf
? misc/m.rot90/cmd/OBJ.i586-linux-elf
? misc/m.tiger.region/OBJ.i586-linux-elf
? misc/m.u2ll/OBJ.i586-linux-elf
? misc/m.u2ll/cmd/OBJ.i586-linux-elf
? paint/Drivers/OBJ.i586-linux-elf
? paint/Drivers/ppm/OBJ.i586-linux-elf
? paint/Drivers/preview/OBJ.i586-linux-elf
? paint/Drivers/preview2/OBJ.i586-linux-elf
? paint/Interface/OBJ.i586-linux-elf
? paint/Interface/applib/OBJ.i586-linux-elf
? paint/Interface/applib/LIB.i586-linux-elf
? paint/Interface/driverlib/OBJ.i586-linux-elf
? paint/Interface/driverlib/LIB.i586-linux-elf
? paint/Interface/shell/OBJ.i586-linux-elf
? paint/Programs/OBJ.i586-linux-elf
? paint/Programs/p.chart/OBJ.i586-linux-elf
? paint/Programs/p.colors/OBJ.i586-linux-elf
? paint/Programs/p.icons/OBJ.i586-linux-elf
? paint/Programs/p.labels/OBJ.i586-linux-elf
? paint/Programs/p.map/OBJ.i586-linux-elf
? paint/Programs/p.map/cmd/OBJ.i586-linux-elf
? paint/Programs/p.map/inter/OBJ.i586-linux-elf
? paint/Programs/p.map.new/cmd/OBJ.i586-linux-elf
? paint/Programs/p.ppm/OBJ.i586-linux-elf
? paint/Programs/p.select/OBJ.i586-linux-elf
? paint/Programs/p.select/cmd/OBJ.i586-linux-elf
? paint/Programs/p.select/inter/OBJ.i586-linux-elf
? paint/Tests/OBJ.i586-linux-elf
? ps.map/ps.map.new/OBJ.i586-linux-elf
? ps.map/ps.map.new/cmd/OBJ.i586-linux-elf
? ps.map/ps.map.new/devices/OBJ.i586-linux-elf
? ps.map/ps.map.new/inter/OBJ.i586-linux-elf
? ps.map/ps.map.old/OBJ.i586-linux-elf
? ps.map/ps.map.old/devices/OBJ.i586-linux-elf
? ps.map/ps.map.old/ps.icon/OBJ.i586-linux-elf
? ps.map/ps.map.old/ps.map/OBJ.i586-linux-elf
? ps.map/ps.map.old/ps.map/cmd/OBJ.i586-linux-elf
? ps.map/ps.map.old/ps.map/inter/OBJ.i586-linux-elf
? ps.map/ps.map.old/ps.select/OBJ.i586-linux-elf
? ps.map/ps.map.old/scripts/OBJ.i586-linux-elf
? raster/r.cost2
? raster/r.cost#####
? raster/r.cost++
? raster/r.drain##
? raster/r.drain2
? raster/r.agnps50/ststus
? raster/r.average/OBJ.i586-linux-elf
? raster/r.average/cmd/OBJ.i586-linux-elf
? raster/r.average/inter/OBJ.i586-linux-elf
? raster/r.basins.fill/OBJ.i586-linux-elf
? raster/r.bilinear/OBJ.i586-linux-elf
? raster/r.binfer/OBJ.i586-linux-elf
? raster/r.buffer/OBJ.i586-linux-elf
? raster/r.buffer/cmd/OBJ.i586-linux-elf
? raster/r.buffer/inter/OBJ.i586-linux-elf
? raster/r.cats/OBJ.i586-linux-elf
? raster/r.cats/cmd/OBJ.i586-linux-elf
? raster/r.circle/OBJ.i586-linux-elf
? raster/r.clump/OBJ.i586-linux-elf
? raster/r.clump/cmd/OBJ.i586-linux-elf
? raster/r.coin/OBJ.i586-linux-elf
? raster/r.coin/cmd/OBJ.i586-linux-elf
? raster/r.colors/OBJ.i586-linux-elf
? raster/r.colors/cmd/OBJ.i586-linux-elf
? raster/r.colors.paint/OBJ.i586-linux-elf
? raster/r.combine/OBJ.i586-linux-elf
? raster/r.combine/cmd/OBJ.i586-linux-elf
? raster/r.compress/OBJ.i586-linux-elf
? raster/r.compress/cmd/OBJ.i586-linux-elf
? raster/r.compress/inter/OBJ.i586-linux-elf
? raster/r.contour/OBJ.i586-linux-elf
? raster/r.cost/r.cost.patch
? raster/r.cost/OBJ.i586-linux-elf
? raster/r.cost/cmd/OBJ.i586-linux-elf
? raster/r.cost/cmd/main.orig.c
? raster/r.cost/cmd/rcost.diff
? raster/r.cost/cmd/main.new.c
? raster/r.covar/OBJ.i586-linux-elf
? raster/r.covar/cmd/OBJ.i586-linux-elf
? raster/r.cross/OBJ.i586-linux-elf
? raster/r.describe/OBJ.i586-linux-elf
? raster/r.describe/cmd/OBJ.i586-linux-elf
? raster/r.digit/OBJ.i586-linux-elf
? raster/r.drain/OBJ.i586-linux-elf
? raster/r.drain/cmd/main-OK.c
? raster/r.drain/cmd/OBJ.i586-linux-elf
? raster/r.drain/cmd/main2.c
? raster/r.flow/OBJ.i586-linux-elf
? raster/r.flowmd/OBJ.i586-linux-elf
? raster/r.grow/OBJ.i586-linux-elf
? raster/r.grow/cmd/OBJ.i586-linux-elf
? raster/r.grow/inter/OBJ.i586-linux-elf
? raster/r.in.arc/OBJ.i586-linux-elf
? raster/r.in.arc/cmd/OBJ.i586-linux-elf
? raster/r.in.ascii/OBJ.i586-linux-elf
? raster/r.in.ascii/cmd/OBJ.i586-linux-elf
? raster/r.in.bin/OBJ.i586-linux-elf
? raster/r.in.dted/r.in.dted/OBJ.i586-linux-elf
? raster/r.in.ll/OBJ.i586-linux-elf
? raster/r.in.ll/cmd/OBJ.i586-linux-elf
? raster/r.in.png/OBJ.i586-linux-elf
? raster/r.in.poly/OBJ.i586-linux-elf
? raster/r.in.ppm/OBJ.i586-linux-elf
? raster/r.in.sunrast/OBJ.i586-linux-elf
? raster/r.in.sunrast/cmd/OBJ.i586-linux-elf
? raster/r.infer/OBJ.i586-linux-elf
? raster/r.infer/cmd/OBJ.i586-linux-elf
? raster/r.info/OBJ.i586-linux-elf
? raster/r.info/cmd/OBJ.i586-linux-elf
? raster/r.info/inter/OBJ.i586-linux-elf
? raster/r.kappa/OBJ.i586-linux-elf
? raster/r.kappa/cmd/OBJ.i586-linux-elf
? raster/r.line/OBJ.i586-linux-elf
? raster/r.line/cmd/OBJ.i586-linux-elf
? raster/r.los/OBJ.i586-linux-elf
? raster/r.los/cmd/OBJ.i586-linux-elf
? raster/r.mapcalc/OBJ.i586-linux-elf
? raster/r.mapcalc/mapcalc/OBJ.i586-linux-elf
? raster/r.mapcalc/polish/OBJ.i586-linux-elf
? raster/r.mask.points/OBJ.i586-linux-elf
? raster/r.mask.points/cmd/OBJ.i586-linux-elf
? raster/r.median/OBJ.i586-linux-elf
? raster/r.median/cmd/OBJ.i586-linux-elf
? raster/r.median/inter/OBJ.i586-linux-elf
? raster/r.mfilter/OBJ.i586-linux-elf
? raster/r.mfilter/cmd/OBJ.i586-linux-elf
? raster/r.mode/OBJ.i586-linux-elf
? raster/r.mode/cmd/OBJ.i586-linux-elf
? raster/r.mode/inter/OBJ.i586-linux-elf
? raster/r.neighbors/OBJ.i586-linux-elf
? raster/r.neighbors/cmd/OBJ.i586-linux-elf
? raster/r.neighbors/inter/OBJ.i586-linux-elf
? raster/r.null/OBJ.i586-linux-elf
? raster/r.out.arc/OBJ.i586-linux-elf
? raster/r.out.arc/cmd/OBJ.i586-linux-elf
? raster/r.out.ascii/OBJ.i586-linux-elf
? raster/r.out.ascii/cmd/OBJ.i586-linux-elf
? raster/r.out.mpeg/OBJ.i586-linux-elf
? raster/r.out.png/OBJ.i586-linux-elf
? raster/r.out.ppm/OBJ.i586-linux-elf
? raster/r.out.tga/OBJ.i586-linux-elf
? raster/r.out.xyz/OBJ.i586-linux-elf
? raster/r.param.scale/OBJ.i586-linux-elf
? raster/r.patch/OBJ.i586-linux-elf
? raster/r.patch/cmd/OBJ.i586-linux-elf
? raster/r.poly/OBJ.i586-linux-elf
? raster/r.poly/cmd/OBJ.i586-linux-elf
? raster/r.profile/OBJ.i586-linux-elf
? raster/r.profile/cmd/OBJ.i586-linux-elf
? raster/r.proj/OBJ.i586-linux-elf
? raster/r.proj/cmd/OBJ.i586-linux-elf
? raster/r.quant/OBJ.i586-linux-elf
? raster/r.random/OBJ.i586-linux-elf
? raster/r.random/cmd/OBJ.i586-linux-elf
? raster/r.random/inter/OBJ.i586-linux-elf
? raster/r.reclass/OBJ.i586-linux-elf
? raster/r.reclass/cmd/OBJ.i586-linux-elf
? raster/r.reclass/inter/OBJ.i586-linux-elf
? raster/r.recode/OBJ.i586-linux-elf
? raster/r.report/OBJ.i586-linux-elf
? raster/r.report/cmd/OBJ.i586-linux-elf
? raster/r.report/inter/OBJ.i586-linux-elf
? raster/r.resamp.rst/OBJ.i586-linux-elf
? raster/r.resample/OBJ.i586-linux-elf
? raster/r.resample/cmd/OBJ.i586-linux-elf
? raster/r.rescale/OBJ.i586-linux-elf
? raster/r.rescale/cmd/OBJ.i586-linux-elf
? raster/r.rescale/inter/OBJ.i586-linux-elf
? raster/r.rescale.eq/OBJ.i586-linux-elf
? raster/r.rescale.eq/cmd/OBJ.i586-linux-elf
? raster/r.slope.aspect/OBJ.i586-linux-elf
? raster/r.slope.aspect/cmd/OBJ.i586-linux-elf
? raster/r.statistics/OBJ.i586-linux-elf
? raster/r.statistics/cmd/OBJ.i586-linux-elf
? raster/r.stats/OBJ.i586-linux-elf
? raster/r.stats/cmd/OBJ.i586-linux-elf
? raster/r.sum/OBJ.i586-linux-elf
? raster/r.sun/OBJ.i586-linux-elf
? raster/r.support/OBJ.i586-linux-elf
? raster/r.surf.area/OBJ.i586-linux-elf
? raster/r.surf.contour/OBJ.i586-linux-elf
? raster/r.surf.contour/cmd/OBJ.i586-linux-elf
? raster/r.surf.fractal/OBJ.i586-linux-elf
? raster/r.surf.gauss/OBJ.i586-linux-elf
? raster/r.surf.idw/OBJ.i586-linux-elf
? raster/r.surf.idw/cmd/OBJ.i586-linux-elf
? raster/r.surf.idw2/OBJ.i586-linux-elf
? raster/r.surf.idw2/cmd/OBJ.i586-linux-elf
? raster/r.surf.random/OBJ.i586-linux-elf
? raster/r.thin/OBJ.i586-linux-elf
? raster/r.thin/cmd/OBJ.i586-linux-elf
? raster/r.timestamp/OBJ.i586-linux-elf
? raster/r.to.sites/OBJ.i586-linux-elf
? raster/r.transect/OBJ.i586-linux-elf
? raster/r.transect/cmd/OBJ.i586-linux-elf
? raster/r.volume/OBJ.i586-linux-elf
? raster/r.volume/cmd/OBJ.i586-linux-elf
? raster/r.water.outlet/OBJ.i586-linux-elf
? raster/r.watershed/OBJ.i586-linux-elf
? raster/r.watershed/front/OBJ.i586-linux-elf
? raster/r.watershed/ram/OBJ.i586-linux-elf
? raster/r.watershed/seg/OBJ.i586-linux-elf
? raster/r.watershed/shed/OBJ.i586-linux-elf
? raster/r.weight/OBJ.i586-linux-elf
? raster/r.weight/inter/OBJ.i586-linux-elf
? raster/r.weight2/OBJ.i586-linux-elf
? raster/r.weight2/cmd/OBJ.i586-linux-elf
? raster/r.what/OBJ.i586-linux-elf
? raster/r.what/cmd/OBJ.i586-linux-elf
? scripts/OBJ.i586-linux-elf
? scripts/contrib/OBJ.i586-linux-elf
? scripts/contrib/d.rast.leg/OBJ.i586-linux-elf
? scripts/contrib/i.oif/OBJ.i586-linux-elf
? scripts/contrib/i.spectral/OBJ.i586-linux-elf
? scripts/contrib/s.in.grid/OBJ.i586-linux-elf
? sites/cdhc/LIB.i586-linux-elf
? sites/s.in.ascii/OBJ.i586-linux-elf
? sites/s.info/OBJ.i586-linux-elf
? sites/s.kcv/OBJ.i586-linux-elf
? sites/s.normal/OBJ.i586-linux-elf
? sites/s.o2n.tps/OBJ.i586-linux-elf
? sites/s.out.ascii/OBJ.i586-linux-elf
? sites/s.out.e00/OBJ.i586-linux-elf
? sites/s.perturb/OBJ.i586-linux-elf
? sites/s.probplt/OBJ.i586-linux-elf
? sites/s.qcount/OBJ.i586-linux-elf
? sites/s.rand/OBJ.i586-linux-elf
? sites/s.sample/OBJ.i586-linux-elf
? sites/s.surf.idw/OBJ.i586-linux-elf
? sites/s.surf.idw/cmd/OBJ.i586-linux-elf
? sites/s.surf.rst/OBJ.i586-linux-elf
? sites/s.surf.tps/OBJ.i586-linux-elf
? sites/s.sv/OBJ.i586-linux-elf
? sites/s.territory/OBJ.i586-linux-elf
? sites/s.to.rast/OBJ.i586-linux-elf
? sites/s.to.vect/OBJ.i586-linux-elf
? sites/s.to.vect/cmd/OBJ.i586-linux-elf
? sites/s.univar/OBJ.i586-linux-elf
? sites/sroff/OBJ.i586-linux-elf
? tcltkgrass/OBJ.i586-linux-elf
Index: CMD/generic/CREATE_GMAKE.sh
===================================================================
RCS file: /home/grass/grassrepository/grass/src/CMD/generic/CREATE_GMAKE.sh,v
retrieving revision 1.4
diff -u -r1.4 CREATE_GMAKE.sh
--- CMD/generic/CREATE_GMAKE.sh	2000/04/25 07:19:25	1.4
+++ CMD/generic/CREATE_GMAKE.sh	2000/05/03 03:57:19
@@ -11,7 +11,7 @@
 echo "CMD=$SRC/src/CMD"                   >> $UNIX_BIN/gmake5
 echo "HEADER=head"                        >> $UNIX_BIN/gmake5
 echo "HASX=yes"                           >> $UNIX_BIN/gmake5
-echo "HASMotif=no"                        >> $UNIX_BIN/gmake5
+echo "HASMotif=no"                       >> $UNIX_BIN/gmake5
 echo ". $SRC/src/CMD/generic/gmake.sh"    >> $UNIX_BIN/gmake5
 chmod ugo+x $UNIX_BIN/gmake5
 
Index: CMD/lists/GRASS
===================================================================
RCS file: /home/grass/grassrepository/grass/src/CMD/lists/GRASS,v
retrieving revision 1.25
diff -u -r1.25 GRASS
--- CMD/lists/GRASS	2000/04/14 12:11:40	1.25
+++ CMD/lists/GRASS	2000/05/03 03:57:20
@@ -108,8 +108,6 @@
 src/general/g.tempfile
 src/general/g.setproj
 src/general/g.version
-src/general/gis
-src/general/manage
 src/imagery/i.ask
 src/imagery/i.cca
 src/imagery/i.class
@@ -277,7 +275,7 @@
 src/raster/r.out.arc
 src/raster/r.out.ascii
 src/raster/r.out.mpeg
-src/raster/r.out.png
+#src/raster/r.out.png
 src/raster/r.out.ppm
 src/raster/r.out.tga
 src/raster/r.out.xyz
@@ -470,3 +468,4 @@
 #src.contrib/eurogis/r.to.SVF
 #src.garden/grass.hdf/hdf3
 src.garden/answers/src.answers/raster/r.fill.dir
+
Index: CMD/lists/drivers.graphics
===================================================================
RCS file: /home/grass/grassrepository/grass/src/CMD/lists/drivers.graphics,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 drivers.graphics
--- CMD/lists/drivers.graphics	1999/12/29 15:10:04	1.1.1.1
+++ CMD/lists/drivers.graphics	2000/05/03 03:57:20
@@ -1,7 +1,8 @@
 src/display/devices/XDRIVER
-src/display/devices/4105
+src/display/devices/XDRIVER2
+#src/display/devices/4105
 src/display/devices/GENERIC
-src/display/devices/IGRAPH
-src/display/devices/IRIS
-src/display/devices/MASS
-src/display/devices/SUNVIEW
+#src/display/devices/IGRAPH
+#src/display/devices/IRIS
+#src/display/devices/MASS
+#src/display/devices/SUNVIEW
Index: display/d.3d/Dmain.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.3d/Dmain.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 Dmain.c
--- display/d.3d/Dmain.c	1999/12/29 15:10:05	1.1.1.1
+++ display/d.3d/Dmain.c	2000/05/03 03:57:21
@@ -23,6 +23,7 @@
 	struct Option *opt9 ;
 	struct Option *opt10 ;
 	struct Option *opt11 ;
+	struct Option *dev ;
 	struct Flag *flag1 ;
 	struct Flag *flag2 ;
 	struct Flag *flag3 ;
@@ -96,7 +97,7 @@
 
     opt10 = G_define_option() ;
     opt10->key        = "color" ;
-    opt10->type       = TYPE_STRING ;
+    opt10->type       = TYPE_COLOR ;
     opt10->required   = NO ;
     opt10->options    = G_malloc(strlen(D_color_list()) + 6);
     sprintf (opt10->options, "%s,color", D_color_list());
@@ -105,7 +106,7 @@
 
     opt11 = G_define_option() ;
     opt11->key        = "box" ;
-    opt11->type       = TYPE_STRING ;
+    opt11->type       = TYPE_COLOR ;
     opt11->required   = NO ;
     opt11->options    = G_malloc(strlen(D_color_list()) + 6);
     sprintf (opt11->options, "%s,none", D_color_list());
@@ -124,6 +125,12 @@
 	flag3->key         = 'a' ;
 	flag3->description = "Calculate corner elevations by averaging 4 neighbor cells" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	if (G_parser(argc, argv))
 			exit(1);
 
@@ -221,7 +228,7 @@
 		G_fatal_error("Inappropriate window resolution request") ;
 
 /* Set up graphics */
-	R_open_driver();
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current graphics frame") ;
Index: display/d.3d/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.3d/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.3d/main.c	1999/12/29 15:10:05	1.1.1.1
+++ display/d.3d/main.c	2000/05/03 03:57:22
@@ -16,9 +16,24 @@
 	int do_it ;
 	char erase_color[64] ;
 	char *mapset ;
-
+  	struct Option *dev; 
+	
 	G_gisinit(argv[0]) ;
-	R_open_driver();
+
+
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = YES;
+    dev->description = "Graphics device";
+
+	if (argc>1 && G_parser(argc, argv))
+		exit(1);
+
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
+
+//	R_open_driver();
 	G_clear_screen() ;
 
 /* Get name of files for display */
@@ -44,8 +59,9 @@
 	if (D_get_cur_wind(window_name))
 	{
 	    R_close_driver();
-	    system ("d.frame -e");
+	    system ("d.frame -e");	/* Problem ? */
 	    R_open_driver();
+/*  	R_open_driver2(dev->answer); */
 	}
 
 	for(;;)
Index: display/d.area/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.area/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.area/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.area/main.c	2000/05/03 03:57:22
@@ -26,6 +26,7 @@
 	char map_name[128];
 	struct Option *opt1,*opt2, *opt3;
 	struct line_pnts *Points;
+	struct Option  *dev;
 
 	opt1 = G_define_option() ;
 	opt1->key        = "map" ;
@@ -37,16 +38,24 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "fillcolor" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->options    = D_color_list();
 	opt2->description= "Color desired for filling polys" ;
 
 	opt3 = G_define_option() ;
 	opt3->key        = "linecolor" ;
-	opt3->type       = TYPE_STRING ;
+	opt3->type       = TYPE_COLOR ;
 	opt3->answer     = "none" ;
 	opt3->description= "Color desired for drawing map" ;
+	
+
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	G_gisinit(argv[0]);
 
 	/* Check command line */
@@ -67,7 +76,8 @@
 	}
 
 	
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current graphocs window");
Index: display/d.ask/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.ask/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.ask/main.c	1999/12/29 15:10:05	1.1.1.1
+++ display/d.ask/main.c	2000/05/03 03:57:22
@@ -5,11 +5,12 @@
 int main(int argc,char *argv[])
 {
     struct Option *element, *prompt;
+	struct Option  *dev;
     struct Flag *quiet;
     char *tempfile;
     char command[1024];
     FILE *fd;
-
+	char driver[65]="";
     G_gisinit(argv[0]);
 
     element = G_define_option();
@@ -25,6 +26,12 @@
     prompt->type = TYPE_STRING;
     prompt->description = "Short user prompt message";
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 /*
     quiet = G_define_flag();
     quiet->key = 'q';
@@ -36,32 +43,39 @@
 	exit(1);
 
 /* make sure we can do graphics */
-    R_open_driver();
+	R_open_driver2(dev->answer);
+/*      R_open_driver(); */
     R_close_driver();
 
     tempfile = G_tempfile();
     unlink (tempfile);
-    sprintf (command, "%s/etc/i.find %s %s %s %s",
-	G_gisbase(), G_location(), G_mapset(), element->answers[0], tempfile);
+	if (dev->answer)
+			strncpy(driver,64,dev->answer);
+    sprintf (command, "%s/etc/i.find %s %s %s %s %s",
+	G_gisbase(), G_location(), G_mapset(), element->answers[0], tempfile,driver);
     system(command);
 
     if (access(tempfile,0)==0)
     {
 	if (prompt->answer)
 	{
-	    sprintf (command, "%s/etc/i.ask %s '%s'",
-		G_gisbase(), tempfile, prompt->answer);
+	    sprintf (command, "%s/etc/i.ask %s '%s' %s",
+		G_gisbase(), tempfile, prompt->answer, driver);
 	}
 	else
 	{
-	    sprintf (command, "%s/etc/i.ask %s",
-		G_gisbase(), tempfile);
+	    sprintf(command, "%s/etc/i.ask %s %s",
+		G_gisbase(), tempfile, driver);
 	}
 	exit(system(command));
     }
     else
     {
-	fd = popen ("d.menu tcolor=red > /dev/null", "w");
+		if (dev->answer != NULL) {
+			sprintf(command,"d.menu device=%s tcolor=red>/dev/null",dev->answer); 
+			fd = popen (command, "w");
+		} else
+			fd = popen ("d.menu tcolor=red > /dev/null", "w");
 	if (fd)
 	{
 	    fprintf (fd, "** no %s files found **\n", element->answers[1]);
Index: display/d.barscale/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.barscale/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.barscale/cmd/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.barscale/cmd/main.c	2000/05/03 03:57:22
@@ -12,6 +12,7 @@
 	int t, b, l, r ;
 	struct Option *opt1, *opt2, *opt3 ;
 	struct Flag *mouse ;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]);
@@ -33,7 +34,7 @@
 
 	opt1 = G_define_option() ;
 	opt1->key        = "bcolor" ;
-	opt1->type       = TYPE_STRING ;
+	opt1->type       = TYPE_COLOR;
 	opt1->answer     = "black" ;
 	opt1->required   = NO ;
 	opt1->options    = D_color_list();
@@ -41,7 +42,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "tcolor" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR;
 	opt2->answer     = "white" ;
 	opt2->required   = NO ;
 	opt2->options    = D_color_list();
@@ -56,6 +57,12 @@
 	opt3->required   = NO;
 	opt3->description= "the screen coordinates for top-left corner of label" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	coord_inp = 0;
 
 	if (G_parser(argc, argv) < 0)
@@ -75,7 +82,8 @@
 	sscanf(opt3->answers[1],"%lf",&north) ;
 	if((east>0)||(north>0)) coord_inp=1;
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current window") ;
Index: display/d.colormode/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.colormode/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.colormode/cmd/main.c	1999/12/29 15:10:05	1.1.1.1
+++ display/d.colormode/cmd/main.c	2000/05/03 03:57:23
@@ -19,6 +19,7 @@
 char **argv)
 {
 	struct Option *option;
+	struct Option  *dev;
 	int mode, stat ;
 
 	option = G_define_option() ;
@@ -29,7 +30,13 @@
 	option->options    ="fixed,float";
 
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
 
+
 	/* Parse command line */
 	if (G_parser(argc, argv))
 		exit(-1);
@@ -44,7 +51,8 @@
 		exit(-1) ;
 	}
 
-	R_open_driver();
+	R_open_driver2(dev->answer);
+/*  	R_open_driver(); */
 
 	stat = 1;
 	switch (mode)
Index: display/d.colortable/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.colortable/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.colortable/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.colortable/cmd/main.c	2000/05/03 03:57:23
@@ -40,6 +40,7 @@
 	int x_box[5] ;
 	int y_box[5] ;
 	struct Option *opt1, *opt2, *opt3, *opt4 ;
+	struct Option  *dev;
 
 	opt1 = G_define_option() ;
 	opt1->key        = "map" ;
@@ -50,7 +51,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "color" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->options=D_color_list();
 	opt2->description= "Color of lines separating the colors of the color table";
@@ -67,6 +68,13 @@
 	opt4->options    = "1-1000" ;
 	opt4->description= "Number of columns" ;
 
+
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
 
@@ -133,7 +141,8 @@
 		G_fatal_error(buff) ;
 		exit(-1);
 	}
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current frame") ;
Index: display/d.display/cell3d.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/cell3d.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 cell3d.c
--- display/d.display/cell3d.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/cell3d.c	2000/05/03 03:57:23
@@ -5,7 +5,7 @@
 
 int cell3d()
 {
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(MAP.name) ;
 	R_close_driver();
 
Index: display/d.display/digitize.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/digitize.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 digitize.c
--- display/d.display/digitize.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/digitize.c	2000/05/03 03:57:23
@@ -5,7 +5,7 @@
 
 int digitize()
 {
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(MAP.name) ;
 	R_close_driver();
 
Index: display/d.display/do_exit.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/do_exit.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 do_exit.c
--- display/d.display/do_exit.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/do_exit.c	2000/05/03 03:57:23
@@ -22,7 +22,7 @@
 	div_color        = D_translate_color(DC_EXIT) ;
 
 	tell_em_to_use_mouse() ;
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	answer = D_popup(
 		background_color,
 		text_color,
Index: display/d.display/histo.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/histo.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 histo.c
--- display/d.display/histo.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/histo.c	2000/05/03 03:57:24
@@ -17,6 +17,7 @@
 	int rng_cat ;
 	int cat ;
 	int val ;
+	char command[128];
 
 	if (*mapname == '\0')
 	{
@@ -25,7 +26,7 @@
 		return -1;
 	}
 
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(LO3.name) ;
 	Derase("black") ;
 	R_close_driver();
@@ -53,8 +54,9 @@
 		return(-1) ;
 
 /* Read through temp file plotting the histogram */
-	if (NULL != (fptr = popen("d.graph", "w")))
-	{
+	snprintf(command,127,"d.graph device=%s ",getenv("PRIVATE_DDISPLAY_DEVICE"));
+	if (NULL != (fptr = popen(command, "w")))
+	{	
 		fprintf(fptr, "color white\n") ;
 		fprintf(fptr, "move  5 10\n") ;
 		fprintf(fptr, "draw  5 90\n") ;
Index: display/d.display/label.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/label.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 label.c
--- display/d.display/label.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/label.c	2000/05/03 03:57:24
@@ -5,10 +5,9 @@
 
 int label()
 {
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(MAP.name) ;
 	R_close_driver();
-
 	gorun("d.label", "") ;
 
 	return 0;
Index: display/d.display/legend.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/legend.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 legend.c
--- display/d.display/legend.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/legend.c	2000/05/03 03:57:24
@@ -64,7 +64,7 @@
         }
 	for(;;)
 	{
-		R_open_driver();
+		R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 		tell_em_to_use_mouse() ;
 		answer = D_popup(
 			background_color,
@@ -81,7 +81,7 @@
 		switch(answer)
 		{
 		case 1: case 2:
-			R_open_driver();
+			R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 			Dchoose(LEG.name) ;
 			Derase("black") ;
 			R_close_driver();
Index: display/d.display/menu_disp.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/menu_disp.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 menu_disp.c
--- display/d.display/menu_disp.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/menu_disp.c	2000/05/03 03:57:24
@@ -33,7 +33,7 @@
 
 	for(;;)
 	{
-		R_open_driver();
+		R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 		tell_em_to_use_mouse() ;
 		answer = D_popup(
 			background_color,
Index: display/d.display/menu_info.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/menu_info.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 menu_info.c
--- display/d.display/menu_info.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/menu_info.c	2000/05/03 03:57:24
@@ -23,7 +23,7 @@
 
 	for(;;)
 	{
-		R_open_driver();
+		R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 		tell_em_to_use_mouse() ;
 		answer = D_popup(
 			background_color,
Index: display/d.display/menu_main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/menu_main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 menu_main.c
--- display/d.display/menu_main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/menu_main.c	2000/05/03 03:57:24
@@ -15,6 +15,7 @@
 	int background_color ;
 	int text_color ;
 	int div_color ;
+	struct Option  *dev;
 	static char *options[] = {
 		"DISPLAY MAIN MENU",
 		" map display",
@@ -29,23 +30,39 @@
 		" QUIT DISPLAY",
 		NULL } ;
 
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	background_color = D_translate_color(BC_MAIN) ;
 	text_color       = D_translate_color(TC_MAIN) ;
 	div_color        = D_translate_color(DC_MAIN) ;
 
+ 
 	G_gisinit(argv[0]) ;
 
+	/* Check command line */
+	if (argc > 1 && G_parser(argc, argv))
+		exit(-1);
+	
+	if (dev->answer) {
+		char env[256];
+		setenv("PRIVATE_DDISPLAY_DEVICE",dev->answer,1);
+	}
+
 	setup() ;
 	mapset = NULL;
 
 /* Set the font to quick and simple */
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	R_font("romans") ;
 	R_close_driver();
 
 	for(;;)
 	{
-		R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 		tell_em_to_use_mouse() ;
 		answer = D_popup(
 			background_color,
Index: display/d.display/msurement.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/msurement.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 msurement.c
--- display/d.display/msurement.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/msurement.c	2000/05/03 03:57:24
@@ -5,7 +5,7 @@
 
 int measurements()
 {
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(MAP.name) ;
 	R_close_driver();
 
Index: display/d.display/scale.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/scale.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 scale.c
--- display/d.display/scale.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/scale.c	2000/05/03 03:57:24
@@ -5,7 +5,7 @@
 
 int scale()
 {
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(MAP.name) ;
 	R_close_driver();
 
Index: display/d.display/setup.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/setup.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 setup.c
--- display/d.display/setup.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/setup.c	2000/05/03 03:57:24
@@ -9,8 +9,10 @@
 {
 	FILE *popen() ;
 	FILE *fptr ;
+	char command[128];
 
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
+	fprintf(stderr,">>%s\n",getenv("PRIVATE_DDISPLAY_DEVICE"));
 
 /* Try to make it possible to interactively change colors */
 	R_color_table_float() ;
@@ -36,12 +38,14 @@
 	gorun("grass.logo.sh", "") ;
 
 /* Provide known information */
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(LOC.name) ;
 	R_close_driver();
 
-	if (NULL != (fptr = popen("d.text", "w")))
+	snprintf(command,127,"d.text device=%s ",getenv("PRIVATE_DDISPLAY_DEVICE"));
+	if (NULL != (fptr = popen(command, "w")))
 	{
+		fprintf(fptr, "device=%s ",getenv("PRIVATE_DDISPLAY_DEVICE"));
 		fprintf(fptr, ".S 60\n.C white\n.B\n") ;
 		fprintf(fptr, "%s\n", G_myname()) ;
 		pclose(fptr) ;
@@ -51,3 +55,4 @@
 
 	return 0;
 }
+
Index: display/d.display/show_cell.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/show_cell.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 show_cell.c
--- display/d.display/show_cell.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/show_cell.c	2000/05/03 03:57:24
@@ -10,21 +10,24 @@
 	FILE *fptr ;
 	struct Cell_head wind ;
 	char buff[256] ;
+	char command[128];
 
 /* Show the map name in name window */
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(NAM.name) ;
 	Derase("black") ;
 	R_close_driver();
 
-	if (NULL != (fptr = popen("d.text", "w")))
+	snprintf(command,127,"d.text device=%s ",getenv("PRIVATE_DDISPLAY_DEVICE"));
+	if (NULL != (fptr = popen(command, "w")))
 	{
+		fprintf(fptr, "device=%s ",getenv("PRIVATE_DDISPLAY_DEVICE"));
 		fprintf(fptr, ".S 60\n.C white\n.B\n") ;
 		fprintf(fptr, "%s\n", G_get_cell_title (mapname, mapset)) ;
 		pclose(fptr) ;
 	}
 
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 
 /* Draw cell map */
 	G_get_window(&wind) ;
@@ -51,13 +54,15 @@
 {
 	struct Cell_head wind ;
 	FILE *fptr ;
+	char command[128];
 
 	/* G__get_window called here because we need to read the current window
 	 * which may have changed.  G_get_window reads thw window only once.
 	 */
 	G__get_window (&wind,"","WIND",G_mapset()) ;
 
-	if (NULL != (fptr = popen("d.mapgraph", "w")))
+	snprintf(command,127,"d.mapgraph device=%s ",getenv("PRIVATE_DDISPLAY_DEVICE"));
+	if (NULL != (fptr = popen(command, "w")))
 	{
 		double dx, dy, x, y ;
 		dx = wind.east - wind.west ;
Index: display/d.display/show_leg.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/show_leg.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 show_leg.c
--- display/d.display/show_leg.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/show_leg.c	2000/05/03 03:57:24
@@ -13,7 +13,7 @@
 	char buff[256] ;
 
 /* Draw legend */
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(LEG.name) ;
 	Derase("black") ;
 	R_close_driver();
Index: display/d.display/show_region.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/show_region.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 show_region.c
--- display/d.display/show_region.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/show_region.c	2000/05/03 03:57:25
@@ -10,16 +10,18 @@
 	struct Cell_head wind ;
 	char wbuf[50], ebuf[50], nbuf[50], sbuf[50];
 	char nsbuf[50], ewbuf[50];
+	char command[128];
 
 	if (-1 == G_get_set_window(&wind))
 		return(-1) ;
 
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(COO.name) ;
 	Derase("black") ;
 	R_close_driver();
 
-	if (NULL != (fptr = popen("d.text", "w")))
+	snprintf(command,127,"d.text device=%s ",getenv("PRIVATE_DDISPLAY_DEVICE"));
+	if (NULL != (fptr = popen(command, "w")))
 	{
 		G_format_northing (wind.south, sbuf, wind.proj);
 		G_format_northing (wind.north, nbuf, wind.proj);
Index: display/d.display/site.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/site.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 site.c
--- display/d.display/site.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/site.c	2000/05/03 03:57:25
@@ -11,7 +11,7 @@
 	fprintf (stdout,"Sorry, not available yet\n") ;
 	do_pause() ;
 */
-	R_open_driver ();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose (MAP.name);
 	R_close_driver ();
 	gorun ("d.sites", "");
Index: display/d.display/vect_map.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/vect_map.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 vect_map.c
--- display/d.display/vect_map.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/vect_map.c	2000/05/03 03:57:25
@@ -15,7 +15,7 @@
 	char *color ;
 	int option ;
 
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	Dchoose(MAP.name) ;
 	R_close_driver();
 
Index: display/d.display/zoom.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.display/zoom.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 zoom.c
--- display/d.display/zoom.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.display/zoom.c	2000/05/03 03:57:25
@@ -26,7 +26,7 @@
 	text_color       = D_translate_color(TC_WIND) ;
 	div_color        = D_translate_color(DC_WIND) ;
 
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 	tell_em_to_use_mouse() ;
 	i = D_popup(
 		background_color,
@@ -43,7 +43,7 @@
 	switch(i)
 	{
 	case 1:
-		R_open_driver();
+		R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 		Dchoose(MAP.name) ;
 		R_close_driver();
 		G_clear_screen() ;
@@ -53,7 +53,7 @@
 			return 1;
 		break ;
 	case 2:
-		R_open_driver();
+		R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 		Dchoose(REF.name) ;
 		R_close_driver();
 		G_clear_screen() ;
@@ -74,7 +74,7 @@
 
 	show_region() ;
 
-	R_open_driver();
+	R_open_driver2(getenv("PRIVATE_DDISPLAY_DEVICE"));
 
 /* Draw cell map */
 	/* G__get_window called here because we need to read the current window
Index: display/d.erase/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.erase/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.erase/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.erase/main.c	2000/05/03 03:57:25
@@ -2,38 +2,51 @@
 #include "display.h"
 #include "D.h"
 #include "raster.h"
+#include "../../libes/raster/graph.h"
 
 int main(int argc,char *argv[])
 {
-	struct Option *color;
+	struct Option *color, *dev;
 	char name[256];
 	char *err;
+	char* driver;
 
 	G_gisinit(argv[0]);
 
 	color = G_define_option();
 	color->key = "color";
-	color->type = TYPE_STRING;
+	color->type = TYPE_COLOR;
 	color->required = NO;
 	color->answer = "black";	/* set default color! */
 	color->description = "Color to erase with";
 
-	if (argc > 1 && G_parser(argc, argv))
-		exit(1);
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+	/*dev->gisprompt   = "old,cell,raster" ;*/
+    dev->description = "Graphice device";
 
-	R_open_driver();
+   if (argc > 1 && G_parser(argc, argv))
+        exit(-1);
 
+	R_open_driver2(dev->answer);
+	_send_ident(CONNECTION_BEGIN);
+
 	err = NULL;
-	if (D_get_cur_wind(name))
-		err = "No current frame" ;
-	else if (D_set_cur_wind(name))
-		err = "Current frame not available" ;
-	else
-		Derase(color->answer) ;
 
+		if (D_get_cur_wind(name))
+			err = "No current frame..." ;
+		else if (D_set_cur_wind(name))
+			err = "Current frame not available" ;
+		else
+			Derase(color->answer) ;
+		
+	_send_ident(CONNECTION_END);
 	R_close_driver();
 	if (err)
 		G_fatal_error(err) ;
 
 	exit(0);
 }
+
Index: display/d.font/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.font/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.font/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.font/cmd/main.c	2000/05/03 03:57:25
@@ -10,6 +10,7 @@
         char buf[1024];
         FILE *fd;
         struct Option *opt1;
+		struct Option  *dev;
         int i;
 
         /* find out what fonts we have */
@@ -39,6 +40,12 @@
         opt1->answer     = "romans";
         opt1->description= "Choose new current font" ;
 
+		dev              = G_define_option();
+		dev->key         = "device";
+		dev->type        = TYPE_STRING;
+		dev->required    = NO;
+		dev->description = "Graphics device";
+
         /* Initialize the GIS calls */
         G_gisinit(argv[0]) ;
 
@@ -47,7 +54,8 @@
                 exit(-1);
 
         /* load the font */
-        R_open_driver();
+		R_open_driver2(dev->answer);
+/*          R_open_driver(); */
         R_font(opt1->answer) ;
 
         /* add this command to the list */
Index: display/d.frame/cmd/create.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.frame/cmd/create.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 create.c
--- display/d.frame/cmd/create.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.frame/cmd/create.c	2000/05/03 03:57:25
@@ -17,7 +17,7 @@
 	int stat;
 	char name[256] ;
 	float top, bottom, left, right;
-	struct Option *frame, *at;
+	struct Option *frame, *at, *dev;
 
 	frame = G_define_option();
 	frame->key = "frame";
@@ -34,10 +34,18 @@
 	at->description = "Where to place the frame";
 	at->answer = NULL;
 
-	R_open_driver ();
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+	
 
 	if (argc > 1 && G_parser(argc,argv))
 		exit(1);
+
+	R_open_driver2(dev->answer);
+
 	if (at->answer)
 	{
 		if (4 != sscanf(at->answer,"%f,%f,%f,%f",
Index: display/d.frame/cmd/dumper.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.frame/cmd/dumper.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 dumper.c
--- display/d.frame/cmd/dumper.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.frame/cmd/dumper.c	2000/05/03 03:57:25
@@ -1,8 +1,10 @@
 #include "raster.h"
 #include <stdio.h>
+#include "gis.h"
 
+
 int 
-main (void)
+main (int argc, char* argv[])
 {
     char **pads;
     char **items;
@@ -14,8 +16,18 @@
     int i;
     int n ;
     int stat ;
+	struct Option *dev;
+
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
+    if (G_parser(argc,argv))
+			exit(1);
 
-    R_open_driver();
+	R_open_driver2(dev->answer);
 
     R_pad_list (&pads, &npads);
     for (p = -1; p < npads; p++)
Index: display/d.frame/cmd/frame.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.frame/cmd/frame.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 frame.c
--- display/d.frame/cmd/frame.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.frame/cmd/frame.c	2000/05/03 03:57:25
@@ -25,6 +25,7 @@
     int check_at();
     char buf[1024];
     int create, select, print, debug;
+	struct Option *dev;
     struct
     {
 	struct Option *frame, *at;
@@ -74,10 +75,17 @@
     parm.at->description = "Where to place the frame (implies -c)";
     parm.at->checker = check_at;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     if (G_parser(argc,argv))
 	exit(1);
 
-    R_open_driver();
+	R_open_driver2(dev->answer);
+/*      R_open_driver(); */
 
     create = flag.create->answer;
     print  = flag.print->answer;
@@ -99,7 +107,7 @@
     if (create)
     {
 	select = 0;
-	sprintf (buf, "%s/etc/frame.create", G_gisbase());
+	sprintf (buf, "%s/etc/frame.create device=%s", G_gisbase(), dev->answer?dev->answer:"");
 	if (parm.frame->answer)
 	{
 	    strcat (buf, " frame='");
@@ -116,7 +124,7 @@
     }
     if (select)
     {
-	sprintf (buf, "%s/etc/frame.select", G_gisbase());
+	sprintf (buf, "%s/etc/frame.select device=%s", G_gisbase(), dev->answer?dev->answer:"");
 	if (parm.frame->answer)
 	{
 	    strcat (buf, " frame='");
@@ -128,13 +136,13 @@
 
     if (debug)
     {
-	sprintf (buf, "%s/etc/frame.dumper", G_gisbase());
+	sprintf (buf, "%s/etc/frame.dumper device=%s", G_gisbase(), dev->answer?dev->answer:"");
 	if(system (buf)) exit(1);
     }
 
     if (print)
     {
-	R_open_driver();
+	R_open_driver2(dev->answer);
 	D_get_cur_wind(buf) ;
 	D_set_cur_wind(buf) ;
 	R_close_driver() ;
Index: display/d.frame/cmd/select.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.frame/cmd/select.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 select.c
--- display/d.frame/cmd/select.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.frame/cmd/select.c	2000/05/03 03:57:25
@@ -20,6 +20,7 @@
     int button ;
 
     struct Option *frame;
+	struct Option *dev;
 
     frame = G_define_option();
     frame->key = "frame";
@@ -28,10 +29,17 @@
     frame->description = "Name of frame to choose (use mouse if not specified)";
     frame->answer = NULL;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
+
     if (argc > 1 && G_parser(argc, argv))
 	exit(1);
 
-    R_open_driver ();
+	R_open_driver2(dev->answer);
 
     if (frame->answer)
     {
Index: display/d.geodesic/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.geodesic/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.geodesic/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.geodesic/cmd/main.c	2000/05/03 03:57:26
@@ -11,6 +11,7 @@
     double lon1,lat1,lon2,lat2;
     char msg[100];
     char *deftcolor;
+	struct Option *dev;
     struct
     {
 	struct Option *lcolor, *tcolor, *coor;
@@ -27,7 +28,7 @@
 
     parm.lcolor = G_define_option() ;
     parm.lcolor->key        = "lcolor" ;
-    parm.lcolor->type       = TYPE_STRING ;
+    parm.lcolor->type       = TYPE_COLOR ;
     parm.lcolor->required   = NO ;
     parm.lcolor->description= "Line color" ;
     parm.lcolor->options    = D_color_list();
@@ -35,12 +36,19 @@
 
     parm.tcolor = G_define_option() ;
     parm.tcolor->key        = "tcolor" ;
-    parm.tcolor->type       = TYPE_STRING ;
+    parm.tcolor->type       = TYPE_COLOR ;
     parm.tcolor->required   = NO ;
     parm.tcolor->description= "Text color" ;
     parm.tcolor->options    = D_color_list();
 
-    if (argc > 1 && G_parser(argc, argv))
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+	/*dev->gisprompt   = "old,cell,raster" ;*/
+    dev->description = "Graphics device";
+
+   if (argc > 1 && G_parser(argc, argv))
         exit(-1);
 
     if (G_projection() != PROJECTION_LL)
@@ -81,7 +89,8 @@
 	use_mouse = 0;
     }
 
-    R_open_driver();
+/*      R_open_driver(); */
+	R_open_driver2(dev->answer);
 
     line_color = D_translate_color (parm.lcolor->answer);
     if (!line_color)
Index: display/d.graph/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.graph/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.graph/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.graph/cmd/main.c	2000/05/03 03:57:26
@@ -18,6 +18,7 @@
 {
 	char window_name[64] ;
 	struct Option *opt1, *opt2 ;
+	struct Option  *dev;
 
 	opt1 = G_define_option() ;
 	opt1->key        = "input" ;
@@ -27,11 +28,17 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "color" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->options    = D_color_list();
 	opt2->description= "Color selection graphics" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
 
@@ -69,7 +76,8 @@
 		}
 	}
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current window") ;
Index: display/d.grid/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.grid/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.grid/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.grid/cmd/main.c	2000/05/03 03:57:26
@@ -18,6 +18,7 @@
 	double size ;
 	double east, north ;
 	struct Option *opt1, *opt2, *opt3 ;
+	struct Option  *dev;
 
 	opt2 = G_define_option() ;
 	opt2->key        = "size" ;
@@ -28,7 +29,7 @@
 
 	opt1 = G_define_option() ;
 	opt1->key        = "color" ;
-	opt1->type       = TYPE_STRING ;
+	opt1->type       = TYPE_COLOR ;
 	opt1->required   = NO;
 	opt1->answer     = "gray" ;
 	opt1->options    = D_color_list();
@@ -42,6 +43,12 @@
 	opt3->multiple   = NO;
 	opt3->description= "Lines of the grid pass through this coordinate" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
 
@@ -78,7 +85,8 @@
 	}
 
 	/* Setup driver and check important information */
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	D_setup(0);
 
Index: display/d.his/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.his/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.his/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.his/cmd/main.c	2000/05/03 03:57:27
@@ -35,6 +35,7 @@
 	struct Colors out_colors ;
 	struct Colors sat_colors ;
 	struct Option *opt1, *opt2, *opt3, *opt4 ;
+	struct Option  *dev;
 	char mg[100];
 
 	opt1 = G_define_option() ;
@@ -65,6 +66,12 @@
 	opt4->gisprompt  = "new,cell,raster" ;
 	opt4->description= "Name of raster map to contain results" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	G_gisinit(argv[0]) ;
 
 	if (G_parser(argc, argv))
@@ -207,6 +214,11 @@
 	}
 
 	out_array = G_allocate_cell_buf () ;
+
+
+/* Was missing from original file ?!? (pmx) 04/2000 */
+	R_open_driver2(dev->answer);
+
 
 	/* Make color table */
 	G_make_HIS_color(&out_colors) ;
Index: display/d.histogram/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.histogram/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.histogram/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.histogram/cmd/main.c	2000/05/03 03:57:27
@@ -57,6 +57,7 @@
 	struct Flag *flag1 ;
 	struct Flag *flag2 ;
 	struct Flag *flag3 ;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
@@ -71,7 +72,7 @@
 	opt2             = G_define_option() ;
 	opt2->key        = "color" ;
 	opt2->description= "Color for legend and title";
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->required   = NO ;
 	opt2->answer     = "white" ;
 	opt2->options    = D_color_list();
@@ -100,6 +101,12 @@
 	opt5->required   = NO ;
 	opt5->answer     = "255" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	flag1            = G_define_flag() ;
 	flag1->key       = 'n' ;
 	flag1->description= "Display information for null cells" ;
@@ -178,7 +185,8 @@
 
 	/* set up the graphics driver and initialize its color-table */
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	D_setup(0);
 
Index: display/d.icons/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.icons/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.icons/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.icons/cmd/main.c	2000/05/03 03:57:27
@@ -31,6 +31,7 @@
     char *name, *mapset;
     char *D_color_list();
     ICON icon1, icon2;
+	struct Option  *dev;
 
     /* Define the different options */
 
@@ -43,7 +44,7 @@
 
     parm.color = G_define_option() ;
     parm.color->key        = "color";
-    parm.color->type       = TYPE_STRING;
+    parm.color->type       = TYPE_COLOR;
     parm.color->required   = NO;
     parm.color->answer     = "white";
     parm.color->options    = D_color_list();
@@ -67,7 +68,14 @@
     flag.reversed->key = 'r';
     flag.reversed->description = "Input coordinates reversed (north east)";
 
-    /* Initialize the GIS calls */
+     dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+	/*dev->gisprompt   = "old,cell,raster" ;*/
+    dev->description = "Graphics device";
+
+   /* Initialize the GIS calls */
     G_gisinit(argv[0]) ;
 
     /* Check command line */
@@ -108,7 +116,8 @@
 
 
     /* Setup driver and check important information */
-    R_open_driver();
+	R_open_driver2(dev->answer);
+/*      R_open_driver(); */
     R_standard_color (color) ;
     setup_plot();
 
Index: display/d.label/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.label/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.label/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.label/cmd/main.c	2000/05/03 03:57:28
@@ -22,6 +22,7 @@
 	int textcolor ;
 	int tsize ;
 	struct Option *opt1, *opt2, *opt3, *opt4 ;
+	struct Option  *dev;
 
 	opt1 = G_define_option() ;
 	opt1->key        = "size" ;
@@ -33,7 +34,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "backcolor" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->required   = NO ;
 	opt2->answer     = "black" ;
 	opt2->options    = D_color_list();
@@ -41,7 +42,7 @@
 
 	opt3 = G_define_option() ;
 	opt3->key        = "textcolor" ;
-	opt3->type       = TYPE_STRING ;
+	opt3->type       = TYPE_COLOR ;
 	opt3->required   = NO ;
 	opt3->answer     = "white" ;
 	opt3->options    = D_color_list();
@@ -54,6 +55,12 @@
 	opt4->options="romand,romanp,romant,romans,scriptc,scripts,romancs,italicc,italiccs,gothitt,gothgrt,gothgbt" ;
 	opt4->description= "Sets the font" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
 
@@ -81,7 +88,8 @@
 
 
 	/* */
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (opt4->answer != NULL)
 		R_font(opt4->answer) ;
Index: display/d.labels/get_loc.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.labels/get_loc.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 get_loc.c
--- display/d.labels/get_loc.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.labels/get_loc.c	2000/05/03 03:57:28
@@ -8,6 +8,7 @@
 #include "raster.h"
 #include "display.h"
 #include "local_proto.h"
+extern char* driver;
 
 int get_location (int option, char *east, char *north)
 {
@@ -16,7 +17,8 @@
     int t, b, l, r ;
     int flag;
 
-    R_open_driver();
+/*      R_open_driver(); */
+	R_open_driver2(driver);
 
     if (D_get_cur_wind(temp))
 	G_fatal_error("No current graphics window") ;
Index: display/d.labels/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.labels/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.labels/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.labels/main.c	2000/05/03 03:57:28
@@ -9,6 +9,7 @@
 #include "local_proto.h"
 
 char *element = "paint/labels" ;
+char *driver= NULL;
 
 int 
 main (int argc, char **argv)
@@ -18,13 +19,25 @@
     char *tempfile;
     FILE *in;
     int stat, option, new_file;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
     G_gisinit(argv[0]) ;
 
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     option = 0;
+
+    if (argc > 1 && G_parser(argc, argv))
+        exit(-1);
+
+	driver = dev->answer;
 
-    mapset = G_ask_any ("enter new or existing paint labels file", 
+   mapset = G_ask_any ("enter new or existing paint labels file", 
 			    name, element, "labels", 0);
     if (mapset == NULL)
 	  exit(0);
Index: display/d.labels/show_a_label.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.labels/show_a_label.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 show_a_label.c
--- display/d.labels/show_a_label.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.labels/show_a_label.c	2000/05/03 03:57:28
@@ -14,6 +14,8 @@
 #include "config.h"
 #include "local_proto.h"
 
+extern char* driver;
+
 int 
 show_a_label (char *tmp_fname)
 {
@@ -23,7 +25,8 @@
 	FILE *infile ;
 	int t, b, l, r ;
 
-	R_open_driver();
+	R_open_driver2(driver);
+/*  	R_open_driver(); */
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current window") ;
Index: display/d.leg.thin/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.leg.thin/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.leg.thin/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.leg.thin/main.c	2000/05/03 03:57:29
@@ -27,6 +27,7 @@
 	struct Categories cats ;
 	struct Colors colors ;
 	struct Option *opt1, *opt2, *opt3, *opt4 ;
+	struct Option  *dev;
 	struct Range range ;
 	CELL min_ind, max_ind, null_cell;
 	DCELL dmin, dmax, val;
@@ -40,7 +41,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "color" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->options    = D_color_list();
 	opt2->description= "Sets the legend's text color" ;
@@ -61,6 +62,12 @@
 	opt4->options    = "0-1000" ;
 	opt4->description= "Number of text lines (useful for truncating long legends)" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
 
@@ -119,7 +126,8 @@
 
 	G_set_c_null_value(&null_cell, 1);
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current window") ;
Index: display/d.legend/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.legend/cmd/main.c,v
retrieving revision 1.3
diff -u -r1.3 main.c
--- display/d.legend/cmd/main.c	2000/02/01 18:55:00	1.3
+++ display/d.legend/cmd/main.c	2000/05/03 03:57:29
@@ -36,6 +36,7 @@
 	struct Categories cats ;
 	struct Colors colors ;
 	struct Option *opt1, *opt2, *opt3, *opt4 ;
+	struct Option  *dev;
 	struct Range range ;
 	struct Flag *flag1;
 	struct FPRange fp_range ;
@@ -51,7 +52,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "color" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->options    = D_color_list();
 	opt2->description= "Sets the legend's text color" ;
@@ -72,6 +73,12 @@
 	opt4->options    = "0-1000" ;
 	opt4->description= "Number of text lines (useful for truncating long legends)" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
         flag1 = G_define_flag();
         flag1->key      = 'n';
         flag1->description= "Do not display no data (NULL) values.";
@@ -137,7 +144,8 @@
         color_ramp = 0;
 	G_set_c_null_value(&null_cell, 1);
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current window") ;
Index: display/d.mapgraph/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.mapgraph/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.mapgraph/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.mapgraph/cmd/main.c	2000/05/03 03:57:29
@@ -13,6 +13,7 @@
 {
 	int color ;
 	struct Option *opt1, *opt2/*, *opt3, *opt4*/ ;
+	struct Option  *dev;
 
 	opt1 = G_define_option() ;
 	opt1->key        = "input" ;
@@ -22,7 +23,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "color" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->options    = D_color_list();
 	opt2->description= "Starting color desired for graphics" ;
@@ -43,6 +44,12 @@
 	opt4->description= "Horizontal text width as % of display frame width" ;
 */
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
 
@@ -94,7 +101,8 @@
 
 	vsize = hsize = 5.0 ;
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	D_setup(0);
 
Index: display/d.measure/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.measure/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.measure/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.measure/cmd/main.c	2000/05/03 03:57:30
@@ -6,6 +6,7 @@
 int main (int argc, char **argv)
 {
 	char frame[64] ;
+	struct Option  *dev;
 	struct
 	{
 	    struct Option *c1;
@@ -19,7 +20,7 @@
 	parm.c1 = G_define_option();
 	parm.c1->key = "c1";
 	parm.c1->description = "line color 1";
-	parm.c1->type = TYPE_STRING;
+	parm.c1->type = TYPE_COLOR;
 	parm.c1->required = NO;
 	parm.c1->options=D_color_list();
 	parm.c1->answer = "black";
@@ -27,15 +28,23 @@
 	parm.c2 = G_define_option();
 	parm.c2->key = "c2";
 	parm.c2->description = "line color 2";
-	parm.c2->type = TYPE_STRING;
+	parm.c2->type = TYPE_COLOR;
 	parm.c2->required = NO;
 	parm.c2->options=D_color_list();
 	parm.c2->answer = "white";
 
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_COLOR;
+    dev->required    = NO;
+	/*dev->gisprompt   = "old,cell,raster" ;*/
+    dev->description = "Graphics device";
+
 	if (G_parser(argc,argv))
 	    exit(1);
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(frame))
 		G_fatal_error("No current frame") ;
Index: display/d.menu/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.menu/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.menu/cmd/main.c	1999/12/29 15:10:06	1.1.1.1
+++ display/d.menu/cmd/main.c	2000/05/03 03:57:30
@@ -40,10 +40,12 @@
 	int i ;
 	int len ;
 	struct Option *opt1, *opt2, *opt3, *opt4 ;
+	struct Option  *dev;
 
+
 	opt1 = G_define_option() ;
 	opt1->key        = "bcolor" ;
-	opt1->type       = TYPE_STRING ;
+	opt1->type       = TYPE_COLOR ;
 	opt1->answer     = "black" ;
 	opt1->required   = NO ;
 	opt1->options    = D_color_list();
@@ -51,7 +53,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "tcolor" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->required   = NO ;
 	opt2->options    = D_color_list();
@@ -59,7 +61,7 @@
 
 	opt3 = G_define_option() ;
 	opt3->key        = "dcolor" ;
-	opt3->type       = TYPE_STRING ;
+	opt3->type       = TYPE_COLOR ;
 	opt3->answer     = "white" ;
 	opt3->required   = NO ;
 	opt3->options    = D_color_list();
@@ -73,6 +75,12 @@
 	opt4->options    = "1-100" ;
 	opt4->description= "Sets the menu text size" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
 
@@ -82,7 +90,8 @@
 	if (G_parser(argc, argv))
 		exit(-1);
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	backcolor = D_translate_color(opt1->answer) ;
 	if (backcolor == 0)
Index: display/d.mouse/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.mouse/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.mouse/main.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.mouse/main.c	2000/05/03 03:57:30
@@ -5,6 +5,7 @@
     char **argv ;
 {
     struct Option *anchor, *drag;
+	struct Option  *dev;
     double east0,north0;
 
 /* Initialize the GIS calls */
@@ -25,6 +26,12 @@
     drag->answer = "none";
     drag->description = "drag method";
 
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     if (argc > 1)
     {
 	if (G_parser(argc, argv))
@@ -51,7 +58,7 @@
 	east0 = north0 = 0.0;
     }
 
-    R_open_driver();
+	R_open_driver2(dev->answer);
     setup();
     where(east0, north0, drag->answer);
     R_close_driver();
Index: display/d.p.labels/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.p.labels/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.p.labels/cmd/main.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.p.labels/cmd/main.c	2000/05/03 03:57:30
@@ -13,6 +13,7 @@
 	char buff[128] ;
 	int t, b, l, r ;
         struct Option *opt1;
+	struct Option  *dev;
 
 /* Initialize the GIS calls */
     G_gisinit(argv[0]) ;
@@ -24,6 +25,12 @@
     opt1->gisprompt  = "old,paint/labels,paint labels" ;
     opt1->description= "Name of label file" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     if (G_parser(argc, argv))
         exit(-1);
 
@@ -48,7 +55,8 @@
 		G_fatal_error(buff) ;
 	}
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current window") ;
Index: display/d.pan/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.pan/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.pan/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.pan/main.c	2000/05/03 03:57:31
@@ -15,6 +15,7 @@
     struct Flag *quiet;
     struct Option *zoom;
     double magnify;
+	struct Option  *dev;
 
 /* Initialize the GIS calls */
     G_gisinit(argv[0]) ;
@@ -31,12 +32,19 @@
     zoom->options    = "0.001-1000.0" ;
     zoom->description= "magnification: >1.0 zooms in, <1.0 zooms out" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     if (argc > 1 && G_parser(argc,argv))
 	exit(1);
 
     sscanf(zoom->answer,"%lf", &magnify); 
 
-    R_open_driver();
+/*      R_open_driver(); */
+	R_open_driver2(dev->answer);
 
     D_setup(0);
 
Index: display/d.param.scale/init_graphics.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.param.scale/init_graphics.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 init_graphics.c
--- display/d.param.scale/init_graphics.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.param.scale/init_graphics.c	2000/05/03 03:57:31
@@ -8,6 +8,7 @@
 
 #include "param.h"
 
+extern char* driver;
 
 init_graphics()
 {
@@ -27,7 +28,8 @@
     /*------------------------------------------------------------------*/
 
     system("d.frame -e; d.erase white");
-    R_open_driver();
+/*      R_open_driver(); */
+	R_open_driver2(driver);
 
     D_get_screen_window(&top,&bot,&lef,&rit);	/* Get window coords.	*/
 
Index: display/d.param.scale/interface.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.param.scale/interface.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 interface.c
--- display/d.param.scale/interface.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.param.scale/interface.c	2000/05/03 03:57:31
@@ -6,6 +6,7 @@
 /*********************************************************************************/
 
 #include "param.h"
+extern char* driver;
 
 interface(argc,argv) 
 
@@ -25,6 +26,7 @@
 			*expon,		/* Inverse distance exponent for weight.*/
 			*vert_sc;	/* Vertical scaling factor.		*/
 
+	struct Option  *dev;
     struct Flag		*constr,	/* Forces quadratic through the central	*/
 					/* cell of local window if selected.	*/
 			*fixed,		/* Fix axis scale.			*/
@@ -95,6 +97,12 @@
     vert_sc->required	  = NO;
     vert_sc->answer	  = "1.0";
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     constr->key		  = 'c';
     constr->description   = "Constrain model through central window cell";
     
@@ -117,6 +125,8 @@
     sscanf(vert_sc->answer,"%lf",&zscale);
     sscanf(tol1_val->answer,"%lf",&slope_tol);
     sscanf(tol2_val->answer,"%lf",&curve_tol);
+
+	driver=dev->answer;
 
     if ((exponent<0.0) || (exponent >4.0))
 	exponent = 0.0;
Index: display/d.param.scale/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.param.scale/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.param.scale/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.param.scale/main.c	2000/05/03 03:57:32
@@ -11,6 +11,7 @@
 #define MAIN
 
 #include "param.h"	
+char * driver = NULL;
 
 main(argc,argv) 
     int argc;
Index: display/d.points/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.points/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.points/cmd/main.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.points/cmd/main.c	2000/05/03 03:57:32
@@ -9,10 +9,11 @@
 {
     char *D_color_list();
     struct Option *opt1, *opt2, *opt3, *opt4;
+	struct Option  *dev;
 
     opt1 = G_define_option() ;
     opt1->key        = "color" ;
-    opt1->type       = TYPE_STRING ;
+    opt1->type       = TYPE_COLOR ;
     opt1->required   = NO ;
     opt1->answer     = "gray" ;
     opt1->options    = D_color_list();
@@ -41,6 +42,12 @@
     opt4->answer     = NULL ;
     opt4->description= "Input is a UNIX file name" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     /* Initialize the GIS calls */
     G_gisinit(argv[0]) ;
 
@@ -83,7 +90,8 @@
 
 
     /* Setup driver and check important information */
-    R_open_driver();
+	R_open_driver2(dev->answer);
+/*      R_open_driver(); */
     setup();
 
     /* Do the plotting */
Index: display/d.profile/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.profile/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.profile/main.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.profile/main.c	2000/05/03 03:57:33
@@ -35,6 +35,7 @@
 	int    i,CurrentWin=0;
 	int    min,max;
 	struct Option *map;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
@@ -47,6 +48,12 @@
 	map->gisprompt   = "old,cell,raster" ;
 	map->description = "Raster map to be profiled";
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	if (G_parser(argc, argv))
 		exit(1);
 
@@ -79,7 +86,8 @@
 	fprintf (stdout,"\n\nUse mouse to choose action\n");
 
 	/* establish connection with graphics driver */
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	/* Make sure screen is clear */
 	Dclearscreen() ;
Index: display/d.rast/cmd/display.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rast/cmd/display.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 display.c
--- display/d.rast/cmd/display.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rast/cmd/display.c	2000/05/03 03:57:33
@@ -140,3 +140,10 @@
 
     return 0;
 }
+
+
+
+
+
+
+
Index: display/d.rast/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rast/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.rast/cmd/main.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rast/cmd/main.c	2000/05/03 03:57:34
@@ -3,6 +3,7 @@
 #define MAIN
 #include "mask.h"
 #include "local_proto.h"
+#include "../../../libes/raster/graph.h"
 
 static int parse_catlist ( char **, Mask *);
 static int parse_vallist ( char **, d_Mask *);
@@ -16,6 +17,7 @@
     int overlay;
     int invert, fp;
     struct Option *map;
+    struct Option *dev;
     struct Option *catlist;
     struct Option *vallist;
     struct Option *bg;
@@ -33,6 +35,12 @@
     map->gisprompt   = "old,cell,raster" ;
     map->description = "Raster map to be displayed";
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     catlist              = G_define_option();
     catlist->key         = "catlist";
     catlist->key_desc    = "cat[-cat]";
@@ -52,7 +60,7 @@
     bg              = G_define_option();
     bg->key         = "bg";
     bg->key_desc    = "color";
-    bg->type        = TYPE_STRING;
+    bg->type        = TYPE_COLOR;
     bg->required    = NO;
     bg->options     = color_list();
     bg->description = "Background color (for null)";
@@ -81,7 +89,8 @@
         G_fatal_error(buf) ;
     }
 
-    R_open_driver();
+    R_open_driver2(dev->answer);
+	_send_ident(CONNECTION_BEGIN);
 
     fp = G_raster_map_is_fp(name, mapset);
     if(catlist->answer)
@@ -102,6 +111,7 @@
     else
         display (name, mapset, overlay, bg->answer, CELL_TYPE, invert) ;
 
+	_send_ident(CONNECTION_END);
     R_close_driver();
 
     exit(0);
@@ -244,3 +254,6 @@
 
     return 0;
 }
+
+
+
Index: display/d.rast.arrow/arrow.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rast.arrow/arrow.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 arrow.c
--- display/d.rast.arrow/arrow.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rast.arrow/arrow.c	2000/05/03 03:57:41
@@ -60,6 +60,7 @@
     double U_start;
     double U_x, U_y ;
 	struct Option *opt1, *opt2, *opt3, *opt4, *opt5, *opt6 ;
+	struct Option  *dev;
 
 	G_gisinit(argv[0]) ;
 
@@ -81,7 +82,7 @@
 
     opt3 = G_define_option() ;
     opt3->key        = "arrow_color" ;
-    opt3->type       = TYPE_STRING ;
+    opt3->type       = TYPE_COLOR ;
     opt3->required   = NO ;
     opt3->answer     = "green" ;
     opt3->options = "white,red,orange,yellow,green,blue,indigo,violet,magenta,brown,gray,black";
@@ -89,7 +90,7 @@
 
     opt4 = G_define_option() ;
     opt4->key        = "grid_color" ;
-    opt4->type       = TYPE_STRING ;
+    opt4->type       = TYPE_COLOR ;
     opt4->required   = NO ;
     opt4->answer     = "gray" ;
     opt4->options = "white,red,orange,yellow,green,blue,indigo,violet,magenta,brown,gray,black";
@@ -97,7 +98,7 @@
 
     opt5 = G_define_option() ;
     opt5->key        = "x_color" ;
-    opt5->type       = TYPE_STRING ;
+    opt5->type       = TYPE_COLOR ;
     opt5->required   = NO ;
     opt5->answer     = "white" ;
     opt5->options = "white,red,orange,yellow,green,blue,indigo,violet,magenta,brown,gray,black";
@@ -105,12 +106,18 @@
 
     opt6 = G_define_option() ;
     opt6->key        = "unknown_color" ;
-    opt6->type       = TYPE_STRING ;
+    opt6->type       = TYPE_COLOR ;
     opt6->required   = NO ;
     opt6->answer     = "red" ;
     opt6->options = "white,red,orange,yellow,green,blue,indigo,violet,magenta,brown,gray,black";
     opt6->description= "Color for showing unknown information" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     /* Check command line */
     if (G_parser(argc, argv))
         exit(-1);
@@ -148,7 +155,8 @@
 
 /* Setup driver and check important information */
 
-    R_open_driver();
+/*      R_open_driver(); */
+	R_open_driver2(dev->answer);
 
     if (D_get_cur_wind(window_name))
         G_fatal_error("No current window") ;
Index: display/d.rast.edit/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rast.edit/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.rast.edit/main.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rast.edit/main.c	2000/05/03 03:57:41
@@ -29,10 +29,20 @@
 	char            temp[128], line[128];
 	char           *m;
 	struct FPRange    fp_range;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]);
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
+    if (argc > 1 && G_parser(argc,argv))
+	exit(1);
+
 	/*
 	 * note: grid color used to be an option set with the help of the
 	 * parser, but it was more bother than worth. if black is not what
@@ -42,7 +52,8 @@
 	strcpy(grid_color_name, "black");
 	grid_color = D_translate_color(grid_color_name);
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 	/*
 	 * if the monitor is divided into more than one window, find which is
 	 * the choosen, current one being used
Index: display/d.rast.num/number.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rast.num/number.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 number.c
--- display/d.rast.num/number.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rast.num/number.c	2000/05/03 03:57:41
@@ -53,6 +53,7 @@
 	struct Cell_head window ;
 	struct Colors colors;
 	struct Option *opt1, *opt2 ;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
@@ -67,17 +68,25 @@
 
     opt2 = G_define_option() ;
     opt2->key        = "grid_color" ;
-    opt2->type       = TYPE_STRING ;
+    opt2->type       = TYPE_COLOR ;
     opt2->required   = NO ;
     opt2->answer     = "gray" ;
     opt2->options = "white,red,orange,yellow,green,blue,indigo,violet,magenta,brown,gray,black";
     opt2->description= "Color for drawing grid" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
+
 	/* Check command line */
 	if (G_parser(argc, argv))
 		exit(-1);
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (opt1->answer)
 		strcpy(full_name, opt1->answer);
Index: display/d.rast.zoom/zoom.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rast.zoom/zoom.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 zoom.c
--- display/d.rast.zoom/zoom.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rast.zoom/zoom.c	2000/05/03 03:57:41
@@ -26,11 +26,22 @@
     char temp[128] ;
     int t, b, l, r ;
     struct Cell_head window;
+	struct Option  *dev;
 
 /* Initialize the GIS calls */
     G_gisinit (argv[0]) ;
 
-    R_open_driver();
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
+	if (argc>1 && G_parser(argc, argv))
+		exit(-1);
+
+/*      R_open_driver(); */
+	R_open_driver2(dev->answer);
 
     if (D_get_cur_wind(temp))
 	G_fatal_error("No current graphics window") ;
Index: display/d.rgb/cmd/init_rgb.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rgb/cmd/init_rgb.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 init_rgb.c
--- display/d.rgb/cmd/init_rgb.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rgb/cmd/init_rgb.c	2000/05/03 03:57:41
@@ -8,11 +8,11 @@
 	char window_name[64] ;
 	int t, b, l, r ;
 
-	R_open_driver() ;
+/*	R_open_driver() ; */
 
-
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current graphics window") ;
+
 
 	if (D_set_cur_wind(window_name))
 		G_fatal_error("Current graphics window not available") ;
Index: display/d.rgb/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rgb/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.rgb/cmd/main.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rgb/cmd/main.c	2000/05/03 03:57:41
@@ -12,8 +12,8 @@
 	CELL *b3_array ;
 	CELL *out_array ;
 	char *mapset ;
-	char name[20] ;
-	char buff[128] ;
+	char name[20]="" ;
+	char buff[128]="" ;
 	int atrow, atcol ;
 	int next_row;
 	int b1_file ;
@@ -31,7 +31,10 @@
 	struct Colors b3_colors ;
 	struct Colors out_colors ;
 	struct Option *opt1, *opt2, *opt3, *opt4 ;
+	struct Option  *dev;
 
+	G_gisinit(argv[0]) ;
+
 	opt1 = G_define_option() ;
 	opt1->key        = "red" ;
 	opt1->type       = TYPE_STRING ;
@@ -63,19 +66,26 @@
 	opt4->gisprompt  = "new,cell,raster" ;
 	opt4->description= "Name of raster map to contain results" ;
 
-	G_gisinit(argv[0]) ;
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
 
 	if (G_parser(argc, argv))
 		exit(-1);
 
 	/* Do screen initializing stuff */
+
+	R_open_driver2(dev->answer);
+/*  	R_open_driver(); */
 	init_rgb();
 
 	/* Get name of layer to be used for red */
 
 	b1_used = 0 ;
-
-	strcpy (name, opt1->answer);
+	if (opt1->answer)
+		strcpy (name, opt1->answer);
 
 	mapset = G_find_cell2(name, "");
 	if (mapset == NULL)
@@ -110,7 +120,9 @@
 
 	b2_used = 0 ;
 
-	strcpy (name, opt2->answer);
+	name[0]='\0';
+	if (opt2->answer)
+		strcpy (name, opt2->answer);
 
 	mapset = G_find_cell2(name, "");
 	if (mapset == NULL)
@@ -143,8 +155,11 @@
 	/* Get name of layer to be used for blue */
 
 	b3_used = 0 ;
+
+	name[0]='\0';
+	if (opt3->answer)
+		strcpy (name, opt3->answer);
 
-	strcpy (name, opt3->answer);
 	mapset = G_find_cell2(name, "");
 	if (mapset == NULL)
 	{
@@ -182,6 +197,8 @@
 
 	if (opt4->answer != NULL)
 	{
+	name[0]='\0';
+	if (opt4->answer)
 		strcpy (name, opt4->answer);
 
 		mapset = G_find_cell2(name, "");
Index: display/d.rhumbline/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.rhumbline/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.rhumbline/cmd/main.c	1999/12/29 15:10:07	1.1.1.1
+++ display/d.rhumbline/cmd/main.c	2000/05/03 03:57:41
@@ -14,6 +14,7 @@
 	    {
 		struct Option *lcolor, *tcolor, *coor;
 	} parm;
+	struct Option  *dev;
 
 	G_gisinit (argv[0]);
 
@@ -26,7 +27,7 @@
 
 	parm.lcolor = G_define_option() ;
 	parm.lcolor->key        = "lcolor" ;
-	parm.lcolor->type       = TYPE_STRING ;
+	parm.lcolor->type       = TYPE_COLOR ;
 	parm.lcolor->required   = NO ;
 	parm.lcolor->description= "Line color" ;
 	parm.lcolor->options    = D_color_list();
@@ -35,12 +36,18 @@
 #ifdef CAN_DO_DISTANCES
 	parm.tcolor = G_define_option() ;
 	parm.tcolor->key        = "tcolor" ;
-	parm.tcolor->type       = TYPE_STRING ;
+	parm.tcolor->type       = TYPE_COLOR ;
 	parm.tcolor->required   = NO ;
 	parm.tcolor->description= "Text color" ;
 	parm.tcolor->options    = D_color_list();
 #endif
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	if (argc > 1 && G_parser(argc, argv))
 		exit(-1);
 
@@ -82,7 +89,8 @@
 		use_mouse = 0;
 	}
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	line_color = D_translate_color (parm.lcolor->answer);
 	if (!line_color)
Index: display/d.scale/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.scale/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.scale/cmd/main.c	1999/12/29 15:10:08	1.1.1.1
+++ display/d.scale/cmd/main.c	2000/05/03 03:57:41
@@ -13,6 +13,7 @@
 	int t, b, l, r ;
 	struct Option *opt1, *opt2, *opt3 ;
 	struct Flag *mouse ;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]);
@@ -23,7 +24,7 @@
 
 	opt1 = G_define_option() ;
 	opt1->key        = "bcolor" ;
-	opt1->type       = TYPE_STRING ;
+	opt1->type       = TYPE_COLOR ;
 	opt1->answer     = "black" ;
 	opt1->required   = NO ;
 	opt1->options    = D_color_list();
@@ -31,7 +32,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "tcolor" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->required   = NO ;
 	opt2->options    = D_color_list();
@@ -46,6 +47,12 @@
 	opt3->required   = NO;
 	opt3->description= "the screen coordinates for top-left corner of label" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	coord_inp = 0;
 
 	if (G_parser(argc, argv) < 0)
@@ -65,7 +72,8 @@
 	sscanf(opt3->answers[1],"%lf",&north) ;
 	if((east>0)||(north>0)) coord_inp=1;
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current window") ;
Index: display/d.site.labels/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.site.labels/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.site.labels/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.site.labels/main.c	2000/05/03 03:57:41
@@ -16,6 +16,7 @@
         struct Option *opt1, *opt2, *opt3, *opt4, *opt5, *opt6;
 	struct Option *opt7, *opt8, *opt9 ;
 	struct Flag *mouse;
+	struct Option  *dev;
 	
 
 /* Initialize the GIS calls */
@@ -41,7 +42,7 @@
 
     opt3 = G_define_option() ;
     opt3->key        = "color" ;
-    opt3->type       = TYPE_STRING ;
+    opt3->type       = TYPE_COLOR ;
     opt3->required   = NO ;
     opt3->options    = "red,white,magenta,brown,blue,yellow,black,orange,green,violet,grey";
     opt3->answer     = "white";
@@ -63,7 +64,7 @@
 
     opt6 = G_define_option() ;
     opt6->key        = "backgr" ;
-    opt6->type       = TYPE_STRING ;
+    opt6->type       = TYPE_COLOR ;
     opt6->required   = NO ;
     opt6->answer     = "none" ;
     opt6->options    = "grey,red,white,magenta,brown,blue,yellow,black,orange,green,violet,none";
@@ -93,6 +94,12 @@
     opt9->answer     = "romans" ;
     opt9->description= "Fontname" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     if (G_parser(argc, argv))
         exit(-1);
 
@@ -117,7 +124,8 @@
 		G_fatal_error(buff) ;
 	}
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current window") ;
Index: display/d.sites/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.sites/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.sites/cmd/main.c	1999/12/29 15:10:08	1.1.1.1
+++ display/d.sites/cmd/main.c	2000/05/03 03:57:41
@@ -14,6 +14,7 @@
 	int t, b, l, r ;
 	struct Cell_head window ;
 	struct Option *opt1, *opt2, *opt3, *opt4;
+	struct Option  *dev;
 
 	opt4 = G_define_option() ;
 	opt4->key        = "sitefile";
@@ -24,7 +25,7 @@
 
 	opt1 = G_define_option() ;
 	opt1->key        = "color" ;
-	opt1->type       = TYPE_STRING ;
+	opt1->type       = TYPE_COLOR ;
 	opt1->required   = NO ;
 	opt1->answer     = "gray" ;
 	opt1->options    = D_color_list();
@@ -46,6 +47,12 @@
 	opt3->options    = "x,diamond,box,+" ;
 	opt3->description= "Specify the type of the icon" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	/* Initialize the GIS calls */
 	G_gisinit(argv[0]) ;
 
@@ -88,7 +95,8 @@
 		type = TYPE_DIAMOND ;
 
 	/* Setup driver and check important information */
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current frame") ;
Index: display/d.sites.label/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.sites.label/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.sites.label/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.sites.label/main.c	2000/05/03 03:57:41
@@ -20,6 +20,7 @@
 {
   struct Option *site_opt, *anchor_opt, *color_opt, *font_opt;
   struct Option *width_opt, *height_opt;
+  struct Option  *dev;
   char *sitefile;
   char *mapset;
   FILE *site_fd;
@@ -52,7 +53,7 @@
 
   color_opt = G_define_option();
   color_opt->key = "color";
-  color_opt->type = TYPE_STRING;
+  color_opt->type = TYPE_COLOR;
   color_opt->required = NO;
   color_opt->description = "Color to display text in";
   color_opt->answer = DEFAULT_COLOR;
@@ -78,6 +79,11 @@
   height_opt->description = "Height of letters";
   height_opt->answer = DEFAULT_HEIGHT;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
 
   if(G_parser(argc, argv))
     exit(1);
@@ -109,7 +115,8 @@
 
   G_get_set_window(&region);
 
-  R_open_driver();
+/*    R_open_driver(); */
+  R_open_driver2(dev->answer);
   D_setup(0);
   D_get_cur_wind(window_name);
   D_set_cur_wind(window_name);
Index: display/d.sites.qual/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.sites.qual/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.sites.qual/cmd/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.sites.qual/cmd/main.c	2000/05/03 03:57:41
@@ -21,6 +21,7 @@
 	struct Cell_head window ;
 	struct Option *opt1, *opt2, *opt3, *opt4, *opt5, *opt6;
 	struct Flag *do_num;
+	struct Option  *dev;
 
 	opt4 = G_define_option() ;
 	opt4->key        = "sitefile";
@@ -31,7 +32,7 @@
 
 	opt1 = G_define_option() ;
 	opt1->key        = "color" ;
-	opt1->type       = TYPE_STRING ;
+	opt1->type       = TYPE_COLOR ;
 	opt1->required   = NO ;
 	opt1->answer     = "gray" ;
 	opt1->options    = D_color_list();
@@ -67,6 +68,13 @@
 	opt6->gisprompt  = "new,site_lists,sites";
 	opt6->description= "Name of a site file to output drawn sites" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
+
 	do_num = G_define_flag ();
 	do_num->key = 'n';
 	do_num->description = "Output number of sites displayed";
@@ -133,7 +141,8 @@
 		type = TYPE_DIAMOND ;
 
 	/* Setup driver and check important information */
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(window_name))
 		G_fatal_error("No current frame") ;
Index: display/d.text/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.text/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.text/cmd/main.c	1999/12/29 15:10:08	1.1.1.1
+++ display/d.text/cmd/main.c	2000/05/03 03:57:41
@@ -33,6 +33,7 @@
         struct Option *opt1, *opt2, *opt3;
         char *wind_file_name;
         FILE *wind_file;
+		struct Option  *dev;
 
         opt1 = G_define_option() ;
         opt1->key        = "size" ;
@@ -44,7 +45,7 @@
 
         opt2 = G_define_option() ;
         opt2->key        = "color" ;
-        opt2->type       = TYPE_STRING ;
+        opt2->type       = TYPE_COLOR ;
         opt2->answer     = "gray" ;
         opt2->required   = NO ;
         opt2->options    = D_color_list();
@@ -58,6 +59,11 @@
         opt3->options    = "1-1000" ;
         opt3->description= "The screen line number on which text will begin to be drawn ";
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
 
         /* Initialize the GIS calls */
         G_gisinit(argv[0]) ;
@@ -67,7 +73,7 @@
                 exit(-1);
 
 		if (isatty(0))
-			fprintf (stdout,"\nPlease enter text instructions.  Enter EOF on last line to quit\n") ;
+			fprintf (stdout,"\nPlease enter text instructions.  Enter [CTRL-D] on last line to quit\n") ;
 
         sscanf(opt1->answer,"%f",&size);
 
@@ -82,7 +88,8 @@
 
 
         /* */
-        R_open_driver();
+/*          R_open_driver(); */
+	R_open_driver2(dev->answer);
 
         if (D_get_cur_wind(window_name))
                 G_fatal_error("No current window") ;
Index: display/d.title/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.title/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.title/cmd/main.c	1999/12/29 15:10:08	1.1.1.1
+++ display/d.title/cmd/main.c	2000/05/03 03:57:42
@@ -14,6 +14,7 @@
 	struct Categories cats ;
 	struct Option *opt1, *opt2, *opt3 ;
 	struct Flag *flag ;
+	struct Option  *dev;
 
 	opt1 = G_define_option() ;
 	opt1->key        = "map" ;
@@ -24,7 +25,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "color" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->required   = NO ;
 	opt2->options    = D_color_list();
@@ -37,6 +38,12 @@
 	opt3->options    = "0-100" ;
 	opt3->description= "Sets the text size as percentage of the frame's height" ;
 
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	flag = G_define_flag() ;
 	flag->key        = 'f' ;
 	flag->description= "Do a fancier title" ;
@@ -85,7 +92,8 @@
 	else
 		fancy(mapset, &window, &cats) ;
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 	D_add_to_list(G_recreate_command()) ;
 	R_close_driver();
 
Index: display/d.vect/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.vect/cmd/main.c,v
retrieving revision 1.2
diff -u -r1.2 main.c
--- display/d.vect/cmd/main.c	2000/04/21 10:09:25	1.2
+++ display/d.vect/cmd/main.c	2000/05/03 03:57:42
@@ -13,6 +13,9 @@
 #include "Vect.h"
 #define MAIN
 #include "local_proto.h"
+
+#include "../../../libes/raster/graph.h"
+
 int quiet = 1;
 
 int 
@@ -27,6 +30,7 @@
 	struct Option *opt1, *opt2;
 	struct Flag   *levone,  *_quiet;
 	struct line_pnts *Points;
+	struct Option  *dev;
 
 	opt1 = G_define_option() ;
 	opt1->key        = "map" ;
@@ -38,11 +42,17 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "color" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->options    = D_color_list();
 	opt2->description= "Color desired for drawing map" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	levone = G_define_flag ();
 	levone->key		= 'm';
 	levone->description	= "Use less memory";
@@ -72,11 +82,13 @@
 		exit(-1);
 	}
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
+	_send_ident(CONNECTION_BEGIN);
 
 	D_setup(0);
 
-	R_standard_color(color) ;
+  	R_standard_color(color) ; 
 
 	Points = Vect_new_line_struct ();
 
@@ -94,6 +106,7 @@
 
 	Vect_destroy_line_struct (Points);
 
+	_send_ident(CONNECTION_END);
 	R_close_driver();
 	exit(stat);
 }
Index: display/d.vect.cats/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.vect.cats/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.vect.cats/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.vect.cats/main.c	2000/05/03 03:57:42
@@ -29,6 +29,7 @@
 	struct Option *opt1, *opt2, *opt3;
 	struct Flag *flag1;
 	struct line_pnts *Points;
+	struct Option  *dev;
 
 
 	opt1 = G_define_option() ;
@@ -41,7 +42,7 @@
 
 	opt2 = G_define_option() ;
 	opt2->key        = "color" ;
-	opt2->type       = TYPE_STRING ;
+	opt2->type       = TYPE_COLOR ;
 	opt2->answer     = "white" ;
 	opt2->options = "white,red,orange,yellow,green,blue,indigo,violet,magenta,brown,gray,black";
 	opt2->description= "Color desired for drawing map" ;
@@ -53,6 +54,12 @@
 	opt3->multiple	= YES ;
 	opt3->description= "Vector category type to be displayed" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	flag1 = G_define_flag();
 	flag1->key 	= 'f';
 	flag1->description= "Fill areas";
@@ -81,7 +88,8 @@
 		exit(-1);
 	}
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	D_setup(0);
 
Index: display/d.vect.zoom/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.vect.zoom/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.vect.zoom/cmd/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.vect.zoom/cmd/main.c	2000/05/03 03:57:42
@@ -15,6 +15,7 @@
 	struct Map_info Map;
 	struct Categories Cats;
 	int level;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
 	G_gisinit (argv[0]) ;
@@ -26,6 +27,13 @@
 	opt1->gisprompt  = "old,dig,vector" ;
 	opt1->description= "Name of existing vector map" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
+
 	if(G_parser(argc,argv))
 		exit(1);
 
@@ -41,7 +49,8 @@
 	}
 
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 	D_setup(0);
 
 	level = Vect_open_old (&Map, name, mapset);
Index: display/d.what.rast/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.what.rast/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.what.rast/cmd/main.c	1999/12/29 15:10:08	1.1.1.1
+++ display/d.what.rast/cmd/main.c	2000/05/03 03:57:42
@@ -13,6 +13,7 @@
 	char **ptr;
 	struct Flag *once, *terse;
 	struct Option *opt1, *fs;
+	struct Option  *dev;
 
 
 	/* Initialize the GIS calls */
@@ -35,6 +36,12 @@
 	fs->answer	= ":";
 	fs->description = "Field separator (terse mode only)";
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	once = G_define_flag();
 	once->key = '1';
 	once->description = "Identify just one location";
@@ -50,7 +57,8 @@
 			exit(-1);
 	}
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(temp))
 		G_fatal_error("No current graphics window") ;
Index: display/d.what.sites/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.what.sites/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.what.sites/main.c	1999/12/29 15:10:11	1.1.1.1
+++ display/d.what.sites/main.c	2000/05/03 03:57:42
@@ -10,6 +10,7 @@
 	int t, b, l, r ;
 	struct Option *opt1;
 	struct Flag *shh;
+	struct Option  *dev;
 
 
 	/* Initialize the GIS calls */
@@ -24,6 +25,12 @@
 	opt1->gisprompt  = "old,site_lists,Sites" ;
 	opt1->description= "Name of existing sites file"; 
 
+	dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	shh = G_define_flag ();
 	shh->key = 'q';
 	shh->description = "Load quietly";
@@ -32,7 +39,8 @@
 	if (G_parser(argc, argv))
 	    exit(-1);
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 
 	if (D_get_cur_wind(temp))
 		G_fatal_error("No current graphics window") ;
Index: display/d.what.vect/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.what.vect/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.what.vect/cmd/main.c	1999/12/29 15:10:08	1.1.1.1
+++ display/d.what.vect/cmd/main.c	2000/05/03 03:57:42
@@ -15,6 +15,7 @@
 	struct Map_info Map;
 	struct Categories Cats;
 	int level;
+	struct Option  *dev;
 
 	/* Initialize the GIS calls */
 	G_gisinit (argv[0]) ;
@@ -30,6 +31,12 @@
 	opt1->gisprompt  = "old,dig,vector" ;
 	opt1->description= "Name of existing vector map" ;
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
 	if(G_parser(argc,argv))
 		exit(1);
 
@@ -45,7 +52,8 @@
 	}
 
 
-	R_open_driver();
+/*  	R_open_driver(); */
+	R_open_driver2(dev->answer);
 	D_setup(0);
 
 	level = Vect_open_old (&Map, name, mapset);
Index: display/d.where/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.where/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.where/cmd/main.c	1999/12/29 15:10:08	1.1.1.1
+++ display/d.where/cmd/main.c	2000/05/03 03:57:42
@@ -15,6 +15,7 @@
     int with_info;
     double a,e;
     int i;
+	struct Option  *dev;
 
 /* Initialize the GIS calls */
     G_gisinit(argv[0]) ;
@@ -30,7 +31,13 @@
     spheroid->description= "Name of a spheroid (for lat/lon coordinate conversion)";
     spheroid->options    = s_names;
 
-    *s_names = 0;
+     dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
+   *s_names = 0;
     for (i = 0; name = CC_spheroid_name(i); i++)
     {
 	if(i) strcat (s_names, ",");
@@ -63,7 +70,8 @@
 	}
     }
 
-    R_open_driver();
+/*      R_open_driver(); */
+	R_open_driver2(dev->answer);
     D_setup(0);
     where_am_i(once->answer, have_spheroid) ;
     R_close_driver();
Index: display/d.zoom/cmd/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/d.zoom/cmd/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- display/d.zoom/cmd/main.c	1999/12/29 15:10:08	1.1.1.1
+++ display/d.zoom/cmd/main.c	2000/05/03 03:57:42
@@ -16,6 +16,7 @@
     int rotate;
     struct Flag *quiet;
     struct Option *action;
+	struct Option  *dev;
 
 /* Initialize the GIS calls */
     G_gisinit(argv[0]) ;
@@ -28,6 +29,12 @@
     action->required = NO;
     action->answer = NULL; /* do NOT set a default, please */
 
+    dev              = G_define_option();
+    dev->key         = "device";
+    dev->type        = TYPE_STRING;
+    dev->required    = NO;
+    dev->description = "Graphics device";
+
     quiet = G_define_flag();
     quiet->key = 'q';
     quiet->description = "Quiet";
@@ -35,7 +42,8 @@
     if (argc > 1 && G_parser(argc,argv))
 	exit(1);
 
-    R_open_driver();
+/*      R_open_driver(); */
+	R_open_driver2(dev->answer);
 
     D_setup(0);
 
Index: display/devices/XDRIVER/XDRIVER24/Box_abs.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/devices/XDRIVER/XDRIVER24/Box_abs.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 Box_abs.c
--- display/devices/XDRIVER/XDRIVER24/Box_abs.c	1999/12/29 15:10:09	1.1.1.1
+++ display/devices/XDRIVER/XDRIVER24/Box_abs.c	2000/05/03 03:57:43
@@ -8,6 +8,7 @@
 extern Pixmap bkupmap;
 extern int backing_store;
 
+
 int Box_abs (int x1, int y1, int x2, int y2)
 {
     int tmp;
Index: display/devices/XDRIVER/XDRIVER24/Raster.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/devices/XDRIVER/XDRIVER24/Raster.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 Raster.c
--- display/devices/XDRIVER/XDRIVER24/Raster.c	1999/12/29 15:10:09	1.1.1.1
+++ display/devices/XDRIVER/XDRIVER24/Raster.c	2000/05/03 03:57:43
@@ -1,3 +1,4 @@
+/* -*-c-basic-offset: 4;-*- */
 #include <stdio.h>
 #include <stdlib.h>
 #include "includes.h"
@@ -19,8 +20,8 @@
 typedef unsigned char byte;
 XColor defs;
 int tmp = 0;
+u_long t,t2;
 
-
 /* Write 'nrows' lines of 'num' pixels contained as ints in 'array' to
  * the screen starting at the current position. 'withzeros' indicates
  * that * zero-valued pixels in array should either be written or left
@@ -28,149 +29,180 @@
  * either be written directly to the screen or used to reference a
  * color look-up table. */
 
+u_long bright(u_long pix, float dim) {
+	u_long t,t1, t2;
+	t1 = pix&0xFF;
+	if (t1 > 255) t1 = 255;
+	t  = t1*dim +0.5; 
+
+	t1 = pix&0xFF00;
+	t1 = t1>>8;
+	t1 = t1*dim +0.5;
+	if (t1 > 255) t1 = 255;
+	t += (t1&0xFF)<<8;
+
+	t1 = pix&0xFF0000;
+	t1 = t1>>16;
+	t1 = t1*dim +0.5;
+	if (t1 > 255) t1 = 255;
+	t += (t1&0xFF)<<16;
+
+	t1 = pix&0xFF000000;
+	t1 = t1>>24;
+	t1 = t1*dim +0.5;
+	if (t1 > 255) t1 = 255;
+	t += (t1&0xFF)<<24;
+
+	return t;
+}
 int 
 Raster_int (int num, int nrows, unsigned int *array, int withzeros, int color_type)
 {
-    int i, j;
-    unsigned int *arr ;
-    XWindowAttributes xwa;
-    int bytes_per_pixel;
-    int offset = 0 ;
-    if (! offset)
-        offset = get_color_offset() + get_max_std_colors() ;
-
-
-    /* Unless this is 1st time thru or if raster line length has
-         * changed we don't need to reallocate space or re-create the
-         * Ximage. */
-    if (alloc < num) {
-	int pad;
-        if (gotimage) {
-            XDestroyImage(grimage);     /* destroy any previous images */
-            gotimage = 0;
-        }
-        if (XGetWindowAttributes(dpy, grwin, &xwa) == 0)
-            return (-1);
-	if (xwa.depth > 8 ) pad = 32;
-	else pad = 8;
-        grimage = XCreateImage(dpy, xwa.visual, xwa.depth, ZPixmap,
-            0, None, num, 1, pad, 0);
-        gotimage = 1;
+	int i, j;
+	unsigned int *arr ;
+	XWindowAttributes xwa;
+	int bytes_per_pixel;
+	int offset = 0 ;
+
+	if (! offset)
+		offset = get_color_offset() + get_max_std_colors() ;
+
+
+	/* Unless this is 1st time thru or if raster line length has
+	 * changed we don't need to reallocate space or re-create the
+	 * Ximage. */
+	if (alloc < num) {
+		int pad;
+		if (gotimage) {
+			XDestroyImage(grimage);     /* destroy any previous images */
+			gotimage = 0;
+		}
+		if (XGetWindowAttributes(dpy, grwin, &xwa) == 0)
+			return (-1);
+		if (xwa.depth > 8 ) pad = 32;
+		else pad = 8;
+		grimage = XCreateImage(dpy, xwa.visual, xwa.depth, ZPixmap,
+							   0, None, num, 1, pad, 0);
+		gotimage = 1;
 #ifdef DEBUG
-{
-static int first = 1;
-if (first) {
-fprintf (stdout,"visual = %d, depth = %d\n",xwa.visual->class,xwa.depth);
-fprintf (stdout,"ximage->width = %d\n",grimage->width);
-fprintf (stdout,"ximage->height = %d\n",grimage->height);
-fprintf (stdout,"ximage->xoffset = %d\n",grimage->xoffset);
-fprintf (stdout,"ximage->format = %d\n",grimage->format);
-fprintf (stdout,"ximage->byte_order %d\n",grimage->byte_order);
-fprintf (stdout,"ximage->bitmap_unit = %d\n",grimage->bitmap_unit);
-fprintf (stdout,"ximage->bitmap_bit_order = %d\n",grimage->bitmap_bit_order);
-fprintf (stdout,"ximage->bitmap_pad = %d\n",grimage->bitmap_pad);
-fprintf (stdout,"ximage->depth = %d\n",grimage->depth);
-fprintf (stdout,"ximage->bytes_per_line = %d\n",grimage->bytes_per_line);
-fprintf (stdout,"ximage->bits_per_pixel = %d\n",grimage->bits_per_pixel);
-fprintf (stdout,"ximage->red_mask = %d\n",grimage->red_mask);
-fprintf (stdout,"ximage->green_mask = %d\n",grimage->green_mask);
-fprintf (stdout,"ximage->blue_mask = %d\n",grimage->blue_mask);
-first = 0;
-}}
+		{
+			static int first = 1;
+			if (first) {
+				fprintf (stdout,"visual = %d, depth = %d\n",xwa.visual->class,xwa.depth);
+				fprintf (stdout,"ximage->width = %d\n",grimage->width);
+				fprintf (stdout,"ximage->height = %d\n",grimage->height);
+				fprintf (stdout,"ximage->xoffset = %d\n",grimage->xoffset);
+				fprintf (stdout,"ximage->format = %d\n",grimage->format);
+				fprintf (stdout,"ximage->byte_order %d\n",grimage->byte_order);
+				fprintf (stdout,"ximage->bitmap_unit = %d\n",grimage->bitmap_unit);
+				fprintf (stdout,"ximage->bitmap_bit_order = %d\n",grimage->bitmap_bit_order);
+				fprintf (stdout,"ximage->bitmap_pad = %d\n",grimage->bitmap_pad);
+				fprintf (stdout,"ximage->depth = %d\n",grimage->depth);
+				fprintf (stdout,"ximage->bytes_per_line = %d\n",grimage->bytes_per_line);
+				fprintf (stdout,"ximage->bits_per_pixel = %d\n",grimage->bits_per_pixel);
+				fprintf (stdout,"ximage->red_mask = %d\n",grimage->red_mask);
+				fprintf (stdout,"ximage->green_mask = %d\n",grimage->green_mask);
+				fprintf (stdout,"ximage->blue_mask = %d\n",grimage->blue_mask);
+				fprintf (stdout,"color_type = %d. FLOAT?%d\n",color_type, (get_table_type() == FLOAT));
+				first = 0;
+			}
+		}
 #endif
-        bytes_per_pixel = (grimage->bits_per_pixel + 7)/8;
-        if (alloc == 0)
-            grimage->data =  malloc(num * bytes_per_pixel);
-        else
-            grimage->data =  realloc(grimage->data, num * bytes_per_pixel);
-        if (grimage->data == NULL)
-            return (-1);        /* not enough space left */
-    }
+		bytes_per_pixel = (grimage->bits_per_pixel + 7)/8;
+		if (alloc == 0)
+			grimage->data =  malloc(num * bytes_per_pixel);
+		else
+			grimage->data =  realloc(grimage->data, num * bytes_per_pixel);
+		if (grimage->data == NULL)
+			return (-1);        /* not enough space left */
+	}
 /* If zeros are to be included, an entire raster row can be constructed */
-    if (withzeros) {
-        char *pix;
+	if (withzeros) {
+		char *pix;
 
-        if (color_type)
-            _get_color_index_array(array, num) ;
+		if (color_type)
+			_get_color_index_array(array, num) ;
 
-        arr = array;
-        pix = grimage->data;
-        if (get_table_type() == FLOAT) {
-	    for (i = 0; i < num; i++)
-		XPutPixel(grimage, i, 0, (u_long) *arr++);
-        }
-        else {
-	    for (i = 0; i < num; i++)
-		XPutPixel(grimage, i, 0, (u_long) xpixels[*arr++]);
-        }
-
-        for (i = 0; i < nrows; i++) {
-            XPutImage(dpy, grwin, gc, grimage, 0, 0, cur_x, cur_y + i, num, 1);
-            if (!backing_store) {
-                XPutImage(dpy, bkupmap, gc, grimage, 0, 0, cur_x, cur_y + i,
-                    num, 1);
-            }
-        }
-    }
-    /* If zeros are not included may need to draw many shorter rasters.
-         * If the pixel value in array is zero we don't disturb the
-         * existing pixel of the drawable. If the pixel is non-zero we
-         * re-write it. */
-    else {
-        int start_col, width;
-
-        arr = array;
-        start_col = 0;
-        width = 0;
-        for (j = 0; j < num; j++) {
-            if (*arr == 0) {
-                if (width > 0) {
-                    for (i = 0; i < nrows; i++) {
-                        XPutImage(dpy, grwin, gc, grimage, 0, 0,
-                            cur_x + start_col, cur_y + i, width, 1);
-                        if (!backing_store)
-                            XPutImage(dpy, bkupmap, gc, grimage, 0, 0,
-                                cur_x + start_col, cur_y + i, width, 1);
-                    }
-                    width = 0;
-                    start_col = j + 1;
-                } else {
-                    start_col++;
-                }
-            } else {            /* non-zero pixel, put into the image */
-                if (get_table_type() == FLOAT) {
-                    if ( color_type )
-                        XPutPixel(grimage, width++, 0,
-                            (u_long) _get_color_index(*arr));
-                    else 
-                        XPutPixel(grimage, width++, 0,
-                            (u_long) *arr);
-                } else {
-                    if ( color_type )
-                        XPutPixel(grimage, width++, 0,
-                            (u_long) xpixels[_get_color_index(*arr)]);
-                        else
-                        XPutPixel(grimage, width++, 0,
-                            (u_long) xpixels[_get_color_index(*arr)]);
-                }
-            }
-            arr++;
-        }
-        /* Flush out any remaining data */
-        if (width > 0) {
-            for (i = 0; i < nrows; i++) {
-                XPutImage(dpy, grwin, gc, grimage, 0, 0,
-                    cur_x + start_col, cur_y + i, width, 1);
-                if (!backing_store)
-                    XPutImage(dpy, bkupmap, gc, grimage, 0, 0,
-                        cur_x + start_col, cur_y + i, width, 1);
-            }
-        }
-    }
-    return 1;
+		arr = array;
+		pix = grimage->data;
+		if (get_table_type() == FLOAT) {
+			for (i = 0; i < num; i++) {
+				XPutPixel(grimage, i, 0, (u_long) *arr++);
+			}
+		}
+		else {
+			for (i = 0; i < num; i++) {
+				XPutPixel(grimage, i, 0, (u_long) xpixels[*arr++]);
+			}
+		}
+
+		for (i = 0; i < nrows; i++) {
+			XPutImage(dpy, grwin, gc, grimage, 0, 0, cur_x, cur_y + i, num, 1);
+			if (!backing_store) {
+				XPutImage(dpy, bkupmap, gc, grimage, 0, 0, cur_x, cur_y + i,
+						  num, 1);
+			}
+		}
+	}
+	/* If zeros are not included may need to draw many shorter rasters.
+	 * If the pixel value in array is zero we don't disturb the
+	 * existing pixel of the drawable. If the pixel is non-zero we
+	 * re-write it. */
+	else {
+		int start_col, width;
+
+		arr = array;
+		start_col = 0;
+		width = 0;
+		for (j = 0; j < num; j++) {
+			if (*arr == 0) {
+				if (width > 0) {
+					for (i = 0; i < nrows; i++) {
+						XPutImage(dpy, grwin, gc, grimage, 0, 0,
+								  cur_x + start_col, cur_y + i, width, 1);
+						if (!backing_store)
+							XPutImage(dpy, bkupmap, gc, grimage, 0, 0,
+									  cur_x + start_col, cur_y + i, width, 1);
+					}
+					width = 0;
+					start_col = j + 1;
+				} else {
+					start_col++;
+				}
+			} else {            /* non-zero pixel, put into the image */
+				if (get_table_type() == FLOAT) {
+					if ( color_type )
+						XPutPixel(grimage, width++, 0,
+								  (u_long) _get_color_index(*arr));
+					else 
+						XPutPixel(grimage, width++, 0,
+								  (u_long) *arr);
+				} else {
+					if ( color_type )
+						XPutPixel(grimage, width++, 0,
+								  (u_long) xpixels[_get_color_index(*arr)]);
+					else
+						XPutPixel(grimage, width++, 0,
+								  (u_long) xpixels[_get_color_index(*arr)]);
+				}
+			}
+			arr++;
+		}
+		/* Flush out any remaining data */
+		if (width > 0) {
+			for (i = 0; i < nrows; i++) {
+				XPutImage(dpy, grwin, gc, grimage, 0, 0,
+						  cur_x + start_col, cur_y + i, width, 1);
+				if (!backing_store)
+					XPutImage(dpy, bkupmap, gc, grimage, 0, 0,
+							  cur_x + start_col, cur_y + i, width, 1);
+			}
+		}
+	}
+	return 1;
 }
 
 static int do_nothing(int n)
 {
-    return (n);
+	return (n);
 }
Index: display/devices/XDRIVER/XDRIVER24/SWITCHER.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/devices/XDRIVER/XDRIVER24/SWITCHER.c,v
retrieving revision 1.3
diff -u -r1.3 SWITCHER.c
--- display/devices/XDRIVER/XDRIVER24/SWITCHER.c	2000/04/12 10:19:26	1.3
+++ display/devices/XDRIVER/XDRIVER24/SWITCHER.c	2000/05/03 03:57:44
@@ -79,9 +79,11 @@
 
 #define LOOP_PER_SERVICE 15
 
+
 int main (int argc, char *argv[])
 {
     char c, lc = 0;
+	unsigned char layer,param;
     char name[200], text[1024];
     float wx;
     int *xarray = NULL, *yarray = NULL;
@@ -917,6 +919,35 @@
                         sendtext(item->name);
                 sendtext("");
                 break;
+           case CONNECTION_BEGIN:
+                break;
+            case CONNECTION_END:
+                break;
+            case UNDO_DRAWING:
+                break;
+            case LAYER_SELECT:
+                REC(&layer, sizeof layer);
+				break;
+            case LAYER_SHOW:
+                REC(&layer, sizeof layer);
+				break;
+            case LAYER_HIDE:
+                REC(&layer, sizeof layer);
+				break;
+            case LAYER_SOLO:
+                REC(&layer, sizeof layer);
+				break;
+            case LAYER_ALL_VISIBLES:
+				break;
+            case LAYER_ALL:
+				break;
+            case LAYER_GET_CURRENT:
+				layer = 0;
+				SEND(&layer, sizeof layer);
+				break;
+            case LAYER_ERASE:
+                REC(&layer, sizeof layer);
+				break;
 
             default:
                 fprintf(stderr, "\nUnknown command: %d last: %d", c, lc);
Index: display/devices/XDRIVER/XDRIVER24/version.h
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/devices/XDRIVER/XDRIVER24/version.h,v
retrieving revision 1.2
diff -u -r1.2 version.h
--- display/devices/XDRIVER/XDRIVER24/version.h	2000/04/12 10:21:01	1.2
+++ display/devices/XDRIVER/XDRIVER24/version.h	2000/05/03 03:57:44
@@ -1 +1 @@
-#define WIN_NAME "GRASS 5.0beta7"
+#define WIN_NAME "GRASS 5.0beta8"
Index: display/devices/XDRIVER/lib/graph.h
===================================================================
RCS file: /home/grass/grassrepository/grass/src/display/devices/XDRIVER/lib/graph.h,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 graph.h
--- display/devices/XDRIVER/lib/graph.h	1999/12/29 15:10:11	1.1.1.1
+++ display/devices/XDRIVER/lib/graph.h	2000/05/03 03:57:44
@@ -1,89 +1,6 @@
-/* command esc character set to have most bits (but not all) set to 1 */
+/* -*- c-basic-offset: 4; -*-
 
-#define COMMAND_ESC 127
+/* changed to use the main "graph.h" in the grass libes/raster directory  */
+/* Pierre de Mouveaux - 2 may 2000 */
 
-/* BEGIN sync count This is number of zero bytes to be returned by
- * driver in response to a BEGIN request */
-
-#define BEGIN_SYNC_COUNT 32
-
-/* command tokens note: none should be zero, or equal to COMMAND_ESC */
-
-#define GET_NUM_COLORS              1
-#define COLOR                       2
-#define COLOR_PRINT                 3
-#define CONT_ABS                    4
-#define CONT_REL                    5
-#define RGB_COLOR                   6
-#define ERASE                       7
-#define GET_LOCATION_WITH_BOX       8
-#define GET_LOCATION_WITH_LINE      9
-#define GET_LOCATION_WITH_POINTER   10
-#define GRAPH_CLOSE                 11
-#define LINEMOD                     12
-#define MOVE_ABS                    13
-#define MOVE_REL                    14
-#define POLYGON_ABS                 15
-#define POLYGON_REL                 16
-#define POLYLINE_ABS                17
-#define POLYLINE_REL                18
-#define POLYDOTS_ABS                19
-#define POLYDOTS_REL                20
-#define RASTER_CHAR                 21
-#define RASTER_INT                  22
-#define RESET_COLORS                23
-#define RESET_COLOR                 24
-#define SCREEN_LEFT                 25
-#define SCREEN_RITE                 26
-#define SCREEN_BOT                  27
-#define SCREEN_TOP                  28
-#define TEXT                        29
-#define TEXT_SIZE                   30
-#define _____UNUSED_1               31
-#define _____UNUSED_2               32
-#define _____UNUSED_3               33
-#define _____UNUSED_4               34
-#define _____UNUSED_5               35
-#define COLOR_TABLE_FIXED           36
-#define COLOR_TABLE_FLOAT           37
-#define COLOR_OFFSET                38
-#define TEXT_ROTATION               39
-#define SET_WINDOW                  40
-#define _____UNUSED_6               41
-#define GET_TEXT_BOX                42
-#define ZRASTER                     43
-#define FONT                        44
-#define RESPOND                     45
-#define BEGIN                       46
-#define STANDARD_COLOR              47
-#define BOX_ABS                     48
-#define BOX_REL                     49
-#define RGB_RASTER                  50
-#define _____UNUSED_7               51
-#define RGB_COLORS                  52
-#define PANEL_SAVE                  53
-#define PANEL_RESTORE               54
-#define PANEL_DELETE                55
-
-#define PAD_CREATE                  61
-#define PAD_CURRENT                 62
-#define PAD_DELETE                  63
-#define PAD_INVENT                  64
-#define PAD_LIST                    65
-#define PAD_SELECT                  66
-
-#define PAD_APPEND_ITEM             71
-#define PAD_DELETE_ITEM             72
-#define PAD_GET_ITEM                73
-#define PAD_LIST_ITEMS              74
-#define PAD_SET_ITEM                75
-
-/* return codes for pad routines */
-
-#define OK 0
-#define NO_MEMORY 1
-#define NO_PAD 2
-#define NO_CUR_PAD 3
-#define NO_ITEM 4
-#define DUPLICATE 5
-#define ILLEGAL 6
+#include "../../../../libes/raster/graph.h"
Index: imagery/i.rectify/main.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/imagery/i.rectify/main.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 main.c
--- imagery/i.rectify/main.c	1999/12/29 15:10:21	1.1.1.1
+++ imagery/i.rectify/main.c	2000/05/03 03:57:48
@@ -3,8 +3,9 @@
 
 int main (int argc, char *argv[])
 {
-    char group[30];
+/*      char group[30]; */
     int n;
+	char group[30];
 
     setbuf (stdout, NULL);
     setbuf (stderr, NULL);
Index: include/gis.h
===================================================================
RCS file: /home/grass/grassrepository/grass/src/include/gis.h,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 gis.h
--- include/gis.h	1999/12/29 15:10:23	1.1.1.1
+++ include/gis.h	2000/05/03 03:57:50
@@ -324,6 +324,7 @@
 #define TYPE_INTEGER  1
 #define TYPE_DOUBLE   2
 #define TYPE_STRING   3
+#define TYPE_COLOR    4
 #define YES           1
 #define NO            0
 
Index: libes/D/Derase.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/D/Derase.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 Derase.c
--- libes/D/Derase.c	1999/12/29 15:10:24	1.1.1.1
+++ libes/D/Derase.c	2000/05/03 03:57:50
@@ -14,11 +14,19 @@
 		G_fatal_error("clearing current graphics window") ;
 
 	/* Do the plotting */
+
 	R_standard_color(D_translate_color(color)) ;
-	R_box_abs (l, t, r, b);
+	R_erase();
+
+/*  	R_box_abs (l, t, r, b); */
+
+/*  	R_erase(); */
 
 	/* Add erase item to the pad */
+
 	D_set_erase_color(color);
+
+
 
 	return 0;
 }
Index: libes/display/setup.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/display/setup.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 setup.c
--- libes/display/setup.c	1999/12/29 15:10:26	1.1.1.1
+++ libes/display/setup.c	2000/05/03 03:57:51
@@ -69,3 +69,4 @@
     D_move_abs(0,0);
     return 0;
 }
+
Index: libes/display/tran_colr.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/display/tran_colr.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 tran_colr.c
--- libes/display/tran_colr.c	1999/12/29 15:10:26	1.1.1.1
+++ libes/display/tran_colr.c	2000/05/03 03:57:51
@@ -1,12 +1,48 @@
 /* Takes a color name in ascii, returns the color number for that color.
  *    returns 0 if color is not known.
  */
+/* updated to support rvb in the forme R:G:B
+ * and alpha chanel in th form A:R:G:B
+ *
+ * Pierre de Mouveaux - 25 april 2000.
+ */
 
 #include "display.h"
 #include "colors.h"
 
+#include <stdio.h>
+
+#define TRANSPARENT 0x01000000
+
 int D_translate_color(char *str )
 {
+	int a,r,v,b;
+	if (sscanf(str,"%d:%d:%d:%d",&a,&r,&v,&b) == 4) {
+		if (a<1)	a=1;
+		if (a>255)	a=255;	
+		if (r<0) 	r=0;
+		if (r>255)	r=255;
+		if (v<0) 	v=0;
+		if (v>255)	v=255;
+		if (b<0) 	b=0;
+		if (b>255)	b=255;		
+		return ((a<<24)+(r<<16)+(v<<8)+b);
+	}
+	else if (sscanf(str,"%d:%d:%d",&r,&v,&b) == 3) {
+		if (r<0) 	r=0;
+		if (r>255)	r=255;
+		if (v<0) 	v=0;
+		if (v>255)	v=255;
+		if (b<0) 	b=0;
+		if (b>255)	b=255;
+		return (TRANSPARENT+(r<<16)+(v<<8)+b);
+	} 
+	else if (sscanf(str,"%d:",&r) == 1) {
+		if (r<0) 	r=0;
+		if (r>255)	r=255;
+		return (TRANSPARENT+(r<<16)+(r<<8)+r);
+	} 
+	
 	if (! strcmp(str, "red"))
 		return(RED) ;
 	if (! strcmp(str, "orange"))
@@ -42,5 +78,6 @@
 	if (! strcmp(str, "gray"))
 		return(GRAY) ;
 	
-	return(0) ;
+	return(GRAY) ;		/* VISIBLE both on black and on white */
+/*  	return(0) ; */
 }
Index: libes/gis/get_window.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/gis/get_window.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 get_window.c
--- libes/gis/get_window.c	1999/12/29 15:10:30	1.1.1.1
+++ libes/gis/get_window.c	2000/05/03 03:57:52
@@ -35,8 +35,8 @@
 
 	if(err = G__get_window (&dbwindow,"","WIND",G_mapset()))
 	{
-	    free (err);
 	    G_fatal_error ("region for current mapset %s\nrun \"g.region\"", err);
+	    free (err);
 	}
     }
 
@@ -58,8 +58,8 @@
 
     if (err = G__get_window (window,"","DEFAULT_WIND","PERMANENT"))
     {
-	free (err);
 	G_fatal_error ("default region %s", err);
+	free (err);
     }
     return 1;
 }
Index: libes/gis/named_colr.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/gis/named_colr.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 named_colr.c
--- libes/gis/named_colr.c	1999/12/29 15:10:30	1.1.1.1
+++ libes/gis/named_colr.c	2000/05/03 03:57:53
@@ -16,6 +16,7 @@
     {"magenta",	1.00, 0.00, 1.00},
     {"cyan",	0.00, 1.00, 1.00},
     {"aqua",    0.00, 0.75, 0.75},
+    {"lt-grey",	0.5, 0.5, 0.5},
     {"grey",	0.75, 0.75, 0.75},
     {"gray",	0.75, 0.75, 0.75},
     {"orange",	1.00, 0.50, 0.00},
@@ -29,18 +30,52 @@
 
 int G_color_values (
     char *name,
-    float *r,float *g,float *b)
+    float *fr,float *fg,float *fb)
 {
-    int i;
+    int i, a,r,v,b;
 
-    *r = *g = *b = 0.0;
+    *fr = *fg = *fb = 0.0;
     for (i = 0; colors[i].name[0]; i++)
 	if (strcmp (name, colors[i].name) == 0)
 	{
-	    *r = colors[i].r;
-	    *g = colors[i].g;
-	    *b = colors[i].b;
+	    *fr = colors[i].r;
+	    *fg = colors[i].g;
+	    *fb = colors[i].b;
 	    return 1;
+	}
+	else if (sscanf(name,"%d:%d:%d:%d",&a,&r,&v,&b)==4) {
+/*  		if (a<1)	a=1; */
+/*  		if (a>255)	a=255;	 */
+		if (r<0) 	r=0;
+		if (r>255)	r=255;
+		if (v<0) 	v=0;
+		if (v>255)	v=255;
+		if (b<0) 	b=0;
+		if (b>255)	b=255;		
+		*fr=r/255.0;
+		*fg=v/255.0;
+		*fb=b/255.0;
+		return 1;
+	}
+	else if (sscanf(name,"%d:%d:%d",&r,&v,&b)==3) {
+		if (r<0) 	r=0;
+		if (r>255)	r=255;
+		if (v<0) 	v=0;
+		if (v>255)	v=255;
+		if (b<0) 	b=0;
+		if (b>255)	b=255;		
+		*fr=r/255.0;
+		*fg=v/255.0;
+		*fb=b/255.0;
+		return 1;
+	}
+	else if (sscanf(name,"%d:",&r)==1) {
+		if (r<0) 	r=0;
+		if (r>255)	r=255;
+		*fr=r/255.0;
+		*fg=*fr;
+		*fb=*fr;
+		return 1;
 	}
     return -1;
 }
Index: libes/gis/parser.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/gis/parser.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 parser.c
--- libes/gis/parser.c	1999/12/29 15:10:30	1.1.1.1
+++ libes/gis/parser.c	2000/05/03 03:57:55
@@ -645,9 +645,14 @@
 	opt= &first_option;
 	while(opt != NULL)
 	{
-		/* Check answer against options if any */
+
+		/* Check answer against user's check subroutine if any */
+
+		if(opt->checker)
+			error += opt->checker(opt->answer) ;
 
-		if(opt->options && opt->answer)
+		/* Check answer against options if any */
+		else if(opt->options && opt->answer)
 		{
 			if(opt->multiple == 0)
 				error += check_an_opt(opt->key, opt->type,
@@ -686,6 +691,9 @@
 		break ;
 	case TYPE_STRING:
 		error = check_string(answer,options) ;
+		break ;
+	case TYPE_COLOR:
+/*  			error = check_string(answer,options) ; */
 		break ;
 /*
 	case TYPE_COORDINATE:
Index: libes/gis/set_window.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/gis/set_window.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 set_window.c
--- libes/gis/set_window.c	1999/12/29 15:10:31	1.1.1.1
+++ libes/gis/set_window.c	2000/05/03 03:57:55
@@ -93,32 +93,32 @@
 	    G__create_window_mapping (i);
 /* code commented 10/1999 due to problems */
 /*      else */
-        /* opened for writing */
-/*      {
-            free(G__.fileinfo[i].data);
-            G__.fileinfo[i].data = (unsigned char *) G_calloc (G__.window.cols,
-                 G_raster_size(G__.fileinfo[i].map_type));
-        }
-*/
-        /* allocate null bitstream buffers for reading/writing null rows */
-/*      for (j=0;j< NULL_ROWS_INMEM; j++)
-        {
-           free(G__.fileinfo[i].NULL_ROWS[j]);
-           G__.fileinfo[i].NULL_ROWS[j] = G__allocate_null_bits(G__.window.cols);
-        }
-*/
+	/* opened for writing */ 
+/*        { */
+/*              free(G__.fileinfo[i].data); */
+/*              G__.fileinfo[i].data = (unsigned char *) G_calloc (G__.window.cols, */
+/*                   G_raster_size(G__.fileinfo[i].map_type)); */
+/*          } */
 
-        /* initialize : no NULL rows in memory */
-/*      G__.fileinfo[i].min_null_row = (-1) * NULL_ROWS_INMEM;
-        if(G__.fileinfo[i].null_cur_row > 0)
-        {
-            G_warning(
-             "Calling G_set_window() in the middle of writing map %s", 
-                       G__.fileinfo[i].name);
-            G__.fileinfo[i].null_cur_row = 0;
-        }
-*/
-    }
+        /* allocate null bitstream buffers for reading/writing null rows
+/*        for (j=0;j< NULL_ROWS_INMEM; j++) */
+/*          { */
+/*             free(G__.fileinfo[i].NULL_ROWS[j]); */
+/*             G__.fileinfo[i].NULL_ROWS[j] = G__allocate_null_bits(G__.window.cols); */
+/*          } */
+
+
+        /* initialize : no NULL rows in memory
+/*        G__.fileinfo[i].min_null_row = (-1) * NULL_ROWS_INMEM; */
+/*          if(G__.fileinfo[i].null_cur_row > 0) */
+/*          { */
+/*              G_warning( */
+/*               "Calling G_set_window() in the middle of writing map %s",  */
+/*                         G__.fileinfo[i].name); */
+/*              G__.fileinfo[i].null_cur_row = 0; */
+/*          } */
+
+    } 
 
 /* turn masking (back) on if necessary */
     G__check_for_auto_masking ();
Index: libes/gis/version.h
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/gis/version.h,v
retrieving revision 1.3
diff -u -r1.3 version.h
--- libes/gis/version.h	2000/04/20 13:03:41	1.3
+++ libes/gis/version.h	2000/05/03 03:57:55
@@ -1 +1 @@
-static char *VERSION_STRING = "@(#) GRASS 5.0beta7 (April 2000)";
+static char *VERSION_STRING = "@(#) GRASS 5.0beta8 (May 2000)";
Index: libes/raster/Color.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/raster/Color.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 Color.c
--- libes/raster/Color.c	1999/12/29 15:10:41	1.1.1.1
+++ libes/raster/Color.c	2000/05/03 03:57:57
@@ -1,6 +1,27 @@
+/* updated to support RGB colors. 
+ * the 3 lower bytes are R,G and B.
+ * the higher byte (int assumed >=32bits)
+ * is alpha channel (not use for the moment).
+ * To be compatible with the "Standard Color" 
+ * scheme, I use the alpha channel value to diferenciate
+ * between indexed standard colors, and RVB composantes.
+ * The minimun value for alpha is set to 1. (will be considered
+ * equivalent to 0, when alpha blending will be used).
+ * So, if alpha channel == 0, the value is 
+ * not considered an RVB or A-RVB, but rathe the index
+ * of a standard color, in the usual way. 
+ *
+ * Pierre de Mouveaux - 25 april 2000.
+ */
+
 #include "raster.h"
 #include "graph.h"
 
+#define R_MASK 			0x00FF0000
+#define G_MASK 			0x0000FF00
+#define B_MASK 			0x000000FF
+#define TRANSPARENT 	0x01000000
+
 int R_color(int index)
 {
 	int i ;
@@ -14,9 +35,13 @@
 int R_standard_color(int index)
 {
 	int i ;
-	i = index ;
-	_send_ident(STANDARD_COLOR) ;
-	_send_int(&i) ;
-
+	if ((unsigned int)index < TRANSPARENT ) {
+		i = index ;
+		_send_ident(STANDARD_COLOR) ;
+		_send_int(&i) ;
+	} else {
+		unsigned int color = (unsigned int)index;
+		R_RGB_color((color&R_MASK)>>16,(color&G_MASK)>>8,color&B_MASK);
+	}
 	return 0;
 }
Index: libes/raster/graph.h
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/raster/graph.h,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 graph.h
--- libes/raster/graph.h	1999/12/29 15:10:41	1.1.1.1
+++ libes/raster/graph.h	2000/05/03 03:57:57
@@ -86,6 +86,17 @@
 #define PAD_GET_ITEM                73
 #define PAD_LIST_ITEMS              74
 #define PAD_SET_ITEM                75
+#define CONNECTION_BEGIN            76
+#define CONNECTION_END				77
+#define UNDO_DRAWING				78
+#define LAYER_SELECT				79
+#define	LAYER_SHOW					80
+#define	LAYER_HIDE					81
+#define LAYER_SOLO					82
+#define	LAYER_ALL_VISIBLES			83
+#define LAYER_ALL					84
+#define	LAYER_GET_CURRENT			85
+#define	LAYER_ERASE					86
 
 /* return codes for pad routines */
 
Index: libes/raster/io.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/raster/io.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 io.c
--- libes/raster/io.c	1999/12/29 15:10:41	1.1.1.1
+++ libes/raster/io.c	2000/05/03 03:57:59
@@ -174,34 +174,32 @@
 /* return a code and no messages are printed.  The flag quiet is set */
 /* by calling R__open_quiet just before calling R_open_driver. */
 /* Returns in quiet mode opens are defined in open.h */
-
+/*  R_open_driver2() added Pierre de Mouveaux pmx@audiovu.com 24 april 2000 */
 #include "open.h"
 static int quiet = 0;        /* #9 Sep 87 */
 
 
-int R_open_driver()
+int R_open_driver2(char* name)
 {
     int verbose;
     int try, key, lock;
     char our_input_file[512], our_output_file[512];
     struct MON_CAP *mon, *R_parse_monitorcap();
-    char *name, *G__getenv(), *getenv(), *key_string;
+    char *G__getenv(), *getenv(), *key_string;
     char *user, *who_locked_driver();
     struct stat stat_buf;
 
     verbose = !quiet;
     quiet = 0;
-    if ((name = G__getenv("MONITOR")) == NULL)
-    {
-        if (verbose)           /* #31 Aug 87 - want error stuff */
-        {
-            fprintf(stderr,"No graphics monitor has been selected for output.\n");
-            fprintf(stderr,"Please run \"d.mon\" to select a graphics monitor.\n");
-            exit(-1);
-        }
-	return(NO_MON);
-    }
 
+	if (name == NULL) {
+			return R_open_driver();
+	}
+
+	if (strlen(name) == 0) {
+			return R_open_driver();
+	}
+
     if ((mon = R_parse_monitorcap(MON_NAME,name)) == NULL)
     {
 	if (verbose)
@@ -296,6 +294,31 @@
     }
 
     return 0;
+}
+
+int R_open_driver()
+{
+	char *name;
+    int verbose;
+
+    verbose = !quiet;
+    quiet = 0;
+    if ((name = G__getenv("MONITOR")) == NULL)
+    {
+        if (verbose)           /* #31 Aug 87 - want error stuff */
+        {
+            fprintf(stderr,"No graphics monitor has been selected for output.\n");
+            fprintf(stderr,"Please run \"d.mon\" to select a graphics monitor.\n");
+            exit(-1);
+        }
+        else
+        {
+            return(NO_MON);
+        }
+    }
+	
+	R_open_driver2(name);
+
 }
 
 int R__open_quiet()
Index: libes/raster/new_io.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/libes/raster/new_io.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 new_io.c
--- libes/raster/new_io.c	1999/12/29 15:10:41	1.1.1.1
+++ libes/raster/new_io.c	2000/05/03 03:57:59
@@ -155,6 +155,7 @@
 
     verbose = !quiet;
     quiet = 0;
+
     if ((name = G__getenv("MONITOR")) == NULL)
     {
         if (verbose)           /* #31 Aug 87 - want error stuff */
@@ -168,8 +169,7 @@
             return(NO_MON);
         }
     }
-    else
-    {
+    else {
         if ((mon = R_parse_monitorcap(MON_NAME,name)) == NULL)
         {
             if (verbose)
Index: raster/r.binfer/gram.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.binfer/gram.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 gram.c
--- raster/r.binfer/gram.c	1999/12/29 15:11:06	1.1.1.1
+++ raster/r.binfer/gram.c	2000/05/03 03:58:09
@@ -1,6 +1,5 @@
 #ifndef lint
-/*static char yysccsid[] = "from: @(#)yaccpar	1.9 (Berkeley) 02/21/93";*/
-static char yyrcsid[] = "$Id$";
+static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
 #endif
 #define YYBYACC 1
 #define YYMAJOR 1
@@ -34,7 +33,7 @@
 typedef union {
     char *y_sym;
 } YYSTYPE;
-#line 38 "y.tab.c"
+#line 37 "y.tab.c"
 #define Identifier 257
 #define String 258
 #define Constant 259
@@ -334,17 +333,13 @@
 
 
 #include <stdio.h>
-#line 338 "y.tab.c"
+#line 337 "y.tab.c"
 #define YYABORT goto yyabort
 #define YYREJECT goto yyabort
 #define YYACCEPT goto yyaccept
 #define YYERROR goto yyerrlab
 int
-#if defined(__STDC__)
-yyparse(void)
-#else
 yyparse()
-#endif
 {
     register int yym, yyn, yystate;
 #if YYDEBUG
@@ -368,7 +363,7 @@
     *yyssp = yystate = 0;
 
 yyloop:
-    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
+    if (yyn = yydefred[yystate]) goto yyreduce;
     if (yychar < 0)
     {
         if ((yychar = yylex()) < 0) yychar = 0;
@@ -408,6 +403,10 @@
         goto yyreduce;
     }
     if (yyerrflag) goto yyinrecovery;
+#ifdef lint
+    goto yynewerror;
+#endif
+yynewerror:
     yyerror("syntax error");
 #ifdef lint
     goto yyerrlab;
@@ -960,7 +959,7 @@
 #line 508 "binfer.y"
 { yyerrok; }
 break;
-#line 964 "y.tab.c"
+#line 963 "y.tab.c"
     }
     yyssp -= yym;
     yystate = *yyssp;
Index: raster/r.binfer/lex.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.binfer/lex.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 lex.c
--- raster/r.binfer/lex.c	1999/12/29 15:11:06	1.1.1.1
+++ raster/r.binfer/lex.c	2000/05/03 03:58:13
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header$
+ * $Header$
  */
 
 #define FLEX_SCANNER
@@ -261,11 +261,16 @@
 
 #define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
 
+
+#define YY_USES_REJECT
 typedef unsigned char YY_CHAR;
 FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
 typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
+#define YY_FLEX_LEX_COMPAT
+extern int yylineno;
+int yylineno = 1;
+extern char yytext[];
+
 
 static yy_state_type yy_get_previous_state YY_PROTO(( void ));
 static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
@@ -280,24 +285,49 @@
 	yyleng = (int) (yy_cp - yy_bp); \
 	yy_hold_char = *yy_cp; \
 	*yy_cp = '\0'; \
+	if ( yyleng + yy_more_offset >= YYLMAX ) \
+		YY_FATAL_ERROR( "token too large, exceeds YYLMAX" ); \
+	yy_flex_strncpy( &yytext[yy_more_offset], yytext_ptr, yyleng + 1 ); \
+	yyleng += yy_more_offset; \
+	yy_prev_more_offset = yy_more_offset; \
+	yy_more_offset = 0; \
 	yy_c_buf_p = yy_cp;
 
 #define YY_NUM_RULES 23
 #define YY_END_OF_BUFFER 24
-static yyconst short int yy_accept[109] =
+static yyconst short int yy_acclist[139] =
+    {   0,
+       24,   22,   23,   20,   22,   23,   21,   23,   22,   23,
+       22,   23,   22,   23,   22,   23,   18,   22,   23,   14,
+       22,   23,   14,   22,   23,   14,   22,   23,   14,   22,
+       23,   14,   22,   23,   14,   22,   23,   14,   22,   23,
+       14,   22,   23,   20,   15,   16,   19,   18,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   15,    1,   17,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       12,   14,   14,   14,   14,    7,   14,    6,   14,   14,
+       14,   14,   14,   10,   14,   14,   13,   14,   14,   14,
+        8,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+
+       14,   11,   14,   14,   14,   14,   14,    9,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,    4,   14,   14,   14,    5,   14,   14,   14,
+        3,   14,   14,   14,   14,   14,    2,   14
+    } ;
+
+static yyconst short int yy_accept[111] =
     {   0,
-        0,    0,   24,   22,   20,   21,   22,   22,   22,   22,
-       18,   14,   14,   14,   14,   14,   14,   14,   14,   20,
-        0,   15,    0,    0,    1,    0,   16,   19,    0,   18,
-       14,   14,   14,   14,   14,   14,   14,   14,   14,   15,
-       17,   14,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   12,   14,   14,   14,    7,    6,   14,   14,   14,
-       14,   10,   14,   13,   14,   14,    8,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   11,   14,   14,   14,
-       14,    9,   14,   14,   14,   14,   14,   14,   14,   14,
-       14,   14,   14,   14,   14,    4,   14,   14,    5,   14,
+        1,    1,    1,    2,    4,    7,    9,   11,   13,   15,
+       17,   20,   23,   26,   29,   32,   35,   38,   41,   44,
+       45,   45,   46,   46,   46,   46,   46,   47,   48,   48,
+       49,   50,   51,   52,   53,   54,   55,   56,   57,   58,
+       59,   60,   61,   62,   63,   64,   65,   66,   67,   68,
+       69,   70,   71,   73,   74,   75,   76,   78,   80,   81,
+       82,   83,   84,   86,   87,   89,   90,   91,   93,   94,
+       95,   96,   97,   98,   99,  100,  101,  102,  104,  105,
+      106,  107,  108,  110,  111,  112,  113,  114,  115,  116,
+      117,  118,  119,  120,  121,  122,  123,  125,  126,  127,
 
-       14,    3,   14,   14,   14,   14,    2,    0
+      129,  130,  131,  133,  134,  135,  136,  137,  139,  139
     } ;
 
 static yyconst int yy_ec[256] =
@@ -305,17 +335,17 @@
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    6,    7,    1,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    1,    1,    1,
-        1,    1,    1,    1,    9,   10,   11,   12,   13,   14,
-       15,   16,   17,   14,   14,   18,   19,   20,   21,   22,
-       14,   23,   24,   25,   14,   26,   27,   14,   28,   14,
-        1,   29,    1,    1,   30,    1,    9,   10,   11,   12,
-
-       13,   14,   15,   16,   17,   14,   14,   18,   19,   20,
-       21,   22,   14,   23,   24,   25,   14,   26,   27,   14,
-       28,   14,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    4,    5,    6,    1,    1,    1,    1,
+        1,    1,    1,    1,    7,    8,    1,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    1,   10,    1,
+        1,    1,    1,    1,   11,   12,   13,   14,   15,   16,
+       17,   18,   19,   16,   16,   20,   21,   22,   23,   24,
+       16,   25,   26,   27,   16,   28,   29,   16,   30,   16,
+        1,   31,    1,    1,   32,    1,   11,   12,   13,   14,
+
+       15,   16,   17,   18,   19,   16,   16,   20,   21,   22,
+       23,   24,   16,   25,   26,   27,   16,   28,   29,   16,
+       30,   16,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -332,102 +362,120 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst int yy_meta[31] =
+static yyconst int yy_meta[33] =
     {   0,
-        1,    1,    2,    1,    1,    1,    3,    3,    3,    3,
+        1,    1,    2,    1,    1,    1,    1,    3,    3,    1,
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    1,    3
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        1,    3
     } ;
 
-static yyconst short int yy_base[112] =
+static yyconst short int yy_base[113] =
     {   0,
-        0,    0,  137,  138,  134,  138,   27,  132,   25,  126,
-       27,  109,    0,  111,  108,  113,  108,   27,  119,  125,
-       33,  138,   35,  123,  138,  117,   33,  116,  115,   35,
-        0,  100,  102,   35,   96,   35,   30,  104,   92,   41,
-      109,  103,  105,   86,   85,   87,   90,   87,   89,   86,
-       95,    0,   93,   94,   87,    0,    0,   82,   83,   80,
-       90,    0,   78,    0,   73,   77,    0,   86,   85,   73,
-       74,   81,   78,   73,   80,   61,    0,   66,   74,   65,
-       74,    0,   65,   63,   68,   63,   58,   69,   65,   54,
-       46,   46,   48,   49,   41,    0,   54,   36,    0,   38,
+        0,    0,  141,  142,  138,  142,   29,  133,   26,  129,
+       28,  111,    0,  113,  110,  115,  110,   27,  121,  129,
+       35,  142,   37,  124,   36,  120,   35,  119,  118,   39,
+        0,  102,  104,   34,   98,   37,   32,  106,   94,   48,
+      115,  111,  104,  106,   87,   86,   88,   91,   88,   90,
+       87,   96,    0,   94,   95,   88,    0,    0,   83,   84,
+       81,   91,    0,   79,    0,   74,   78,    0,   87,   86,
+       74,   75,   82,   79,   74,   81,   62,    0,   67,   75,
+       66,   75,    0,   66,   63,   66,   59,   54,   65,   61,
+       54,   48,   48,   50,   51,   43,    0,   56,   38,    0,
 
-       31,    0,   39,   45,   31,   28,    0,  138,   70,   73,
-       48
+       40,   33,    0,   41,   48,   34,   30,    0,  142,   79,
+       82,   52
     } ;
 
-static yyconst short int yy_def[112] =
+static yyconst short int yy_def[113] =
     {   0,
-      108,    1,  108,  108,  108,  108,  109,  110,  108,  108,
-      108,  111,  111,  111,  111,  111,  111,  111,  111,  108,
-      109,  108,  109,  110,  108,  108,  108,  108,  108,  108,
-      111,  111,  111,  111,  111,  111,  111,  111,  111,  109,
-      108,  111,  111,  111,  111,  111,  111,  111,  111,  111,
-      111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
-      111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
-      111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
-      111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
-      111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
+      109,    1,  109,  109,  109,  109,  110,  111,  109,  109,
+      109,  112,  112,  112,  112,  112,  112,  112,  112,  109,
+      110,  109,  110,  111,  111,  109,  109,  109,  109,  109,
+      112,  112,  112,  112,  112,  112,  112,  112,  112,  110,
+      111,  109,  112,  112,  112,  112,  112,  112,  112,  112,
+      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
+      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
+      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
+      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
+      112,  112,  112,  112,  112,  112,  112,  112,  112,  112,
 
-      111,  111,  111,  111,  111,  111,  111,    0,  108,  108,
-      108
+      112,  112,  112,  112,  112,  112,  112,  112,    0,  109,
+      109,  109
     } ;
 
-static yyconst short int yy_nxt[169] =
+static yyconst short int yy_nxt[175] =
     {   0,
-        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
-       14,   13,   13,   13,   15,   16,   13,   13,   13,   17,
-       13,   13,   18,   13,   13,   13,   19,   13,    4,    4,
-       22,   26,   27,   29,   30,   37,   22,   21,   40,   26,
-       27,   29,   30,   44,   22,   47,   49,   45,   50,   51,
-       31,  107,  106,  105,   38,   23,   48,  104,  103,  102,
-      101,   23,  100,   23,   99,   98,   97,   96,   95,   23,
-       21,   94,   21,   24,   24,   24,   93,   92,   91,   90,
-       89,   88,   87,   86,   85,   84,   83,   82,   81,   80,
-       79,   78,   77,   76,   75,   74,   73,   72,   71,   70,
-
-       69,   68,   67,   66,   65,   64,   63,   62,   61,   60,
-       59,   58,   57,   56,   55,   54,   41,   53,   52,   46,
-       43,   42,   28,   28,   41,   25,   20,   39,   36,   35,
-       34,   33,   32,   28,   25,   20,  108,    3,  108,  108,
-      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
-      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
-      108,  108,  108,  108,  108,  108,  108,  108
+        4,    5,    6,    7,    8,    4,    9,   10,   11,    4,
+       12,   13,   14,   13,   13,   13,   15,   16,   13,   13,
+       13,   17,   13,   13,   18,   13,   13,   13,   19,   13,
+        4,    4,   22,   26,   27,   29,   30,   37,   22,   21,
+       40,   25,   26,   27,   45,   41,   29,   30,   46,   48,
+       50,   22,   51,   52,   31,  108,   38,  107,  106,   23,
+       49,  105,  104,  103,  102,   23,  101,   23,  100,   99,
+       98,   97,   96,   95,   94,   93,   92,   91,   23,   21,
+       90,   21,   24,   89,   24,   88,   87,   86,   85,   84,
+       83,   82,   81,   80,   79,   78,   77,   76,   75,   74,
+
+       73,   72,   71,   70,   69,   68,   67,   66,   65,   64,
+       63,   62,   61,   60,   59,   58,   57,   56,   55,   42,
+       25,   54,   53,   47,   44,   43,   28,   28,   42,   25,
+       20,   39,   36,   35,   34,   33,   32,   28,   25,   20,
+      109,    3,  109,  109,  109,  109,  109,  109,  109,  109,
+      109,  109,  109,  109,  109,  109,  109,  109,  109,  109,
+      109,  109,  109,  109,  109,  109,  109,  109,  109,  109,
+      109,  109,  109,  109
     } ;
 
-static yyconst short int yy_chk[169] =
+static yyconst short int yy_chk[175] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        7,    9,    9,   11,   11,   18,   21,   23,   23,   27,
-       27,   30,   30,   34,   40,   36,   37,   34,   37,   37,
-      111,  106,  105,  104,   18,    7,   36,  103,  101,  100,
-       98,   21,   97,   23,   95,   94,   93,   92,   91,   40,
-      109,   90,  109,  110,  110,  110,   89,   88,   87,   86,
-       85,   84,   83,   81,   80,   79,   78,   76,   75,   74,
-       73,   72,   71,   70,   69,   68,   66,   65,   63,   61,
-
-       60,   59,   58,   55,   54,   53,   51,   50,   49,   48,
-       47,   46,   45,   44,   43,   42,   41,   39,   38,   35,
-       33,   32,   29,   28,   26,   24,   20,   19,   17,   16,
-       15,   14,   12,   10,    8,    5,    3,  108,  108,  108,
-      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
-      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
-      108,  108,  108,  108,  108,  108,  108,  108
+        1,    1,    7,    9,    9,   11,   11,   18,   21,   23,
+       23,   25,   27,   27,   34,   25,   30,   30,   34,   36,
+       37,   40,   37,   37,  112,  107,   18,  106,  105,    7,
+       36,  104,  102,  101,   99,   21,   98,   23,   96,   95,
+       94,   93,   92,   91,   90,   89,   88,   87,   40,  110,
+       86,  110,  111,   85,  111,   84,   82,   81,   80,   79,
+       77,   76,   75,   74,   73,   72,   71,   70,   69,   67,
+
+       66,   64,   62,   61,   60,   59,   56,   55,   54,   52,
+       51,   50,   49,   48,   47,   46,   45,   44,   43,   42,
+       41,   39,   38,   35,   33,   32,   29,   28,   26,   24,
+       20,   19,   17,   16,   15,   14,   12,   10,    8,    5,
+        3,  109,  109,  109,  109,  109,  109,  109,  109,  109,
+      109,  109,  109,  109,  109,  109,  109,  109,  109,  109,
+      109,  109,  109,  109,  109,  109,  109,  109,  109,  109,
+      109,  109,  109,  109
     } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
 
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
+static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
+static char *yy_full_match;
+static int yy_lp;
+#define REJECT \
+{ \
+*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
+yy_cp = yy_full_match; /* restore poss. backed-over text */ \
+++yy_lp; \
+goto find_rule; \
+}
+static int yy_more_offset = 0;
+static int yy_prev_more_offset = 0;
+#define yymore() (yy_more_offset = yy_flex_strlen( yytext ))
+#define YY_NEED_STRLEN
 #define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
+#define YY_RESTORE_YY_MORE_OFFSET \
+	{ \
+	yy_more_offset = yy_prev_more_offset; \
+	yyleng -= yy_more_offset; \
+	}
+#ifndef YYLMAX
+#define YYLMAX 8192
+#endif
+
+char yytext[YYLMAX];
+char *yytext_ptr;
 #line 1 "binfer.l"
 #define INITIAL 0
 /**/
@@ -440,7 +488,7 @@
 /*** Version: 1.0*/
 /**(lex doesn't like my normal comment style...?)**/
 /**/
-#line 13 "binfer.l"
+#line 16 "binfer.l"
 int s_lookup(int);
 #ifdef DEBUG
 #   include <assert.h>
@@ -467,11 +515,15 @@
 
 #endif   DEBUG
 
+#ifndef sparc
+#ifndef linux
 int yylineno = 1;
+#endif
+#endif
 
 #define   END(v)   (v-1 + sizeof v / sizeof v[0])
 static int screen();
-#line 475 "lex.yy.c"
+#line 527 "lex.yy.c"
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -619,13 +671,13 @@
 YY_DECL
 	{
 	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
+	register char *yy_cp = NULL, *yy_bp = NULL;
 	register int yy_act;
 
-#line 52 "binfer.l"
+#line 59 "binfer.l"
 
 
-#line 629 "lex.yy.c"
+#line 681 "lex.yy.c"
 
 	if ( yy_init )
 		{
@@ -664,152 +716,157 @@
 		yy_bp = yy_cp;
 
 		yy_current_state = yy_start;
+		yy_state_ptr = yy_state_buf;
+		*yy_state_ptr++ = yy_current_state;
 yy_match:
 		do
 			{
 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 109 )
+				if ( yy_current_state >= 110 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			*yy_state_ptr++ = yy_current_state;
 			++yy_cp;
 			}
-		while ( yy_base[yy_current_state] != 138 );
+		while ( yy_base[yy_current_state] != 142 );
 
 yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
+		yy_current_state = *--yy_state_ptr;
+		yy_lp = yy_accept[yy_current_state];
+find_rule: /* we branch to this label when backing up */
+		for ( ; ; ) /* until we find what rule we matched */
+			{
+			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
+				{
+				yy_act = yy_acclist[yy_lp];
+					{
+					yy_full_match = yy_cp;
+					break;
+					}
+				}
+			--yy_cp;
+			yy_current_state = *--yy_state_ptr;
+			yy_lp = yy_accept[yy_current_state];
 			}
 
 		YY_DO_BEFORE_ACTION;
 
+		if ( yy_act != YY_END_OF_BUFFER )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < yyleng; ++yyl )
+				if ( yytext[yyl] == '\n' )
+					++yylineno;
+			}
 
 do_action:	/* This label is used only to access EOF actions. */
 
 
 		switch ( yy_act )
 	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
 case 1:
-*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
-yy_c_buf_p = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 54 "binfer.l"
-; /* Strip out comments */
+#line 61 "binfer.l"
+/* Strip out comments */
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 56 "binfer.l"
+#line 63 "binfer.l"
 {
 return token(NO_PROBABILITY_MAPS); }
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 59 "binfer.l"
+#line 66 "binfer.l"
 {
 return token(NO_COMBINED_MAP); }
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 62 "binfer.l"
+#line 69 "binfer.l"
 {
 return token(COMBINED_MAP); }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 65 "binfer.l"
+#line 72 "binfer.l"
 {
 return token(ASPECT); }
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 68 "binfer.l"
+#line 75 "binfer.l"
 {
 return token(GREY); }
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 71 "binfer.l"
+#line 78 "binfer.l"
 {
 return token(GREY); }
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 74 "binfer.l"
+#line 81 "binfer.l"
 {
 return token(HISTO); }
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 77 "binfer.l"
+#line 84 "binfer.l"
 {
 return token(RAINBOW); }
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 80 "binfer.l"
+#line 87 "binfer.l"
 {
 return token(RAMP); }
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 83 "binfer.l"
+#line 90 "binfer.l"
 {
 return token(RANDOM); }
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 86 "binfer.l"
+#line 93 "binfer.l"
 {
 return token(REDYELLOWGREEN); }
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 89 "binfer.l"
+#line 96 "binfer.l"
 {
 return token(WAVE); }
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 92 "binfer.l"
+#line 99 "binfer.l"
 return screen();
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 94 "binfer.l"
+#line 101 "binfer.l"
 {
 s_lookup(token(String));
 return token(String);
 }
 	YY_BREAK
 case 16:
-#line 100 "binfer.l"
+#line 107 "binfer.l"
 case 17:
-#line 101 "binfer.l"
+#line 108 "binfer.l"
 case 18:
-#line 102 "binfer.l"
+#line 109 "binfer.l"
 case 19:
 YY_RULE_SETUP
-#line 102 "binfer.l"
+#line 109 "binfer.l"
 {
 s_lookup(token(Constant));
 return token(Constant);
@@ -817,29 +874,29 @@
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 107 "binfer.l"
+#line 114 "binfer.l"
 ;
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 109 "binfer.l"
+#line 116 "binfer.l"
 {
 yylineno++;
 }
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 113 "binfer.l"
+#line 120 "binfer.l"
 return token(yytext[0]);
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 114 "binfer.l"
+#line 121 "binfer.l"
 ECHO;
 	YY_BREAK
-#line 841 "lex.yy.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
+#line 898 "lex.yy.c"
+			case YY_STATE_EOF(INITIAL):
+				yyterminate();
 
 	case YY_END_OF_BUFFER:
 		{
@@ -1117,22 +1174,20 @@
 	register char *yy_cp;
 
 	yy_current_state = yy_start;
+	yy_state_ptr = yy_state_buf;
+	*yy_state_ptr++ = yy_current_state;
 
 	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
 		{
 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 109 )
+			if ( yy_current_state >= 110 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		*yy_state_ptr++ = yy_current_state;
 		}
 
 	return yy_current_state;
@@ -1153,22 +1208,18 @@
 #endif
 	{
 	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
 
 	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 109 )
+		if ( yy_current_state >= 110 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 108);
+	yy_is_jam = (yy_current_state == 109);
+	if ( ! yy_is_jam )
+		*yy_state_ptr++ = yy_current_state;
 
 	return yy_is_jam ? 0 : yy_current_state;
 	}
@@ -1211,6 +1262,8 @@
 
 	*--yy_cp = (char) c;
 
+	if ( c == '\n' )
+		--yylineno;
 
 	yytext_ptr = yy_bp;
 	yy_hold_char = *yy_cp;
@@ -1287,6 +1340,8 @@
 	*yy_c_buf_p = '\0';	/* preserve yytext */
 	yy_hold_char = *++yy_c_buf_p;
 
+	if ( c == '\n' )
+		++yylineno;
 
 	return c;
 	}
@@ -1723,7 +1778,7 @@
 	return 0;
 	}
 #endif
-#line 114 "binfer.l"
+#line 121 "binfer.l"
 
 
 static struct rwtable {
Index: raster/r.combine/cmd/gis_lxcl.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.combine/cmd/gis_lxcl.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 gis_lxcl.c
--- raster/r.combine/cmd/gis_lxcl.c	1999/12/29 15:11:07	1.1.1.1
+++ raster/r.combine/cmd/gis_lxcl.c	2000/05/03 03:58:17
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header$
+ * $Header$
  */
 
 #define FLEX_SCANNER
@@ -663,7 +663,7 @@
 YY_DECL
 	{
 	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
+	register char *yy_cp = NULL, *yy_bp = NULL;
 	register int yy_act;
 
 #line 15 "gis_lxcl.l"
Index: raster/r.combine/cmd/gis_pars.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.combine/cmd/gis_pars.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 gis_pars.c
--- raster/r.combine/cmd/gis_pars.c	1999/12/29 15:11:07	1.1.1.1
+++ raster/r.combine/cmd/gis_pars.c	2000/05/03 03:58:18
@@ -1,6 +1,5 @@
 #ifndef lint
-/*static char yysccsid[] = "from: @(#)yaccpar	1.9 (Berkeley) 02/21/93";*/
-static char yyrcsid[] = "$Id$";
+static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
 #endif
 #define YYBYACC 1
 #define YYMAJOR 1
@@ -30,7 +29,7 @@
 	struct Node     *nod_val;
 	char            *str_val;
 } YYSTYPE;
-#line 34 "y.tab.c"
+#line 33 "y.tab.c"
 #define AND_TKN 257
 #define OR_TKN 258
 #define NOT_TKN 259
@@ -256,17 +255,13 @@
 	return (node) ;
 }
 /* ========================================================================= */
-#line 260 "y.tab.c"
+#line 259 "y.tab.c"
 #define YYABORT goto yyabort
 #define YYREJECT goto yyabort
 #define YYACCEPT goto yyaccept
 #define YYERROR goto yyerrlab
 int
-#if defined(__STDC__)
-yyparse(void)
-#else
 yyparse()
-#endif
 {
     register int yym, yyn, yystate;
 #if YYDEBUG
@@ -290,7 +285,7 @@
     *yyssp = yystate = 0;
 
 yyloop:
-    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
+    if (yyn = yydefred[yystate]) goto yyreduce;
     if (yychar < 0)
     {
         if ((yychar = yylex()) < 0) yychar = 0;
@@ -330,6 +325,10 @@
         goto yyreduce;
     }
     if (yyerrflag) goto yyinrecovery;
+#ifdef lint
+    goto yynewerror;
+#endif
+yynewerror:
     yyerror("syntax error");
 #ifdef lint
     goto yyerrlab;
@@ -705,7 +704,7 @@
 {
 		}
 break;
-#line 709 "y.tab.c"
+#line 708 "y.tab.c"
     }
     yyssp -= yym;
     yystate = *yyssp;
Index: raster/r.drain/cmd/Gmakefile
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.drain/cmd/Gmakefile,v
retrieving revision 1.2
diff -u -r1.2 Gmakefile
--- raster/r.drain/cmd/Gmakefile	2000/04/18 19:32:41	1.2
+++ raster/r.drain/cmd/Gmakefile	2000/05/03 03:58:19
@@ -1,7 +1,7 @@
 PGM = r.drain
 LIST =  main.o
  
-LIBES = $(DISPLAYLIB) $(GISLIB) $(SEGMENTLIB) $(DATETIMELIB)
+LIBES = $(DISPLAYLIB) $(GISLIB) $(SEGMENTLIB) $(DATETIMELIB) 
 $(BIN_MAIN_CMD)/$(PGM): $(LIST) $(LIBES)
 	$(CC) $(LDFLAGS) -o $@ $(LIST) $(LIBES) $(MATHLIB) $(XDRLIB)
  
Index: raster/r.mapcalc/polish/lex.yy.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.mapcalc/polish/lex.yy.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 lex.yy.c
--- raster/r.mapcalc/polish/lex.yy.c	1999/12/29 15:11:09	1.1.1.1
+++ raster/r.mapcalc/polish/lex.yy.c	2000/05/03 03:58:23
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header$
+ * $Header$
  */
 
 #define FLEX_SCANNER
@@ -560,7 +560,7 @@
 YY_DECL
 	{
 	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
+	register char *yy_cp = NULL, *yy_bp = NULL;
 	register int yy_act;
 
 #line 2 "pol.l"
Index: raster/r.mapcalc/polish/y.tab.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.mapcalc/polish/y.tab.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 y.tab.c
--- raster/r.mapcalc/polish/y.tab.c	1999/12/29 15:11:09	1.1.1.1
+++ raster/r.mapcalc/polish/y.tab.c	2000/05/03 03:58:25
@@ -1,6 +1,5 @@
 #ifndef lint
-/*static char yysccsid[] = "from: @(#)yaccpar	1.9 (Berkeley) 02/21/93";*/
-static char yyrcsid[] = "$Id$";
+static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
 #endif
 #define YYBYACC 1
 #define YYMAJOR 1
@@ -16,7 +15,7 @@
 
 static int nstored = 0;
 static char **storage = 0;
-#line 20 "y.tab.c"
+#line 19 "y.tab.c"
 #define NAME 257
 #define STRING 258
 #define INTEGER 259
@@ -474,17 +473,13 @@
 }
 
 
-#line 478 "y.tab.c"
+#line 477 "y.tab.c"
 #define YYABORT goto yyabort
 #define YYREJECT goto yyabort
 #define YYACCEPT goto yyaccept
 #define YYERROR goto yyerrlab
 int
-#if defined(__STDC__)
-yyparse(void)
-#else
 yyparse()
-#endif
 {
     register int yym, yyn, yystate;
 #if YYDEBUG
@@ -508,7 +503,7 @@
     *yyssp = yystate = 0;
 
 yyloop:
-    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
+    if (yyn = yydefred[yystate]) goto yyreduce;
     if (yychar < 0)
     {
         if ((yychar = yylex()) < 0) yychar = 0;
@@ -548,6 +543,10 @@
         goto yyreduce;
     }
     if (yyerrflag) goto yyinrecovery;
+#ifdef lint
+    goto yynewerror;
+#endif
+yynewerror:
     yyerror("syntax error");
 #ifdef lint
     goto yyerrlab;
@@ -778,7 +777,7 @@
 #line 79 "pol.y"
 { yyval = -yyvsp[0]; }
 break;
-#line 782 "y.tab.c"
+#line 781 "y.tab.c"
     }
     yyssp -= yym;
     yystate = *yyssp;
Index: raster/r.weight/inter/gis_lxcl.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.weight/inter/gis_lxcl.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 gis_lxcl.c
--- raster/r.weight/inter/gis_lxcl.c	1999/12/29 15:11:14	1.1.1.1
+++ raster/r.weight/inter/gis_lxcl.c	2000/05/03 03:58:31
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header$
+ * $Header$
  */
 
 #define FLEX_SCANNER
@@ -635,7 +635,7 @@
 YY_DECL
 	{
 	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
+	register char *yy_cp = NULL, *yy_bp = NULL;
 	register int yy_act;
 
 #line 16 "gis_lxcl.l"
Index: raster/r.weight/inter/gis_pars.c
===================================================================
RCS file: /home/grass/grassrepository/grass/src/raster/r.weight/inter/gis_pars.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 gis_pars.c
--- raster/r.weight/inter/gis_pars.c	1999/12/29 15:11:14	1.1.1.1
+++ raster/r.weight/inter/gis_pars.c	2000/05/03 03:58:33
@@ -1,6 +1,5 @@
 #ifndef lint
-/*static char yysccsid[] = "from: @(#)yaccpar	1.9 (Berkeley) 02/21/93";*/
-static char yyrcsid[] = "$Id$";
+static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
 #endif
 #define YYBYACC 1
 #define YYMAJOR 1
@@ -23,7 +22,7 @@
         int              int_val;
         char            *str_val;
 } YYSTYPE;
-#line 27 "y.tab.c"
+#line 26 "y.tab.c"
 #define ERAS_TKN 257
 #define LST_TKN 258
 #define COLR_TKN 259
@@ -266,17 +265,13 @@
 	return 0;
 }
 /* ========================================================================= */
-#line 270 "y.tab.c"
+#line 269 "y.tab.c"
 #define YYABORT goto yyabort
 #define YYREJECT goto yyabort
 #define YYACCEPT goto yyaccept
 #define YYERROR goto yyerrlab
 int
-#if defined(__STDC__)
-yyparse(void)
-#else
 yyparse()
-#endif
 {
     register int yym, yyn, yystate;
 #if YYDEBUG
@@ -300,7 +295,7 @@
     *yyssp = yystate = 0;
 
 yyloop:
-    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
+    if (yyn = yydefred[yystate]) goto yyreduce;
     if (yychar < 0)
     {
         if ((yychar = yylex()) < 0) yychar = 0;
@@ -340,6 +335,10 @@
         goto yyreduce;
     }
     if (yyerrflag) goto yyinrecovery;
+#ifdef lint
+    goto yynewerror;
+#endif
+yynewerror:
     yyerror("syntax error");
 #ifdef lint
     goto yyerrlab;
@@ -731,7 +730,7 @@
 #line 243 "gis_pars.y"
 {;}
 break;
-#line 735 "y.tab.c"
+#line 734 "y.tab.c"
     }
     yyssp -= yym;
     yystate = *yyssp;
Index: scripts/shells/create_fifos.sh
===================================================================
RCS file: /home/grass/grassrepository/grass/src/scripts/shells/create_fifos.sh,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 create_fifos.sh
--- scripts/shells/create_fifos.sh	1999/12/29 15:11:21	1.1.1.1
+++ scripts/shells/create_fifos.sh	2000/05/03 03:58:34
@@ -27,10 +27,12 @@
 	if [ ! -p ${DEV}/fifo.${i}a ]; then
 		rm -f ${DEV}/fifo.${i}a
 		${MKFIFO} ${DEV}/fifo.${i}a ${MKNOD_ARG}
+#		touch ${DEV}/fifo.${i}a
 	fi
 	if [ ! -p ${DEV}/fifo.${i}b ]; then
 		rm -f ${DEV}/fifo.${i}b
 		${MKFIFO} ${DEV}/fifo.${i}b ${MKNOD_ARG}
+#		touch ${DEV}/fifo.${i}b
 	fi
 	i=`expr $i + 1`
 done
