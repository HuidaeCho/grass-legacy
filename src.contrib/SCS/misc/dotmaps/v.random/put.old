/* %W% %G% */
/* put_dot.c    1.0   4/01/91
*                                                                       
*     Purpose                                                           
*        output sites(points) in a psuedo-random pattern,      
*         within the bounds of the polygon.                             
*                                                                       
*/                                                                       

#include <math.h>
#include  "gis.h"
#include "Vect.h"
#include "dots.h"

#ifndef HUGE_VAL
#define HUGE_VAL 9999999999999.0
#endif
#define		SITE_DIR	"site_lists"
/*#define DEBUG 1*/

static int I4, ipass;
static double maxd, mind, centrdx, centrdy, f_area ;
static double N,S,E,W;



put_dots(map, area, dot_cnt, temp, size_only)
struct Map_info *map;
int  area, dot_cnt, size_only;
FILE *temp;
{
    int ii, new_cnt ;
    int island ;
    double xorg, yorg ;
    P_AREA *Areas;

    N = E = -999999999.;
    W = S = 999999999.;


                     /* Calculate polygon area */
     if (V2_get_area(map,area,&Areas) != 0) 
		G_fatal_error("could not get area info\n");
     if (tmp_find_area(map,Areas,&f_area,&centrdx,&centrdy,&N,&E,&W,&S) != 0)
        {
        fprintf(stderr,"\nArea %d has NO centroid, aborting !!!\n",area);
        exit(-1);
        }

#ifdef DEBUG
printf("bounds: N %12.2lf,     S %12.2lf\n        E %12.2lf,     W %12.2lf\n",N,S,E,W);
printf("area= %.2lf, centrdx= %.2lf, centrdy= %.2lf\n",f_area,centrdx,centrdy);
#endif

     if (dot_ratio > f_area/dot_cnt) 
        {
        dot_ratio = f_area/dot_cnt;
        min_area = f_area;
        area_cnt = dot_cnt;
        }
    
     if (size_only) return(0);


     /* dot creation stuff here */
	 new_cnt = dot_cnt * ((N-S) * (E-W)/f_area);

	make_dots(temp,map,area,W,E,S,N,new_cnt,dot_cnt);


/*------------------------------------------ All dots Processed  */
    return(0);


}



make_dots(temp,map,garea,x1,x2,y1,y2,dots,actual)
FILE *temp;
struct Map_info *map;
int garea;
double x1, x2, y1, y2;
int dots,actual;
{
double area, x, y, dx, dy, factor, ratio, inarea;
int i, ii, ix ,iy, iix, iiy, r, r1, tx, ty;
int island, iflag;
P_AREA *Areas;


area = (x2 - x1) * (y2 - y1);
ratio = area/dots;
factor = sqrt(ratio);
ix = (x2 - x1)/(factor);
iy = (y2 - y1)/(factor);
r = dots - (ix * iy);


if (r > 0) {
	tx = ix + 1;
	ty = iy + 1;
	r = ((tx) * (ty)) - dots;
	for (iix = ix -1; iix <= ix +1; iix++)
		for (iiy = iy -1; iiy <= iy +1; iiy++) {
			r1 = (iix * iiy) - dots ;
			if (r1 > 0 && r1 < r) {
				r = r1;
				tx = iix;
				ty = iiy;
				}
			}
	}

ix = tx;
iy = ty;



dx = (x2-x1)/(ix);
dy = (y2-y1)/(iy);
x = x1 + (.5 * dx);
i = 0;
V2_get_area(map,garea,&Areas);

while ( x < x2) {
	y = y1 + (.5 * dy);
	while ( y < y2) {
		if ((inarea = dig_point_in_area(map,x,y,Areas)) != 0.0)
			{
			iflag = 1;
     /* ----------------------------------------------
        Dot coord. is INSIDE Area, check for Islands */

		      if (map->Area[garea].n_isles != 0) 
	 			{
	 			for (ii=0; ii < map->Area[garea].n_isles; ii++)
		    		{
           			island = map->Area[garea].isles[ii];
	      /* set "Areas" pointer to the island */
           			V2_get_area(map,island,&Areas);
					if ((inarea = dig_point_in_area(map,x,y,Areas)) == 0.0)
						iflag = 0;
         			}
            	V2_get_area(map,garea,&Areas);
/*				fprintf(stderr,"ISLAND iflag %d\n",iflag);*/
				}
         	if (iflag) fprintf(temp,"%lf|%lf|#%d\n",x,y,++i);
			if (i == actual) {
				x = x2 + 10.0;
				y = y2 + 10.0;
				}
	    	}
/*			fprintf(stderr,"AREA inarea %lf\n",inarea);*/
			y += dy;
			}
		x += dx;
		}
/*DEBUG*/ fprintf(stderr,"actual_%d wanted %d got %d\n",actual,dots,i);
		
}


