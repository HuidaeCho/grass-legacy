/* %W% %G% */
/* put_dot.c    1.0   4/01/91
*                                                                       
*     Purpose                                                           
*        output sites(points) in a psuedo-random pattern,      
*         within the bounds of the polygon.                             
*                                                                       
*/                                                                       

#include <math.h>
#include  "gis.h"
#include "Vect.h"
#include "dots.h"

#define		SITE_DIR	"site_lists"
/*#define DEBUG 1*/

struct Plus_head Plus ;
struct Categories cats ;
char  buf[1024] ;
static int I4, I7, iflag, ipass;
static double maxd, mind, centrdx, centrdy, f_area, centrx, centry;
static double N,S,E,W;



put_dots(map, area, dot_cnt, temp, size_only)
struct Map_info *map;
int  area, dot_cnt, size_only;
FILE *temp;
{
    int ii, dummy, rings;
    int line, linea, island, rngpnt, strtpnt;
    int sav_area, pntcnt, dotcnt;
    int done, rngcnt, nstrt, todo, rngpnt_avail, ltodo;
    double dumx, dumy;
    double max, angle, sang, rand, xorg, yorg, randY, randX;
    double min, tmin;
    double stang;
    P_AREA *Areas;

    N = E = -999999999.;
    W = S = 999999999.;


                     /* Calculate polygon area */
     V2_get_area(map,area,&Areas);
     if (tmp_find_area(map,Areas,&f_area,&centrdx,&centrdy,&N,&E,&W,&S) != 0)
        {
        fprintf(stderr,"\nArea %d has NO centroid, aborting !!!\n",area);
        exit(-1);
        }

#ifdef DEBUG
printf("bounds: N %12.2lf,     S %12.2lf\n        E %12.2lf,     W %12.2lf\n",N,S,E,W);
printf("area= %.2lf, centrdx= %.2lf, centrdy= %.2lf\n",f_area,centrdx,centrdy);
#endif

     if (dot_ratio > f_area/dot_cnt) 
        {
        dot_ratio = f_area/dot_cnt;
        min_area = f_area;
        area_cnt = dot_cnt;
        }
    
     if (size_only) return(0);

     xorg = centrdx;
     yorg = centrdy;
     rngpnt = strtpnt = 5; 
/*   if (dot_cnt <= 29) strtpnt = 2;
     else if (dot_cnt <= 89) strtpnt = 3;
     else if (dot_cnt <= 119) strtpnt = 5;
     else if (dot_cnt <= 139) strtpnt = 7;
     else  strtpnt = 11;
     rngpnt = strtpnt; */


     /* establish st(art) ang(le) from the diagonal of
	the area bounds box */
     stang = atan((N - S) / (E - W)) * 57.2957;

/*        OUTput this area 
         Establish how many rings of "DOTS" there will be  */
      rings = 1;
      rngpnt_avail = dummy = rngpnt;
      while(rngpnt_avail <= dot_cnt)
	 {
	 rings++;
	 dummy = dummy + strtpnt;
	 rngpnt_avail+=dummy;
	 }
      rngcnt = 1;
      if (rings == 1) rings = 2;

#ifdef DEBUG
printf("dot_cnt= %d, rings= %d, rngpnt= %d, pnt_avail= %d\n",dot_cnt,rings,rngpnt,rngpnt_avail);
#endif

/*        Find max and min distances from centroid     */
      centrx = W + ((E - W) / 2.0);
      centry = S + ((N - S) / 2.0);
      maxd = 0.0;
      mind = 9999999.9;
      I4 = 0;
      INCHECK(map,Areas, &xorg, &yorg);
#ifdef DEBUG
printf(" mind= %10.4lf,  maxd= %10.4lf, INCHK= %d\n",mind,maxd,iflag);
#endif

      if ((mind - (maxd / (2 * rings + 1))) > 0) 
	 { /*       Reset min, area is somewhat square  */
	 mind = maxd / (2 * rings + 1);
#ifdef DEBUG
printf("Reset:  mind= %10.4lf,  maxd= %10.4lf\n",mind,maxd);
#endif
	 }
/*----------------------------------------- "Dot" generation -----
         Now start generating dot_cnt figures (dots) */
      if (dot_cnt == 1)
         {
         fprintf(temp,"%lf|%lf|#1\n",centrdx,centrdy);
         return(0);
         }
      nstrt = 0;
      angle = stang;
      done = pntcnt = dummy = ltodo = 0;

      max = maxd;
      tmin = min = mind;
      dotcnt = todo = dot_cnt;

#ifdef DEBUG
printf("angle= %lf, dotcnt= %d, rings= %d, rngpnt= %d\n",angle,dotcnt,rings,rngpnt);
#endif
      for (I4=1; I4 <= dot_cnt; I4++)
        {
cycle:  pntcnt++;
/*
 *     Up to rngpnt points can be selected within a 360 degree Ring
 *      over rngpnt, then requires INCrementing to the next Ring  
 *        INCrementing the st(arting) ang(le) by stang/2 degrees    
 */
#ifdef DEBUG
printf("pntcnt= %d, rngpnt= %d\n",pntcnt,rngpnt);
#endif
        if (pntcnt > rngpnt) 
           {
#ifdef DEBUG
printf("nstrt= %d, dotcnt= %d, rngpnt= %d, todo= %d\n",nstrt,dotcnt,rngpnt,todo);
#endif
           ltodo = todo;
           dotcnt-=rngpnt;
#ifdef DEBUG
printf("dummy= %d, ltodo= %d, dotcnt= %d\n",dummy,ltodo,dotcnt);
#endif

           rngpnt+=strtpnt;
#ifdef DEBUG
printf("ring %d done: rngpnt= %d, stang= %.2lf\n",rngcnt,rngpnt,stang);
#endif
           if (dotcnt <= 1)
              {
              rand = 0.0;
              sang = 0.0;
#ifdef DEBUG
printf("dot cnt#= %d, ang= %lf, rg.dist= %lf, rings= %d, cnt= %d\n",done,sang,rand,rings,rngpnt);
#endif
              fprintf(temp,"%lf|%lf|#1\n",centrdx,centrdy);
              break;
              }
           rngcnt = rngcnt + 1;
           pntcnt = 1;
           angle = stang;

#ifdef DEBUG
printf("_rngcnt= %d, nstrt= %d, stang= %.2lf, angle= %.2lf\n",rngcnt,nstrt,stang,angle);
#endif
                /*  Check for more dots than available
                        output a message if this is the case */
            if (ltodo >= rngpnt_avail) return(ltodo);
           }

#ifdef DEBUG
printf("\npntcnt= %d, done= %d, angpas= %d, rngpnt_avail= %d, todo= %d\n",
               pntcnt,done,nstrt,rngpnt_avail,todo);
#endif

        if ((dotcnt > rngpnt) && (rngpnt_avail < todo))
           angle = angle + 360. / dotcnt;
         else
           angle = angle + 360. / rngpnt;

#ifdef DEBUG
printf("\nredefine start angle= %.2lf\n",angle);
#endif
         sang = angle;
         rand = max;
         ipass = 0;
 zeroI7:
	 I7 = 0;
 dorand: 

#ifdef DEBUG
printf("I7= %d, rand= %.2lf, max= %.2lf, tmin= %.2lf\n",I7,rand,max,tmin);
#endif
	 rand = rand - max / 10.0;
         if ((rand - tmin) > 0.0) I7++;
	 else goto doagin;
         if (I7 > 1000) goto zeroI7;

         randX = cos( sang / 57.2957) * rand;
         randY = sin( sang / 57.2957) * rand;

#ifdef DEBUG
printf("\n*ANG %.2lf,  ATTP %d,  RNDM %.4lf,  RX %.4lf,  RY %.4lf\n", sang,I7,rand,randX,randY);
#endif
         xorg = centrdx + randX;
         yorg = centrdy + randY;

#ifdef DEBUG
printf("centrdx= %.2lf, centrdy= %.2lf, xorg= %.2lf, yorg= %.2lf\n", centrdx,centrdy,xorg,yorg);
#endif

/* ----------------- Pass 1 ---------------- Check Envelope ------      
         Check envelope (N,S,E,W) for INSIDE coord. value              
             If OUTSIDE, go try again                                   */
      if ((xorg <= W) || (xorg >= E)) goto dorand;
      if ((yorg <= S) || (yorg >= N)) goto dorand;    

#ifdef DEBUG
printf(" passed envelop test\n");
#endif

        /*  PASSed envelope test, now see if value is INSIDE POLYgon  */     
inchk:
      INCHECK(map,Areas, &xorg, &yorg);

#ifdef DEBUG
printf("iflag= %d, ipass= %d\n",iflag,ipass);
#endif

/*       Is the point outside (iflag>0) and the first to be found ??? */
      if ((iflag > 0) && (ipass == 0)) goto dorand;

/*       Is the point outside (iflag>0) and the computed ring position ?*/
      if ((iflag > 0) && (ipass == 1)) goto doagin;

/*       Is the point inside (iflag<0) and the computed ring position ? */
      if ((iflag < 0) && (ipass == 1)) goto IfIsle;
/*---------------------------------------------------------             

        This is the first pass, compute the ring position coord.       
        use the number of Rings and the present ring;                  
             to compute "DOT" coord. position                          
                                                                       
        Check the rings and ring counter values          */
      todo = dot_cnt - done; 

#ifdef DEBUG
printf("done= %d, dot_cnt= %d rngpnt= %d, PNT= %d, rings= %d, rngcnt= %d\n",
                    done,dot_cnt,rngpnt,pntcnt,rings,rngcnt);
#endif


#ifdef DEBUG
printf("todo= %d, rngpnt_avail= %d\n",todo,rngpnt_avail);
#endif

      if (todo > rngpnt_avail)
	 {
         rings = rings + 1;
         rngcnt = 1;
#ifdef DEBUG
printf("  UPDATE RING   rings= %d,  rngcnt= %d\n",rings,rngcnt);
#endif
         }
      dumx = ((xorg - centrdx) / rings) * rngcnt;
      xorg = centrdx + dumx;
      dumy = ((yorg - centrdy) / rings) * rngcnt;
      yorg = centrdy + dumy;

      ipass = 1;
      dumx = (xorg - centrdx) * (xorg - centrdx);
      dumy = (yorg - centrdy) * (yorg - centrdy);

#ifdef DEBUG
printf(" * DIST= %.4lf,  min= %.4lf\n",rand,tmin);
#endif

      if (rand < tmin) goto doagin;
      else goto inchk;            /* go check the ring position  */
/* --------------------------------------------------------             

        Dot coord. is INSIDE Poly, check for HOLES                     
*/
IfIsle:
      if (map->Area[area].n_isles == 0) goto Wdot;
      else
	 {
	 for (ii=0; ii < map->Area[area].n_isles; ii++)
	    {
            island = map->Area[area].isles[ii];
            V2_get_area(map,island,&Areas);

#ifdef DEBUG
printf("   READING island# %d\n",island);
#endif

            INCHECK(map,Areas, &xorg, &yorg);

#ifdef DEBUG
printf("Isle check: iflag= %d, ipass= %d\n",iflag,ipass);
#endif

/* if        coord. INSIDE island (iflag<0) and ring position coord.      
   THEN,      go find another*/
            if ((iflag < 0) && (ipass == 1)) goto doagin;

/* ELSE,   Dot coord. is OUTSIDE any island, check for all other islands    
         Set the flag as 'INSIDE', to continue processing a second      
           coord. position   */
            iflag = -1;
            }
	 }

/*       Coord. position NOT in any existing islands */
	 if (ipass == 1) 
	    {
            V2_get_area(map,area,&Areas);
	    goto Wdot;
	    }

/*       Coord. position for a ring is NOT available  */

doagin:
      dotcnt++;

#ifdef DEBUG
printf(" NO POINT FOR angle = %.2lf   TODO= %d, REMAINING= %d\n",
                 angle,todo,rngpnt_avail);
#endif

      goto cycle;
/* ---------------------------------------------------------  */

/*       Found Ring coord., put it out on display   */
Wdot:  done++; 

#ifdef DEBUG
printf("DOT CNT# %d,  ANG %.4lf, RG.DIST %.4lf, rings= %d, rngcnt= %d\n",
                    done,sang,rand,rings,rngcnt);
#endif

      fprintf(temp,"%lf|%lf|#1\n",xorg,yorg);
rngpnt_avail--;
#ifdef DEBUG
printf("%d dots done, %d dots left\n", done, todo);
#endif
      if (dot_cnt == 1) break;
      }

/*------------------------------------------ All Polys Processed  */
    return(0);
}

INCHECK(map,Area, x, y)
    struct Map_info *map;
    P_AREA *Area;
    double *x, *y;
{
    int cur_line;
    int ab_line;
    int i;
    double area;
    double XJ, YJ, XI1, YI1, temp, temp1, temp2, XN, YN;
    double *xptr1, *yptr1;
    double *xptr2, *yptr2;
    double sqx, sqy;
    static struct line_pnts points;
    static int first_time;	/* 0 on startup */

    iflag = 1;
    if (! Area->n_lines) iflag = -iflag;

    if (first_time == 0)
    {
	points.alloc_points = 0;
	first_time = -1;
    }

    for(cur_line = 0; cur_line < Area->n_lines ; cur_line++)
       {
	ab_line = ABS(Area->lines[cur_line]);
                                 /* read line */
	V2_read_line (map, &points, ab_line);

	xptr1 = points.x;
	yptr1 = points.y;
	xptr2 = points.x + 1;
	yptr2 = points.y + 1;

	for(i=1; i<points.n_points; i++)
	{
	XI1 = XN = *xptr2;
	YI1 = YN = *yptr2;
/*printf("xptr1= %.2lf, yptr1= %.2lf,   XI1= %.2lf, YI1= %.2lf\n",*xptr1,*yptr1,XI1,YI1);*/
	/* for INTERSECTION check, make sure yptr1 > YI1 
	   REVerse is necessary */
        if (*yptr1 < YI1)
	   {
	   temp = *xptr1;
	   *xptr1 = XI1;
	   XI1 = temp;
	   temp = *yptr1;
	   *yptr1 = YI1;
	   YI1 = temp;
	   }
/*printf("y= %.2lf, y1= %.2lf,  yi1= %.2lf\n",*y,*yptr1,YI1);*/
        if (( *y <= *yptr1) && (*y > YI1))
	   {         /* INTERSECTION OCCURS. see if x coord is >  */
/*printf("intersection\n");*/
           temp = *x - *xptr1;
	   temp1 = *y - *yptr1;
	   temp2 = (XI1 - *xptr1) / (YI1 - *yptr1);
	   temp = temp - temp1 * temp2;
	   if (temp < 0) iflag = -iflag;
	   }
      /* get next boundary coord. */
	*xptr1 = XN;
	*yptr1 = YN;

	if (I4 == 0)
	   {  /* keep a running value for min, max */
	   sqx = (*xptr1 - centrdx) * (*xptr1 - centrdx);
	   sqy = (*yptr1 - centrdy) * (*yptr1 - centrdy);
	   if (maxd < sqrt(sqx + sqy)) maxd = sqrt(sqx + sqy);
	   if (mind > sqrt(sqx + sqy)) mind = sqrt(sqx + sqy);
	   }
        xptr2++, yptr2++;
	}

       }
/*if (iflag > 0) printf("iflag = %d, outside\n",iflag);
  if (iflag < 0) printf("iflag = %d, inside\n",iflag);*/
    
  return;
}
