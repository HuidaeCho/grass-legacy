/*  @(#)main.c    1.0  2/26/91  */
/*
**  Created by R.L.Glenn
**  USDA, Soil Conservation Service
**
**  Input arguements:
**        s.to.vect input=site_list file to read
**                  output=vector (digit) file to create
*/
#include <stdio.h>
#include <ctype.h>
#include "gis.h"
#include "Vect.h"

#define MAIN
#define	B_DIG		"dig"
#define	DIG_ATT		"dig_att"
#define	SITE_DIR	"site_lists"

static char  *current_mapset ;
static char  *gbase ;
static char  *location ;

static char *N_dig_file;
static char *N_att_file;
static char *N_site_file;
static char *N_path;
static char *N_name;
static char *S_name;

struct Map_info Map;
struct line_pnts *Points ;

main (argc, argv)
int argc;
char *argv[];
{
    char sname[40], *mapset, desc[256];
    char path[128], map_name[20], buf[200], buf1[200], command[256];
    char *ptr, current[200], *cptr;
    int vect_read, ier, cat;
    int have_old, have_attr, type, have_site;
    int alloc_points, n_points ;
    double *east, *north;
    double *xarray, *yarray;
    FILE *fopen(), *attr, *site ;
    struct Option *sitein, *outvect;
    struct Cell_head window;

    sitein = G_define_option();
    sitein->key          = "input";
    sitein->description  = "Name of site input file";
    sitein->type         = TYPE_STRING;
    sitein->required     = YES;
    sitein->multiple     = NO;

    outvect = G_define_option();
    outvect->key          = "output";
    outvect->description  = "Name of vector output file";
    outvect->type         = TYPE_STRING;
    outvect->required     = YES;
    outvect->multiple     = NO;
    outvect->gisprompt    = "new,dig,vector";

    G_gisinit(argv[0]);
    if (G_parser(argc, argv)) exit(-1);

    new_screen();

    G_get_window (&window);

    new_screen();
    gbase = G_gisbase() ;
    sprintf(path,"%s/%s",G_location_path(),G_mapset());
    N_path = path;

    sprintf(map_name,"%s",outvect->answer);
    sprintf(sname,"%s",sitein->answer);
    have_old = have_site = 0;

    mapset = G_find_vector (map_name, G_mapset());
    if (mapset != NULL)
	{
	sprintf(buf,"[%s] exits. ok to overwrite? ", map_name);
	if (!G_yes (buf,0)) exit(0);
	have_old = 1;
	}
    N_name = map_name;

    mapset = G_find_file (SITE_DIR,sname,"");
    if (mapset == NULL)
	{
	sprintf(buf,"Site file file [%s] not available",sname);
	G_fatal_error(buf) ;
	}
    S_name = sname;
    
    /* store the original file names */
    {

	sprintf (buf, "%s/%s/%s", N_path, "dig", N_name);
	N_dig_file= G_store (buf);

	sprintf (buf, "%s/%s/%s", N_path, "dig_att", N_name);
	N_att_file = G_store (buf);

	sprintf (buf, "%s/%s/%s", N_path, "site_lists", S_name);
	N_site_file = G_store (buf);
    }

    if ((site = fopen (N_site_file, "r+")) != NULL)
	have_site = 1;
    else
    {
	sprintf (buf, "Not able to open site file <%s>\n", N_site_file);
	G_fatal_error (buf);
    }

    if ( (attr = fopen(N_att_file, "w+") ) == NULL )
       {
       sprintf (buf, "Not able to open attribute file <%s>\n", N_att_file);
       G_fatal_error (buf);
       }

    if (have_old)    /* Do initial read of old DIGIT file */
	if ((vect_read = Vect_open_old(&Map,map_name, mapset)) < 0 )
		{
		G_fatal_error("Reading input file.") ;
		exit(-1) ;
		}
    else            /* Create new digit file */
	if ((vect_read = Vect_open_new (&Map, map_name, mapset)) < 0)
		{
		G_fatal_error("Creating new vector file.") ;
		exit(-1) ;
		}

    get_head_info(have_old, &(Map.head));

    printf ("transfering sites to vect file ...\n");

                    /* Initialize the Point structure, ONCE */
    Points = Vect_new_line_struct();
                    /* allocat for DOT type */
    alloc_points = 3;
    xarray = (double *) dig_falloc(alloc_points, sizeof(double));
    yarray = (double *) dig_falloc(alloc_points, sizeof(double));
    east = xarray;
    north = yarray;
    n_points = 2;
    type = DOT;

    while (fgets (buf, sizeof(buf), site) != NULL)
            {
	    if (!isdigit(*buf)) continue;  /* skip comment lines */
            ptr = buf;
            cptr = current;
fprintf(stderr,"got: <%s>\n",buf);
            for (;;)
               {
fprintf(stderr,"1: ptr=<%s>, len= %d\n",ptr,strlen(ptr));
               while (*ptr == ' ' || *ptr == '\t')
		    {
		    *(cptr) = *(ptr);
		    ptr++; cptr++;
		    if (strlen(ptr) == 0) break;
fprintf(stderr,"2: ptr=<%s>, len= %d\n",ptr,strlen(ptr));
		    }
               if (ispunct(*ptr) || *ptr == 0) break;
               if (*ptr == '\174') *(ptr) = '\040';      /* | */
               if (*ptr == '\043') *(ptr) = '\040';      /* # */
               *(cptr) = *(ptr);
fprintf(stderr,"3: ptr=<%s>, len= %d\n",ptr,strlen(ptr));
               ptr++; cptr++;
sleep(2);
               }
fprintf(stderr,"curnt: <%s\n>",current);
  	    ier = sscanf (current, "%lf %lf %d %[^\n]", 
		       &east, &north, &cat, desc);
fprintf(stderr,"\tread %d arguments\n",ier);
  	    if ( ier < 3)
	        {
	        fprintf (stderr, "Bad line '%s'\n", current);
	        continue;
	        }
fprintf(stderr,"e= %lf, n= %lf, cat= %d, desc=<%s>\n",east,north,cat,desc);
              
		     /* make an attribute record */
  	    fprintf(attr,"P %15.7lf %15.7lf%7d\n",east,north,cat); 
fprintf(stderr,"\tattr rec done\n");
                     /* create dig record */
            xarray[1] = xarray[0];
            yarray[1] = yarray[0];
fprintf(stderr,"\tx1y1= %lf,%lf   x2y2= %lf,%lf\n",xarray[0],yarray[0],xarray[1],yarray[1]);
	    if (0 > Vect_copy_xy_to_pnts (Points, xarray, yarray, n_points))
	      G_fatal_error ("Vect_copy error");
fprintf(stderr,"\twrite line\n");
            Vect_write_line (Map, (unsigned int) type, Points);
fprintf(stderr,"next\n");
	    }

    fclose(attr);
    fclose(site);
    Vect_close (&Map);

    printf ("creating support files ...\n");
    sprintf( command, "%s/etc/v.build map=%s thresh=no",gbase, N_name) ;

/*  fprintf(stderr,"%s\n",command);   */
    ier = system ( command );
    if (ier && 0xff00)
	{
	fprintf(stderr, "ERROR(%s):  Could not build digit file: '%s'\n"
			, "v.build", N_name) ;
	exit(-1) ;
	}

    printf("\n<%s> vector file complete\n", N_name); 
    exit (1);
}
