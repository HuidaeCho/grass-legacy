/* Function: logo	Author: P. W. Carlson		5.89
 */

#include "ega_io.h"

static char *scs = "SOIL CONSERVATION SERVICE";
static int grnlines[] = {
	307, 332, 93, 306, 333, 94, 306, 333, 95, 305, 334, 96,
	304, 335, 97, 303, 336, 98, 302, 337, 99, 302, 337, 100,
	301, 338, 101, 300, 339, 102, 299, 340, 103, 298, 341, 104,
	298, 341, 105, 297, 342, 106, 296, 343, 107, 295, 344, 108,
	295, 319, 109, 294, 318, 110, 293, 317, 111, 292, 317, 112,
	291, 316, 113, 291, 315, 114, 290, 314, 115, 289, 313, 116,
	288, 313, 117, 287, 312, 118, 287, 311, 119, 286, 310, 120,
	285, 309, 121, 284, 309, 122, 283, 308, 123, 283, 307, 124,
	282, 306, 125, 281, 305, 126, 280, 305, 127, 279, 304, 128,
	279, 303, 129, 278, 302, 130, 277, 301, 131, 276, 301, 132,
	275, 300, 133, 275, 299, 134, 274, 298, 135, 273, 298, 136,
	272, 297, 137, 272, 296, 138, 271, 295, 139, 270, 294, 140,
	269, 294, 141, 268, 293, 142, 268, 292, 143, 267, 291, 144,
	266, 290, 145, 265, 290, 146, 264, 289, 147, 264, 288, 148,
	263, 287, 149, 262, 286, 150, 262, 286, 151, 261, 285, 152,
	260, 284, 153, 260, 283, 154, 259, 282, 155, 259, 282, 156,
	258, 281, 157, 257, 280, 158, 257, 280, 159, 256, 279, 160,
	256, 279, 161, 256, 278, 162, 255, 277, 163, 255, 277, 164,
	255, 276, 165, 254, 276, 166, 254, 276, 167, 254, 275, 168,
	254, 275, 169, 253, 275, 170, 253, 274, 171, 253, 274, 172,
	253, 274, 173, 253, 274, 174, 253, 274, 175, 253, 274, 176,
	253, 274, 177, 253, 274, 178, 253, 274, 179, 253, 275, 180,
	254, 275, 181, 254, 275, 182, 254, 276, 183, 254, 276, 184,
	255, 276, 185, 255, 277, 186, 255, 277, 187, 256, 278, 188,
	256, 279, 189, 256, 279, 190, 257, 280, 191, 257, 281, 192,
	258, 282, 193, 259, 283, 194, 259, 284, 195, 260, 285, 196,
	260, 286, 197, 261, 287, 198, 262, 288, 199, 263, 290, 200,
	264, 291, 201, 265, 293, 202, 266, 295, 203, 267, 297, 204,
	268, 299, 205, 269, 302, 206, 270, 306, 207, 271, 313, 208,
	272, 366, 209, 274, 364, 210, 275, 363, 211, 277, 361, 212,
	278, 360, 213, 280, 358, 214, 281, 357, 215, 284, 354, 216,
	286, 352, 217, 288, 350, 218, 291, 347, 219, 294, 344, 220,
	298, 340, 221, 303, 335, 222, 311, 327, 223, 327, 367, 208,
	334, 368, 207, 338, 369, 206, 341, 370, 205, 343, 371, 204,
	345, 372, 203, 347, 373, 202, 349, 374, 201, 350, 375, 200,
	352, 376, 199, 353, 377, 198, 354, 378, 197, 355, 378, 196,
	356, 379, 195, 357, 379, 194, 358, 380, 193, 359, 381, 192,
	360, 381, 191, 361, 382, 190, 361, 382, 189, 362, 382, 188,
	363, 383, 187, 363, 383, 186, 364, 383, 185, 364, 384, 184,
	364, 384, 183, 365, 384, 182, 365, 384, 181, 365, 385, 180,
	366, 385, 179, 366, 385, 178, 366, 385, 177, 366, 385, 176,
	366, 385, 175, 366, 385, 174, 366, 385, 173, 366, 385, 172,
	366, 385, 171, 365, 385, 170, 365, 384, 169, 365, 384, 168,
	364, 384, 167, 364, 384, 166, 364, 383, 165, 363, 383, 164,
	363, 383, 163, 362, 382, 162, 361, 382, 161, 361, 382, 160,
	360, 381, 159, 359, 381, 158, 358, 380, 157, 357, 379, 156,
	357, 379, 155, 356, 378, 154, 355, 378, 153, 354, 377, 152,
	354, 376, 151, 353, 377, 150, 352, 376, 149, 351, 375, 148,
	350, 375, 147, 350, 374, 146, 349, 373, 145, 348, 372, 144,
	347, 371, 143, 347, 371, 142, 346, 370, 141, 345, 369, 140,
	344, 368, 139, 343, 367, 138, 343, 367, 137, 342, 366, 136,
	341, 365, 135, 340, 364, 134, 340, 364, 133, 339, 363, 132,
	338, 362, 131, 337, 361, 130, 337, 360, 129, 336, 360, 128,
	335, 359, 127, 334, 358, 126, 333, 357, 125, 333, 356, 124,
	332, 356, 123, 331, 355, 122, 330, 354, 121, 330, 353, 120,
	329, 352, 119, 328, 352, 118, 327, 351, 117, 326, 350, 116,
	326, 349, 115, 325, 348, 114, 324, 348, 113, 323, 347, 112,
	323, 346, 111, 322, 345, 110, 321, 344, 109, 321, 344, 109 };

static int blulines[] = {
	219, 240, 176, 219, 240, 177, 219, 240, 178, 219, 240, 179,
	219, 240, 180, 219, 241, 181, 220, 241, 182, 220, 241, 183,
	220, 241, 184, 220, 241, 185, 220, 242, 186, 220, 242, 187,
	221, 242, 188, 221, 243, 189, 221, 243, 190, 222, 243, 191,
	222, 244, 192, 222, 244, 193, 223, 245, 194, 223, 245, 195,
	223, 246, 196, 224, 246, 197, 224, 247, 198, 225, 248, 199,
	225, 248, 200, 226, 249, 201, 226, 250, 202, 227, 250, 203,
	227, 251, 204, 228, 252, 205, 229, 253, 206, 229, 254, 207,
	230, 255, 208, 231, 256, 209, 231, 257, 210, 232, 258, 211,
	233, 259, 212, 234, 260, 213, 235, 261, 214, 236, 263, 215,
	236, 264, 216, 237, 265, 217, 238, 267, 218, 239, 268, 219,
	240, 270, 220, 242, 272, 221, 243, 274, 222, 244, 276, 223,
	245, 278, 224, 246, 280, 225, 248, 283, 226, 249, 285, 227,
	250, 289, 228, 252, 292, 229, 253, 296, 230, 255, 302, 231,
	257, 311, 232, 258, 380, 233, 260, 378, 234, 261, 377, 235,
	264, 374, 236, 266, 372, 237, 268, 370, 238, 270, 368, 239,
	273, 365, 240, 276, 362, 241, 279, 359, 242, 282, 356, 243,
	286, 352, 244, 290, 348, 245, 295, 343, 246, 301, 337, 247,
	313, 325, 248, 327, 381, 232, 336, 383, 231, 342, 385, 230,
	346, 386, 229, 349, 388, 228, 353, 389, 227, 355, 390, 226,
	358, 392, 225, 360, 393, 224, 362, 394, 223, 364, 395, 222,
	366, 396, 221, 368, 398, 220, 370, 399, 219, 371, 400, 218,
	373, 401, 217, 374, 402, 216, 375, 402, 215, 377, 403, 214,
	378, 404, 213, 379, 405, 212, 380, 406, 211, 381, 407, 210,
	382, 407, 209, 383, 408, 208, 384, 409, 207, 385, 409, 206,
	386, 410, 205, 387, 411, 204, 388, 411, 203, 388, 412, 202,
	389, 412, 201, 390, 413, 200, 390, 413, 199, 391, 414, 198,
	392, 414, 197, 392, 415, 196, 393, 415, 195, 393, 415, 194,
	394, 416, 193, 394, 416, 192, 395, 416, 191, 395, 417, 190,
	395, 417, 189, 396, 417, 188, 396, 418, 187, 396, 418, 186,
	397, 418, 185, 397, 418, 184, 397, 418, 183, 397, 418, 182,
	397, 419, 181, 398, 419, 180, 398, 419, 179, 398, 419, 178,
	398, 419, 177, 398, 419, 176 };
static long asp_sq_1000, inv_asp_sq_1000;

logo() 
{ 
    register int *ptr;
    register n;
    double cx, cy, aspect, w, f;

    /* compute logo location and size */
    cx = 0.5 * (double)H_RES;
    cy = 0.5 * (double)V_RES;
    w = 1.35 * 8 * strlen(scs);
    aspect = ((double)H_RES / (double)V_RES) * (3.0 / 4.0);
    f = w / aspect;

    /* compute the factors for plotting arcs */
    asp_sq_1000 = (long)(1000.0 * aspect * aspect);
    inv_asp_sq_1000 = (long)(1000.0 / (aspect * aspect));

    /* do the blue teardrop */
    args.arg1 = 1;
    ioctl(egafd, EGA_SETCOLOR, &args);
    movem((int)(cx + 0.216506 * w), (int)(cy - 0.125 * f));
    drawem((int)(cx + 0.048113 * w), (int)(cy - 0.416667 * f));
    drawem((int)(cx - 0.048113 * w), (int)(cy - 0.416667 * f));
    drawem((int)(cx - 0.216506 * w), (int)(cy - 0.125 * f));
    carc((int)(cx - 1), (int)cy, (int)(0.25 * w), (int)(cy - 0.125 * f));
    movem((int)(cx + 0.144338 * w), (int)(cy - 0.08333333 * f));
    drawem((int)cx, (int)(cy - 0.3333333 * f));
    drawem((int)(cx - 0.144338 * w), (int)(cy - 0.08333333 * f));
    carc((int)cx, (int)cy, (int)(0.1666667 * w), (int)(cy - 0.08333333 * f));
    ptr = grnlines;
    for (n = 0; n < 232; n++)
    {   args.arg1 = *ptr++;
	args.arg2 = *ptr++;
	args.arg3 = *ptr++;
	ioctl(egafd, EGA_HORLINE, &args);
    }

    /* do the green earth */
    args.arg1 = 2;
    ioctl(egafd, EGA_SETCOLOR, &args);
    movem((int)(cx - 0.375 * w), (int)cy);
    drawem((int)(cx - 0.291667 * w), (int)cy);
    carc((int)(cx - 1), (int)cy, (int)(0.2916667 * w), (int)cy);
    movem((int)(cx + 0.291667 * w), (int)cy);
    drawem((int)(cx + 0.375 * w) - 1, (int)cy);
    carc((int)(cx - 1), (int)cy, (int)(0.375 * w), (int)cy);
    ptr = blulines;
    for (n = 0; n < 130; n++)
    {   args.arg1 = *ptr++;
	args.arg2 = *ptr++;
	args.arg3 = *ptr++;
	ioctl(egafd, EGA_HORLINE, &args);
    }

    /* do the white text */
    args.arg1 = 7;
    ioctl(egafd, EGA_SETCOLOR, &args);
    args.arg1 = (int)(cx - 0.375 * w) + 2;
    args.arg2 = (int)(cy + 0.458333 * f) + 6;
    args.arg3 = 25;
    args.ptr1 = (unsigned char *)scs;
    ioctl(egafd, EGA_BITTEXT, &args);


    /* do the white border */
    movem((int)(cx - 0.375 * w), (int)(cy - 0.541667 * f));
    drawem((int)(cx + 0.375 * w), (int)(cy - 0.541667 * f));
    qc(1, (int)(cx + 0.375 * w), (int)(cy - 0.416667 * f), (int)(0.125 * w));
    movem((int)(cx + 0.5 * w) - 1, (int)(cy - 0.416667 * f));
    drawem((int)(cx + 0.5 * w) - 1, (int)(cy + 0.416667 * f));
    qc(2, (int)(cx + 0.375 * w), (int)(cy + 0.416667 * f), (int)(0.125 * w));
    movem((int)(cx - 0.375 * w), (int)(cy + 0.541667 * f));
    drawem((int)(cx + 0.375 * w), (int)(cy + 0.541667 * f));
    qc(3, (int)(cx - 0.375 * w), (int)(cy + 0.416667 * f), (int)(0.125 * w));
    movem((int)(cx - 0.5 * w), (int)(cy - 0.416667 * f));
    drawem((int)(cx - 0.5 * w), (int)(cy + 0.416667 * f));
    qc(4, (int)(cx - 0.375 * w), (int)(cy - 0.416667 * f), (int)(0.125 * w));

} 


static movem(x, y)
int x, y;
{
    args.arg1 = x;
    args.arg2 = y;
    ioctl(egafd, EGA_MOVE, &args);
}



static drawem(x, y)
int x, y;
{
    args.arg1 = x;
    args.arg2 = y;
    ioctl(egafd, EGA_DRAW, &args);
}
 

/* Function: carc
** This function plots all the points on a circular arc that
** are greater than the minimum y value.
*/
carc(cx, cy, r, min) 
int cx, cy, r, min; 
{ 
    int x, y; 
    long int dx1000, dy1000, prevdx, prevdy, savdx, savdy; 
    long int radius, dx, dy; 
     
    radius = (long)r; 
    dx = prevdx = radius; 
    dx1000 = 1000 * dx;
    for ( dy = 0; dy < dx; dy++) 
    {   dx1000 -= (dy * asp_sq_1000) / dx;
        dx = (dx1000 + 500) / 1000;
	savdx = dx; 
	y = (int)dy; 
	do 
	{   x = (int)dx; 
	    if (cy - y > min) 
	    {	args.arg1 = cx + x;
    		args.arg2 = cy - y;
    		ioctl(egafd, EGA_SETPIX, &args);
    		args.arg1 = cx - x;
    		ioctl(egafd, EGA_SETPIX, &args);
	    } 
	    args.arg1 = cx - x;
    	    args.arg2 = cy + y;
    	    ioctl(egafd, EGA_SETPIX, &args);
	    args.arg1 = cx + x;
    	    ioctl(egafd, EGA_SETPIX, &args);
	} while (++dx < prevdx); 
	dx = savdx; 
	prevdx = dx; 
    } 
    prevdy = dy; 
    dy1000 = 1000 * dy;
    dx--; 
    do 
    {	dy = (dy1000 + 500) / 1000;
	savdy = dy; 
	x = (int)dx; 
	do 
	{   y = (int)dy; 
	    if (cy - y > min) 
	    {	args.arg1 = cx + x;
    		args.arg2 = cy - y;
    		ioctl(egafd, EGA_SETPIX, &args);
    		args.arg1 = cx - x;
    		ioctl(egafd, EGA_SETPIX, &args);
	    } 
	    args.arg1 = cx - x;
    	    args.arg2 = cy + y;
    	    ioctl(egafd, EGA_SETPIX, &args);
	    args.arg1 = cx + x;
    	    ioctl(egafd, EGA_SETPIX, &args);
	} while (--dy > prevdy); 
	dy = savdy; 
	prevdy = dy; 
	dy1000 += ((dx - 1) * inv_asp_sq_1000) / (long)y; 
    } while (dx-- >= 0);		 
} 
 
 
/* Function: qc
** This function draws a quadrant of a circle.  The quadrants are:
**		4 1
**		3 2
*/
qc(quad, cx, cy, r) 
int quad, cx, cy, r; 
{ 
    int x, y; 
    long int dx1000, dy1000, prevdx, prevdy, savdx, savdy; 
    long int radius, dx, dy; 
     
    radius = (long)r; 
    dx = prevdx = radius; 
    dx1000 = 1000 * dx;
    for ( dy = 0; dy < dx; dy++) 
    {   dx1000 -= (dy * asp_sq_1000) / dx;
        dx = (dx1000 + 500) / 1000;
	savdx = dx; 
	y = (int)dy; 
	do 
	{   x = (int)dx; 
	    switch (quad)
	    {   case 1:	args.arg1 = cx + x;
            		args.arg2 = cy - y;
			break;
	        case 2:	args.arg1 = cx + x;
            		args.arg2 = cy + y;
			break;
	        case 3:	args.arg1 = cx - x;
            		args.arg2 = cy + y;
			break;
	        case 4:	args.arg1 = cx - x;
            		args.arg2 = cy - y;
			break;
	    }
            ioctl(egafd, EGA_SETPIX, &args);
	} while (++dx < prevdx); 
	dx = savdx; 
	prevdx = dx; 
    } 
    prevdy = dy; 
    dy1000 = 1000 * dy;
    dx--; 
    do 
    {	dy = (dy1000 + 500) / 1000;
	savdy = dy; 
	x = (int)dx; 
	do 
	{   y = (int)dy; 
	    switch (quad)
	    {   case 1:	args.arg1 = cx + x;
            		args.arg2 = cy - y;
			break;
	        case 2:	args.arg1 = cx + x;
            		args.arg2 = cy + y;
			break;
	        case 3:	args.arg1 = cx - x;
            		args.arg2 = cy + y;
			break;
	        case 4:	args.arg1 = cx - x;
            		args.arg2 = cy - y;
			break;
	    }
            ioctl(egafd, EGA_SETPIX, &args);
	} while (--dy > prevdy); 
	dy = savdy; 
	prevdy = dy; 
	dy1000 += ((dx - 1) * inv_asp_sq_1000) / (long)y; 
    } while (dx-- >= 0);		 
} 
