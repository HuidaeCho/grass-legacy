
#include "gis.h"
#include <gl.h>
#include <device.h>
#include <math.h>
#include "digit.h"

/*#define MAIN*/
#include "externs.h"

long Main_Win;
/*double atof();*/
char *getenv();

Dcell (elev, name1, name2, name3, vname)
    char *elev;
    char *name1;
    char *name2;
    char *name3;
    char *vname;
{
    char *elev_map;
    char *name1_map;
    char *name2_map;
    char *name3_map;
    char *vect_map;
    int i;
    /*struct Cell_head wind;*/
    char buff[128];
    FILEDESC cellfile1 = NULL;
    FILEDESC cellfile2 = NULL;
    FILEDESC cellfile3 = NULL;
    FILEDESC elev_cell = NULL;
    CELL *xarray;
    struct Range Range;
    long *color_array;
    int row, col;
    int t, b, l, r;
    char *p;
    int j, k;
    int dev;
    short val;
    /*float Z_Span, Z_Span2;*/

    float xfrom, yfrom, zfrom, xto, yto, zto;


    i = j = k = 0;

    keepaspect (1, 1);


/******************************************************************************/
    G_get_set_window (&wind) ; /* ok */

    /* get Z range */
    elev_map = G_find_file2 ("cell", elev, "");
    G_read_range (elev, elev_map, &Range);
    if (!(Z_Min = Range.nmin))
	Z_Min = Range.pmin;
    if (!(Z_Max = Range.pmax))
	Z_Max = Range.nmax;
    if (!Z_Min && !Z_Max)
    {
	fprintf (stderr, "Please update the stats (support) for file %s\n", elev);
	Z_Min = -2000; Z_Max = 2000;
    }

    if ((p = getenv ("ZMAX")) != NULL)
	Z_Max = atof (p);
    if ((p = getenv ("ZMIN")) != NULL)
	Z_Min = atof (p);

    
    X_Span_real = wind.east - wind.west;
    Y_Span_real = wind.north - wind.south;
    

    /*
    ** find direction of greatest range
    */
    if (X_Span_real > Y_Span_real)
	Max_Span = X_Span_real;
    else
	Max_Span = Y_Span_real;

    if (Max_Span < Z_Span_real)
	Max_Span = Z_Span_real;


    /*
    **  have to shrink down the world space
    **  because of Z-buffer accuracy limitations
    */
    {
	X_Min = 0.;
	X_Max = 1.;
	Y_Min = 0.;
	Y_Max = 1.;
	Z_Min = 0.;
	Z_Max = 1.;
    }

    Z_Span_real = Z_Span = Z_Max - Z_Min;
    Z_Min_real = Z_Min;
    Z_Max_real = Z_Max;
    Z_Min -= Z_Span*5;
    Z_Max += Z_Span*10;
    Z_Span = 1.;


    /* DEFINE the object space */
    /*  This needs to be modified for z-buffer range 
    X_Min = wind.west;
    X_Max = wind.east;
    Y_Min = wind.south;
    Y_Max = wind.north;
    */


    X_Mid = (X_Max + X_Min) / 2.;
    Y_Mid = (Y_Max + Y_Min) / 2.;
    Z_Mid = (Z_Max + Z_Min) / 2.;

    X_Res = wind.ew_res;
    Y_Res = wind.ns_res;

/*DEBUG*/  fprintf (stderr, "x (%d,%d)  y (%d,%d)  z (%f,%f)\n", X_Min, X_Max,Y_Min, Y_Max,Z_Min, Z_Max);

    if (vname == NULL)
	Vect_file = 0;
    else
    {
	vect_map = G_find_file2 ("dig", vname, "");
	Vect_file = 1;
	Vect_z = Z_Min;
	if (NULL == (Vect_fp = G_fopen_old ("dig", vname, vect_map)))
	    Vect_file = 0;
	else
	{
	    dig_init (Vect_fp);
/*DEBUG*/  fprintf (stderr, "BOX: %lf %lf %lf %lf\n", wind.north, wind.south, wind.east, wind.west);
	    dig_init_box (wind.north, wind.south, wind.east, wind.west);
	}
    }

/******************************************************************************/

    /*
    foreground ();
    */
    prefposition (10, 700, 300, 1000);
    Main_Win = winopen ("3D SGI");
    winconstraints ();
    winconstraints ();

    concave (1);

    RGBmode ();
    doublebuffer ();
    gconfig ();

    getviewport (&left, &right, &bottom, &top);

    buff_init ();


    getorigin (&X_Size, &Y_Size);
    xcenter = ((left + right) >> 1 ) + X_Size;
    ycenter = ((top + bottom) >> 1 ) + Y_Size;

    cpack (0);
    clear ();
    swapbuffers ();

    zbuffer (1);
    lsetdepth (0, 0x7fffff);
    zclear ();
    zfunction (ZF_LEQUAL);


    Y_Size = wind.rows;
    X_Size = wind.cols;

    initialize ();


/******************************************************************************/



    /*
    if (!name2)
    {
	Three_map = 0;
    }
    else
	Three_map = 1;
    */

/* Make sure maps are available */
    /*elev_map = G_find_file2 ("cell", elev, "");*/
    if ((elev_cell = G_open_cell_old(elev, elev_map)) == -1) 
    {
	sprintf(buff,"Not able to open cellfile for [%s]", elev);
	G_fatal_error(buff);
    }
    name1_map = G_find_file2 ("cell", name1, "");
    if ((cellfile1 = G_open_cell_old(name1, name1_map)) == -1) 
    {
	sprintf(buff,"Not able to open cellfile for [%s]", name1);
	G_fatal_error(buff);
    }
    if (Three_map)
    {
	name2_map = G_find_file2 ("cell", name2, "");
	if ((cellfile2 = G_open_cell_old(name2, name2_map)) == -1) 
	{
	    sprintf(buff,"Not able to open cellfile for [%s]", name2);
	    G_fatal_error(buff);
	}
	name3_map = G_find_file2 ("cell", name3, "");
	if ((cellfile3 = G_open_cell_old(name3, name3_map)) == -1) 
	{
	    sprintf(buff,"Not able to open cellfile for [%s]", name3);
	    G_fatal_error(buff);
	}
    }
    else
    {
	G_read_colors (name1, name1_map, &Pcolor);
    }

/* Allocate space for cell buffer */
    xarray = (int *)G_malloc (X_Size * sizeof (int));
    color_array = (long *)G_malloc (X_Size * sizeof (long));



/* alllocate buffers */
    visual = (int *)G_malloc (X_Size * Y_Size * sizeof (int));

    elev_buf = (int *)G_malloc (X_Size * Y_Size * sizeof (int));

/******************************************************************************/


    fprintf (stderr, "Initial load of data:  ");

    for (row = 0; row < Y_Size ; row++) 
    {
	int row_off;

	row_off = row * X_Size;

	G_get_map_row(elev_cell, &(elev_buf[row_off]), row) ; 

	if (Three_map)
	{
	    G_get_map_row (cellfile1, xarray, row); 
	    for (i = 0 ; i < X_Size ; i++)
		color_array[i] = xarray[i] & 0xff;

	    G_get_map_row (cellfile2, xarray, row); 
	    for (i = 0 ; i < X_Size ; i++)
		color_array[i] |= (xarray[i] & 0xff) << 8;
	
	    G_get_map_row (cellfile3, xarray, row); 

	    /* finish the composite color array */
	    for (i = 0 ; i < X_Size ; i++)
		visual[row_off+i] = color_array[i] | ((xarray[i]&0xff)<<16);
	}
	else
	{
	    /*G_get_map_row (cellfile1, &(visual[row*X_Size]), row); */
	    G_get_map_row (cellfile1, xarray, row); 
	    /* shift values down (or up) to start at 1 */
	    /* note will need to subtract 1 to index color arrays */
	    for (i = 0 ; i < X_Size ; i++)
	    {
		visual[row_off+i] = !xarray[i] ? 0 : xarray[i]-Pcolor.min+1;
	    }
	}
    }
    G_close_cell(elev_cell);
    G_close_cell(cellfile1);
    if (Three_map)
    {
	G_close_cell(cellfile2);
	G_close_cell(cellfile3);
    }
    free (xarray);
    free (color_array);

    fprintf (stderr, "Done.\n");

/******************************************************************************/


    initialize2 ();

    /*
    cpack (0);
    clear ();
    zclear ();
    cpack (0xcfcfcfcf);
    display_lines (X_Mod, Y_Mod, shading);
    swapbuffers ();
    */


    {
	Actuator *a;

	redraw_ok = 1;
	while (1)
	{
	    a = pnl_dopanel ();
	    if (Main_Win == pnl_userredraw ())
	    {
		redraw_ok = 1;
		reshapeviewport ();
		redraw_event ();
	    }

	    serve_actuator (a);
	}
    }
}

update_projection ()
{
    /*perspective (persp, 1., .1, 20000.);ORIG*/
    perspective (persp, 1., 20, 20000.);
    lookat(FROM_TO[FROM][X],FROM_TO[FROM][Y],FROM_TO[FROM][Z],
           FROM_TO[TO][X],FROM_TO[TO][Y],FROM_TO[TO][Z], (int) Alook->val-900);
}

initialize ()
{
    linesmooth (1);
    install_panels ();

    XBase = X_Min - (X_Max - X_Mid);
    YBase = Y_Min - (Y_Max - Y_Mid);
    ZBase = Z_Min;

    XRange = X_Max + (X_Max - X_Mid) - XBase;
    YRange = Y_Max + (Y_Max - Y_Mid) - YBase;
    ZRange = Z_Max + (Z_Max - Z_Min) - ZBase;


    UNIT_FROM_TO[FROM][X] = 0.;
    UNIT_FROM_TO[FROM][Y] = 0.;
    UNIT_FROM_TO[FROM][Z] = 0.;
    UNIT_FROM_TO[FROM][3] = 1.;
    UNIT_FROM_TO[TO][X] = 1000.;
    UNIT_FROM_TO[TO][Y] = 0.;
    UNIT_FROM_TO[TO][Z] = 0.;
    UNIT_FROM_TO[TO][3] = 1.;

    persp = 400;


    /* for transform_fromto () */
    P_pushmatrix ();

}

initialize2 ()
{
    fast_res = X_Mod = Y_Mod = XMOD;
    slow_res = X_Modr = Y_Modr = 2.;
    update_fast_res();
    update_slow_res();


    Display_type = D_POLY;
    Apoly->val = 1;
    Apoly->dirtycnt = 2;
    pnl_fixact (Apoly);
    Agrid->val = 0;
    Agrid->dirtycnt = 2;
    pnl_fixact (Agrid);
    Agridc->val = 0;
    Agridc->dirtycnt = 2;
    pnl_fixact (Agridc);
    Agpoly->val = 0;
    Agpoly->dirtycnt = 2;
    pnl_fixact (Agpoly);

    shading = 1;
    Ashading->val = shading;
    Ashading->dirtycnt = 2;
    pnl_fixact (Ashading);

    Z_exag = 1.;			/* (* 10 == 1.0) */
    Aexag->val = 0.1;
    Aexag->dirtycnt = 2;
    pnl_fixact (Aexag);

    Avectz->val = 0.1;
    Avectz->dirtycnt = 2;
    pnl_fixact (Avectz);

    Afringe->val = Fringe_on = 1;
    Afringe->dirtycnt = 2;
    pnl_fixact (Afringe);


    /* generate starting point for viewpoint */
    FROM_TO[0][0] = X_Mid;
    FROM_TO[0][1] = Y_Min - (Y_Max - Y_Min);
    FROM_TO[0][2] = Z_Max + (Z_Max - Z_Min);
    FROM_TO[0][3] = 1.;
    FROM_TO[1][0] = X_Mid;
    FROM_TO[1][1] = Y_Mid;
    FROM_TO[1][2] = Z_Mid;
    FROM_TO[1][3] = 1.;
    
    /* Init Actuators */
    Alook->val = 900.0;
    pnl_fixact (Alook);

    Aincl->val = 300.0;
    pnl_fixact (Aincl);

    PNL_ACCESS (Point, Axy, x) = .5;
    PNL_ACCESS (Point, Axy, y) = 0.;
    pnl_fixact (Axy);

    Aheight->val = .5;
    pnl_fixact (Aheight);

    Apersp->val = 400.;
    pnl_fixact (Apersp);


    update_persp ();
    update_height ();
    update_xy ();
    update_view_dir ();


    /* initialize Object Actuators */
}

redraw_event ()
{
	int x, y;
	getviewport (&left, &right, &bottom, &top);

	getorigin (&x, &y);
	xcenter = ((left + right) >> 1 ) + x;
	ycenter = ((top + bottom) >> 1 ) + y;

	cpack (0);
	clear ();
	swapbuffers ();
}

leave ()
{
    gexit ();
    exit (0);
}
