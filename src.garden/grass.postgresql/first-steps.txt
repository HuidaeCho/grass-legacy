------------------------------------------------
GRASS and PostgreSQL - First Steps
------------------------------------------------
$Id$

Recommended reading:
  http://www.postgresql.org/docs/tutorial/index.html

---------------------
General Module Overview:
  By Alex Shevlakov <sixote@yahoo.com>

Modules in this pack, in general, provide the following functions.

1. g.select.pg - select a database to use with GRASS.

2. g.table.pg - list tables in currently selected DB.

3. g.columns.pg - list columns information in a table of the selected DB.

4. g.stats.pg - calculate means, min,max, frequencies for a specified
   numeric column.

5. d.site.pg - display and optionally copy/reclass sites selected 
   with a DB query. 

6. d.vect.pg - display lines/areas selected with a DB query.

7. d.rast.pg - display(optionally) and reclass raster maps with a DB query.

8. d.what.s.pg - query sites on graphics monitor with mouse. Like
   d.what.sites, it gives coordinates, but lists all attributes. Gives 
   option to geometry filter sites and dump the fields in comma-separated 
   lists for other statistics programs (like R or Gnumeric).

9. d.what.v.pg - query lines/areas with mouse. Like d.what.vect, lists 
   attributes. Optionally fills queried areas (like v.area). May be used 
   for the UPDATE command in Postgres through the input SQL file. The idea 
   is to prepare an arbitrary algorithm, code it in SQL, and then update DB 
   with clicking on chosen polys/lines. You may consider this as piping 
   anything you grabbed on screen through various filters.

10. d.what.r.pg - does the same as above on the raster maps.

11. v.reclass.pg - reclasses vector maps according to the 
    SELECT filter.

12. v.in.shape.pg - does the same as the v.in.shape module plus dumping the
    relevant dbf information directly to postgres table. Although, using 
    the module v.in.shape versus v.in.arc seems not quite an idea, since as 
    Frank Warmerdam who wrote v.in.shape points out:
        "Label for polygons are located on the edge, rather than
     interior to the polygon.  This is ambiguous in cases of
     polygons that share boundaries with other polygons and will
     cause conflicts when running v.support."
    So if you imported a coverage with polygons whose attributes were 
    stored in dbf-file by means of ArcView shapefile (and v.in.shape.pg), 
    the table data would be relevant to polys, while labels would now 
    belong to lines (after v.support really gets confused).
    If you are not bothered with this fact (say importing lines), 
    then try use v.in.shape.pg. 

   Admin/normal_user dump modes differ in the way the new records inserted.
   Admin takes  less time, while "normal user" dump is accompanied with HDD 
   rattles. This is due to safety limitation of Postgres which allows direct 
   copying of large files to its super-users only.

13. v.in.arc.pg - works in interactive mode. A lot more straightforward than 
    the original "v.in.arc". Just UNGEN lines and points in arc/info, then 
    copy the lines and labels files to your work directory (yes, no need to 
    dig them into /db/your_database/your_name/arc), and also copy PAT.dbf 
    (or AAT.dbf) there too, possibly renaming them to more reasonable names, 
    as these would be taken by Postgres tables when they are created.
    Then run v.in.arc.pg and it would create area/line coverages (with 
    categories set to line/areas id's) plus dump the dbf to postgres. Then
    you would probably want to run v.reclass.pg to set proper cats.

14. pg.in.dbf - just the hatcheted dumper from the two above modules. Takes
    DBF file name from user and dumps all columns to postgres.

15. NVIZ2.2 - Postgres interface.
    I have added new entries field in the "What's here" panel; Postgres 
    queries may be disabled in "Attributes" checkbox.

Bugs and other possible caveats reports are welcome.
Alex Shevlakov,
sixote@yahoo.com

==================================================================
Small introduction to GRASS/PostgreSQL interface
by 
  Markus Neteler


  The following text shall introduce you to the interface
  usage. This text is subject to be improved...

Let's start.
Enter GRASS 5. Of course you need to have a location
defined and some data you want to import here.

------------------------------------------------------------------------
A) First see, if PostgreSQL is working:
------------------------------------------------------------------------

g.select.pg -l

Error: select Postgres:connectDB() failed: Is the postmaster running and
accepting TCP/IP(with -i) connections at '130.77.22.66' on port '5432'?

See for the log file:
cat /var/log/postgresql.log

-> No data directory -- can't proceed.
/usr/lib/pgsql/bin/postmaster does not find the database system.  Expected
to find it in the PGDATA directory "/var/lib/pgsql/data", but unable to open
file with pathname "/var/lib/pgsql/data/base/template1/pg_class".

O.k. This tells us (here: SuSe Linux, names may be different in your
installation): 
   - pg_datab.rpm needs to be installed
   - ps_ifa.rpm, maybe pg_iface.rpm

Restart the "postmaster" (the daemon listening for db-queries):
cd /sbin/init.d/rc2.d/
./S25postgres start

ps -ax |grep postmaster

Is postmaster there? It should now.

Check again, if it working now:

g.select.pg -l

If you get the error:
Error: select Postgres:User authentication failed

you need to setup the PostgreSQL user's list. Enter:
  su

Set a password for user "postgres" (first time only!):
  passwd postgres
  [set the password]
  exit

Now login as user "postgres":
  su - postgres

and add yourself as PostgreSQL-user:
  createuser neteler
  Enter user's postgres ID or RETURN to use unix user ID: 601 -> <return>
  Is user "neteler" allowed to create databases (y/n) y
  Is user "neteler" allowed to add users? (y/n) n
 createuser: neteler was successfully added

  exit

Now you are again back in GRASS environment:
  g.select.pg -l
    The following databases are in the Unix catalogue:
    template1

This indicates that you PostgreSQL environment is o.k.
Fine. Now we can proceed.

------------------------------------------------------------------------
B) Using GRASS/PostgreSQL: creating a database table
------------------------------------------------------------------------

Say, you have a SHAPE-file set: humus.shp, humus.shx and humus.dbf.
The file *.shp will go into GRASS, the file *.dbf to PostgreSQL.

Usually you will use "createdb" do create database tables.
First we create an empty pg-table:

  createdb humus

This new table we select in GRASS:
  g.select.pg database=humus

[BTW: To destroy a database use: destroydb humus]

Import the Dbase-table into PostgreSQL:
  pg.in.dbf in=humus.dbf 

  Executing create table humus (AREA float4,PERIMETER float4,G2_UEB09_
  int8,G2_UEB09_I int8,STONR int4,BOTYP text,HORIZ text,BODART text,HUMUS
  float4,SKELETT text)

You will be asked: Additionally dump to ASCII file (enter full Unix name or
                   hit <Enter> for none):
Enter "ENTER" if you don't need the additional ASCII file in your local
directory.

The table is imported into PostgreSQL now.

------------------------------------------------------------------------
C) Getting simple table statistics
------------------------------------------------------------------------

g.stats.pg table=humus col=BOTYP
  Error: connect Postgres:ERROR:  No such function 'min' with the specified
  attributes

The reason is that BOTYP is a text field (yes, see above!). We cannot
calculate statistics from letters. So we try another field:

g.stats.pg table=humus col=HUMUS
       Min,        Max,       Mean
-------------------------------------
         0,       2.81,    1.72372

Aha, quite nice. It tells us about humus contents in percent.

------------------------------------------------------------------------
D) Importing a SHAPE file with DBASE table (*.dbf)
------------------------------------------------------------------------

Now it is getting more amazing! We will import our SHAPE file:
Using "verbose=9" we get information about import progress.

  v.in.shape.pg input=humus.shp verbose=9 

NOTE: You don't have to import the .dfb table manually. It is
done by v.in.shape.pg automatically (many thanks to Alex Shevlakov)!

See if the map there:
  g.list vect
----------------------------------------------
vector files available in mapset geosum:
humus
----------------------------------------------

Create topology:
  v.support m=humus o=build

Get a GRASS monitor:
  d.mon x0

Display the map:
  d.vect humus

Query it using PostgreSQL:
   d.what.v.pg -f m=humus tab=humus col=HUMUS

-> Now we see that v.in.shape[.pg] only supports lines
   but not areas. We hope for an upgrade...

Interim solution:
 - import vector maps as E00 or ungenerate files instead of SHAPE
 - rename to table name then to assign the PG-table to
   your map "virtually"

------------------------------------------------------------------------
E) Get table information
------------------------------------------------------------------------

  g.column.pg -v table=humus

 | columnname               | type      | length     |
 ----------------------------------------------------
 | area                     | float4    |          4 |
 | perimeter                | float4    |          4 |
 | g2_ueb09_                | int8      |          8 |
 | g2_ueb09_i               | int8      |          8 |
 | stonr                    | int4      |          4 |
 | botyp                    | text      |        var |
 | horiz                    | text      |        var |
 | bodart                   | text      |        var |
 | humus                    | float4    |          4 |
 | skelett                  | text      |        var |

As you can see you get information about the field types.

------------------------------------------------------------------------
F) Selecting table entries and displaying on the map:
------------------------------------------------------------------------

d.vect.pg

create an ASCII file "sql.query"  (using an text editor) with contents:
  select * from humus where HUMUS > 1.2;

[change "humus" to your table name and "HUMUS" to a column existing
 in your table]

Now query:
 d.vect.pg -sf sql=sql.query map=humus

You need to specify "-s" to use the sql statements file!

Alternative method: Write query into command line:
 d.vect.pg -f key=HUMUS tab=humus where='HUMUS>1.2' map=humus col=red
   Executing
   SELECT Distinct HUMUS from humus  where  HUMUS>1.2 and HUMUS is not null;
   16 Rows

 key is the column name, tab the table, and where the statement.
 "-f" fills the selected areas, col defines their colors.

 Now you see the selected areas in the GRASS Monitor.

------------------------------------------------------------------------
G) Reclass of vector map
------------------------------------------------------------------------
v.reclass.pg  


Please send improvements to
Markus Neteler
neteler@geog.uni-hannover.de
